<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>synchromoodle.synchronizer API documentation</title>
<meta name="description" content="Synchronizer" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>synchromoodle.synchronizer</code></h1>
</header>
<section id="section-intro">
<p>Synchronizer</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># coding: utf-8
&#34;&#34;&#34;
Synchronizer
&#34;&#34;&#34;

import datetime
import re
import os
from logging import getLogger
from typing import Dict, List
from enum import Enum

from synchromoodle.arguments import DEFAULT_ARGS
from synchromoodle.config import EtablissementsConfig, Config, ActionConfig
from synchromoodle.dbutils import Database, PROFONDEUR_CTX_ETAB, COURSE_MODULES_MODULE, \
    PROFONDEUR_CTX_MODULE_ZONE_PRIVEE, \
    PROFONDEUR_CTX_BLOCK_ZONE_PRIVEE
from synchromoodle.ldaputils import Ldap, EleveLdap, EnseignantLdap, PersonneLdap
from synchromoodle.ldaputils import StructureLdap

#######################################
# FORUM
#######################################
# Nom du forum pour la zone privee
# Le (%s) est reserve a l&#39;organisation unit de l&#39;etablissement
from synchromoodle.webserviceutils import WebService

FORUM_NAME_ZONE_PRIVEE = &#34;Forum réservé au personnel éducatif de l&#39;établissement %s&#34;

# Format d&#39;intro. pour le forum de la zone privee
FORUM_INTRO_FORMAT_ZONE_PRIVEE = 1

# Introduction pour le forum de la zone privee
FORUM_INTRO_ZONE_PRIVEE = &#34;&lt;p&gt;&lt;/p&gt;&#34;

# Max attachements pour le forum de la zone privee
FORUM_MAX_ATTACHEMENTS_ZONE_PRIVEE = 2

# Max bytes pour le forum de la zone privee
FORUM_MAX_BYTES_ZONE_PRIVEE = 512000

#######################################
# BLOCKS
#######################################
# Default region pour le bloc de recherche sur le forum de la zone privee
BLOCK_FORUM_SEARCH_DEFAULT_REGION = &#34;side-pre&#34;

# Default weight pour le bloc de recherche sur le forum de la zone privee
BLOCK_FORUM_SEARCH_DEFAULT_WEIGHT = 2

# Nom pour le bloc de recherche sur le forum de la zone privee
BLOCK_FORUM_SEARCH_NAME = &#34;searches_forums&#34;

# Page type pattern pour le bloc de recherche sur le forum de la zone privee
BLOCK_FORUM_SEARCH_PAGE_TYPE_PATTERN = &#34;course-view-*&#34;

# Show in sub context option pour le bloc de recherche sur le forum de la zone privee
BLOCK_FORUM_SEARCH_SHOW_IN_SUB_CTX = 0

# Sub page pattern pour le bloc de recherche sur le forum de la zone privee
BLOCK_FORUM_SEARCH_SUB_PAGE_PATTERN = &#34;&#34;

SECONDS_PER_DAY = 86400

def est_grp_etab(uai: str, etablissements_config: EtablissementsConfig):
    &#34;&#34;&#34;
    Indique si un établissement fait partie d&#39;un regroupement d&#39;établissement ou non
    :param uai: code de l&#39;établissement
    :param etablissements_config: EtablissementsConfig
    :return: True si l&#39;établissement fait partie d&#39;un regroupement d&#39;établissement
    &#34;&#34;&#34;
    for regroupement in etablissements_config.etabRgp:
        if uai in regroupement.uais:
            return regroupement
    return False


class SyncContext:
    &#34;&#34;&#34;
    Contexte global de synchronisation
    &#34;&#34;&#34;

    def __init__(self):
        self.timestamp_now_sql = None
        self.map_etab_domaine = None  # type: Dict[str, List[str]]
        self.id_context_categorie_inter_etabs = None  # type: int
        self.id_context_categorie_inter_cfa = None  # type: int
        self.id_role_extended_teacher = None  # type: int
        self.id_role_advanced_teacher = None  # type: int
        self.id_field_classe = None  # type: int
        self.id_field_domaine = None  # type: int
        self.utilisateurs_by_cohortes = {}


class EtablissementContext:
    &#34;&#34;&#34;
    Contexte de synchronisation d&#39;établissement
    &#34;&#34;&#34;

    def __init__(self, uai: str):
        self.uai = uai  # type: str
        self.id_context_categorie = None
        self.id_context_course_forum = None
        self.etablissement_regroupe = None
        self.structure_ldap = None  # type: StructureLdap
        self.gere_admin_local = None  # type: bool
        self.regexp_admin_moodle = None  # type: str
        self.regexp_admin_local = None  # type: str
        self.id_zone_privee = None  # type: int
        self.etablissement_theme = None  # type: str
        self.eleves_by_cohortes = {}
        self.enseignants_by_cohortes = {}
        self.classe_to_niv_formation = {}
        self.departement = None  # type: str
        self.college = None  # type: bool
        self.lycee = None  # type: bool
        self.etablissement_en = None # type: bool

class UserType(Enum):
    ELEVE = 1
    ENSEIGNANT = 2
    PERSONNEL_DE_DIRECTION = 3

class Synchronizer:
    &#34;&#34;&#34;
    Synchronise les objets métiers entre l&#39;annuaire LDAP et le Moodle.
    &#34;&#34;&#34;

    def __init__(self, ldap: Ldap, db: Database, config: Config, action_config: ActionConfig = None,
                 arguments=DEFAULT_ARGS):
        self.__webservice = WebService(config.webservice)  # type: WebService
        self.__ldap = ldap  # type: Ldap
        self.__db = db  # type: Database
        self.__config = config  # type: Config
        self.__action_config = action_config if action_config \
            else next(iter(config.actions), ActionConfig())  # type: ActionConfig
        self.__arguments = arguments
        self.context = None  # type: SyncContext
        self.context_dane = None  # type: SyncContext
        self.ids_cohorts_dane_lycee_en = {}
        self.ids_cohorts_dane_dep_clg = {}

    def initialize(self):
        &#34;&#34;&#34;
        Initialise la synchronisation
        :return:
        &#34;&#34;&#34;
        self.context = SyncContext()

        # Recuperation du timestamp actuel
        self.context.timestamp_now_sql = self.__db.get_timestamp_now()

        # Récupération de la liste UAI-Domaine des établissements
        self.context.map_etab_domaine = self.__ldap.get_domaines_etabs()

        # Ids des categories inter etablissements
        id_categorie_inter_etabs = self.__db.get_id_categorie(
            self.__action_config.etablissements.inter_etab_categorie_name)
        self.context.id_context_categorie_inter_etabs = self.__db.get_id_context_categorie(id_categorie_inter_etabs)

        id_categorie_inter_cfa = self.__db.get_id_categorie(
            self.__action_config.etablissements.inter_etab_categorie_name_cfa)
        self.context.id_context_categorie_inter_cfa = self.__db.get_id_context_categorie(id_categorie_inter_cfa)

        # Recuperation des ids des roles
        self.context.id_role_extended_teacher = self.__db.get_id_role_by_shortname(&#39;extendedteacher&#39;)
        self.context.id_role_advanced_teacher = self.__db.get_id_role_by_shortname(&#39;advancedteacher&#39;)

        # Recuperation de l&#39;id du user info field pour la classe
        self.context.id_field_classe = self.__db.get_id_user_info_field_by_shortname(&#39;classe&#39;)

        # Recuperation de l&#39;id du champ personnalisé Domaine
        self.context.id_field_domaine = self.__db.get_id_user_info_field_by_shortname(&#39;Domaine&#39;)


    def handle_dane(self, uai_dane, log=getLogger()):
        # Récupération des informations de la dane pour les cohortes de la dane
        log.debug(&#34;Recherche de la structure dane dans l&#39;annuaire&#34;)
        structure_ldap = self.__ldap.get_structure(uai_dane)
        if structure_ldap:
            log.debug(&#34;La structure dane a été trouvée&#34;)
            etablissement_path = &#34;/1&#34;

            # Recuperation du bon theme
            etablissement_theme = structure_ldap.uai.lower()

            # Creation de la structure si elle n&#39;existe pas encore
            id_dane_categorie = self.__db.get_id_course_category_by_theme(context.etablissement_theme)
            if id_dane_categorie is None:
                log.info(&#34;Création de la structure dane&#34;)
                self.insert_moodle_structure(False, structure_ldap.nom,
                                                etablissement_path, structure_ldap.nom,
                                                structure_ldap.siren, etablissement_theme)
                id_dane_categorie = self.__db.get_id_course_category_by_id_number(structure_ldap.siren)

            # Récupération des identifiants de 3 cohortes pour les lycées de l&#39;enseignement national
            for user_type in UserType:
                self.ids_cohorts_dane_lycee_en[user_type] = \
                    self.get_or_create_dane_lycee_en_cohort(id_context_dane, user_type, self.context.timestamp_now_sql)

            # Pour les différents type d&#39;utilisateurs
            for user_type in UserType:
                self.ids_cohorts_dane_dep_clg[user_type] = {}
                # Récupération des identifiants des cohortes pour les collèges par départements
                for departement in self.__config.constantes.departements:
                    self.ids_cohorts_dane_dep_clg[user_type][departement] = \
                        get_or_create_dane_dep_clg_cohort(id_dane_categorie, user_type, departement, self.context.timestamp_now_sql)

            # TODO lvillanne ici avant on avait l&#39;ancien système de purge qui n&#39;est plus valable, donc a réimaginer


    def handle_etablissement(self, uai, log=getLogger(), readonly=False) -&gt; EtablissementContext:
        &#34;&#34;&#34;
        Synchronise un établissement
        :return: EtabContext
        &#34;&#34;&#34;

        context = EtablissementContext(uai)
        context.gere_admin_local = uai not in self.__action_config.etablissements.listeEtabSansAdmin
        context.etablissement_regroupe = est_grp_etab(uai, self.__action_config.etablissements)
        # Regex pour savoir si l&#39;utilisateur est administrateur moodle
        context.regexp_admin_moodle = self.__action_config.etablissements.prefixAdminMoodleLocal + &#34;.*_%s$&#34; % uai
        # Regex pour savoir si l&#39;utilisateur est administrateur local
        context.regexp_admin_local = self.__action_config.etablissements.prefixAdminLocal + &#34;.*_%s$&#34; % uai

        log.debug(&#34;Recherche de la structure dans l&#39;annuaire&#34;)
        structure_ldap = self.__ldap.get_structure(uai)
        if structure_ldap:
            log.debug(&#34;La structure a été trouvée&#34;)
            etablissement_path = &#34;/1&#34;

            # Si l&#39;etablissement fait partie d&#39;un groupement
            if context.etablissement_regroupe:
                etablissement_ou = context.etablissement_regroupe[&#34;nom&#34;]
                structure_ldap.uai = context.etablissement_regroupe[&#34;uais&#34;][0]
                log.debug(&#34;L&#39;établissement fait partie d&#39;un groupement: ou=%s, uai=%s&#34;,
                          etablissement_ou, structure_ldap.uai)
            else:
                etablissement_ou = structure_ldap.nom
                log.debug(&#34;L&#39;établissement ne fait partie d&#39;un groupement: ou=%s&#34;, etablissement_ou)

            # Recuperation du bon theme
            context.etablissement_theme = structure_ldap.uai.lower()

            # Affectation des informations utiles pour la constitution des groupes dane
            context.departement = context.uai[1:3] if context.uai[0] == &#39;0&#39; else context.uai[:3]
            context.college = structure_ldap.type == self.__config.constantes.type_structure_clg
            context.lycee = structure_ldap.type.startswith(self.__config.constantes.type_structure_lycee_start_with)
            context.etablissement_en = structure_ldap.jointure.startswith(self.__config.constantes.type_structure_jointure_en_start_with)

            # Creation de la structure si elle n&#39;existe pas encore
            id_etab_categorie = self.__db.get_id_course_category_by_theme(context.etablissement_theme)
            if id_etab_categorie is None and not readonly:
                log.info(&#34;Création de la structure&#34;)
                self.insert_moodle_structure(context.etablissement_regroupe, structure_ldap.nom,
                                             etablissement_path, etablissement_ou,
                                             structure_ldap.siren, context.etablissement_theme)
                id_etab_categorie = self.__db.get_id_course_category_by_id_number(structure_ldap.siren)

            # Mise a jour de la description dans la cas d&#39;un groupement d&#39;etablissement
            if context.etablissement_regroupe and not readonly:
                description = self.__db.get_description_course_category(id_etab_categorie)
                if description.find(structure_ldap.siren) == -1:
                    log.info(&#34;Mise à jour de la description&#34;)
                    description = &#34;%s$%s@%s&#34; % (description, structure_ldap.siren, structure_ldap.nom)
                    self.__db.update_course_category_description(id_etab_categorie, description)
                    self.__db.update_course_category_name(id_etab_categorie, etablissement_ou)

            # Recuperation de l&#39;id du contexte correspondant à l&#39;etablissement
            if id_etab_categorie is not None:
                context.id_context_categorie = self.__db.get_id_context_categorie(id_etab_categorie)

            context.id_zone_privee = self.__db.get_id_course_by_id_number(&#34;ZONE-PRIVEE-&#34; + structure_ldap.siren)

            # Recreation de la zone privee si celle-ci n&#39;existe plus
            if context.id_zone_privee is None and not readonly:
                log.info(&#34;Création de la zone privée&#34;)
                context.id_zone_privee = self.__db.insert_zone_privee(id_etab_categorie, structure_ldap.siren,
                                                                      etablissement_ou, self.context.timestamp_now_sql)

            if context.id_zone_privee is not None:
                context.id_context_course_forum = self.__db.get_id_context(self.__config.constantes.niveau_ctx_cours, 3,
                                                                           context.id_zone_privee)
            if context.id_context_course_forum is None and not readonly:
                log.info(&#34;Création du cours associé à la zone privée&#34;)
                context.id_context_course_forum = self.__db.insert_zone_privee_context(context.id_zone_privee)

            context.structure_ldap = structure_ldap
        return context


    def construct_classe_to_niv_formation(self, etablissement_context: EtablissementContext, list_eleve_ldap: list[EleveLdap], log=getLogger()):
        &#34;&#34;&#34;
        Associe au contexte de l&#39;établissement un dictionnaire associant une classe à
        un niveau de formation. Utilisé pour pouvoir récupérer le niveau de formation
        d&#39;un enseignant comme il n&#39;est pas présent directement dans le ldap
        &#34;&#34;&#34;
        for eleve_ldap in list_eleve_ldap:
            eleve_classes_for_etab = []
            for classe in eleve_ldap.classes:
                if classe.etab_dn == etablissement_context.structure_ldap.dn:
                    eleve_classes_for_etab.append(classe.classe)
            for classe in eleve_classes_for_etab:
                etablissement_context.classe_to_niv_formation[classe] = eleve_ldap.niveau_formation


    def handle_eleve(self, etablissement_context: EtablissementContext, eleve_ldap: EleveLdap, log=getLogger()):
        &#34;&#34;&#34;
        Synchronise un élève au sein d&#39;un établissement
        :param etablissement_context:
        :param eleve_ldap:
        :param log:
        :return:
        &#34;&#34;&#34;
        mail_display = self.__config.constantes.default_mail_display
        if not eleve_ldap.mail:
            eleve_ldap.mail = self.__config.constantes.default_mail
            log.info(&#34;Le mail de l&#39;élève n&#39;est pas défini dans l&#39;annuaire, &#34;
                     &#34;utilisation de la valeur par défault: %s&#34;, eleve_ldap.mail)

        eleve_id = self.__db.get_user_id(eleve_ldap.uid)

        if not eleve_id:
            log.info(&#34;Ajout de l&#39;utilisateur: %s&#34;, eleve_ldap)
            self.__db.insert_moodle_user(eleve_ldap.uid, eleve_ldap.given_name,
                                         eleve_ldap.sn, eleve_ldap.mail,
                                         mail_display, etablissement_context.etablissement_theme)
            eleve_id = self.__db.get_user_id(eleve_ldap.uid)
        else:
            log.info(&#34;Mise à jour de l&#39;utilisateur: %s&#34;, eleve_ldap)
            self.__db.update_moodle_user(eleve_id, eleve_ldap.given_name,
                                         eleve_ldap.sn, eleve_ldap.mail, mail_display,
                                         etablissement_context.etablissement_theme)

        # Ajout ou suppression du role d&#39;utilisateur avec droits limités Pour les eleves de college
        if etablissement_context.structure_ldap.type == self.__config.constantes.type_structure_clg:
            log.info(&#34;Ajout du rôle droit limités à l&#39;utilisateur: %s&#34;, eleve_ldap)
            self.__db.add_role_to_user(self.__config.constantes.id_role_utilisateur_limite,
                                       self.__config.constantes.id_instance_moodle, eleve_id)
        else:
            self.__db.remove_role_to_user(self.__config.constantes.id_role_utilisateur_limite,
                                          self.__config.constantes.id_instance_moodle, eleve_id)
            log.info(
                &#34;Suppression du role d&#39;utilisateur avec des droits limites à l&#39;utilisateur %s %s %s (id = %s)&#34;
                , eleve_ldap.given_name, eleve_ldap.sn, eleve_ldap.uid, str(eleve_id))

        # Inscription dans les cohortes associees aux classes
        eleve_cohorts = []
        eleve_classes_for_etab = []
        for classe in eleve_ldap.classes:
            if classe.etab_dn == etablissement_context.structure_ldap.dn:
                eleve_classes_for_etab.append(classe.classe)
        if eleve_classes_for_etab:
            log.info(&#34;Inscription de l&#39;élève %s &#34;
                     &#34;dans les cohortes de classes %s&#34;, eleve_ldap, eleve_classes_for_etab)
            ids_classes_cohorts = self.get_or_create_classes_cohorts(etablissement_context.id_context_categorie,
                                                                     eleve_classes_for_etab,
                                                                     self.context.timestamp_now_sql,
                                                                     log=log)
            for ids_classe_cohorts in ids_classes_cohorts:
                self.__db.enroll_user_in_cohort(ids_classe_cohorts, eleve_id, self.context.timestamp_now_sql)

            eleve_cohorts.extend(ids_classes_cohorts)

        # Inscription dans la cohorte associee au niveau de formation
        if eleve_ldap.niveau_formation:
            log.info(&#34;Inscription de l&#39;élève %s &#34;
                     &#34;dans la cohorte de niveau de formation %s&#34;, eleve_ldap, eleve_ldap.niveau_formation)
            id_formation_cohort = self.get_or_create_formation_cohort(etablissement_context.id_context_categorie,
                                                                      eleve_ldap.niveau_formation,
                                                                      self.context.timestamp_now_sql,
                                                                      log=log)
            self.__db.enroll_user_in_cohort(id_formation_cohort, eleve_id, self.context.timestamp_now_sql)
            eleve_cohorts.append(id_formation_cohort)

        # Inscription dans les cohortes de la Dane
        if etablissement_context.college and etablissement_context.departement in self.__config.constantes.departements:
            self.__db.enroll_user_in_cohort(self.ids_cohorts_dane_dep_clg[UserType.ELEVE][etablissement_context.departement],
                eleve_id, self.context.timestamp_now_sql)
        elif etablissement_context.lycee and etablissement_context.etablissement_en:
            self.__db.enroll_user_in_cohort(self.ids_cohorts_dane_lycee_en[UserType.ELEVE], eleve_id, self.context.timestamp_now_sql)

        # Mise a jour de la classe
        id_user_info_data = self.__db.get_id_user_info_data(eleve_id, self.context.id_field_classe)
        if id_user_info_data is not None:
            self.__db.update_user_info_data(eleve_id, self.context.id_field_classe, eleve_ldap.classe.classe)
            log.debug(&#34;Mise à jour user_info_data&#34;)
        else:
            self.__db.insert_moodle_user_info_data(eleve_id, self.context.id_field_classe, eleve_ldap.classe.classe)
            log.debug(&#34;Insertion user_info_data&#34;)

        # Mise a jour du Domaine
        user_domain = self.__config.constantes.default_domain
        if len(eleve_ldap.domaines) == 1:
            user_domain = eleve_ldap.domaines[0]
        else:
            if eleve_ldap.uai_courant and eleve_ldap.uai_courant in self.context.map_etab_domaine:
                user_domain = self.context.map_etab_domaine[eleve_ldap.uai_courant][0]
        log.debug(&#34;Insertion du Domaine&#34;)
        self.__db.set_user_domain(eleve_id, self.context.id_field_domaine, user_domain)


    def handle_enseignant(self, etablissement_context: EtablissementContext, enseignant_ldap: EnseignantLdap,
                          log=getLogger()):
        &#34;&#34;&#34;
        Met à jour un enseignant au sein d&#39;un établissement
        :param etablissement_context:
        :param enseignant_ldap:
        :param log:
        :return:
        &#34;&#34;&#34;

        enseignant_infos = &#34;%s %s %s&#34; % (enseignant_ldap.uid, enseignant_ldap.given_name, enseignant_ldap.sn)

        if enseignant_ldap.uai_courant and not etablissement_context.etablissement_regroupe:
            etablissement_context.etablissement_theme = enseignant_ldap.uai_courant.lower()

        if not enseignant_ldap.mail:
            enseignant_ldap.mail = self.__config.constantes.default_mail

        # Affichage du mail reserve aux membres de cours
        mail_display = self.__config.constantes.default_mail_display
        if etablissement_context.structure_ldap.uai in self.__action_config.etablissements.listeEtabSansMail:
            # Desactivation de l&#39;affichage du mail
            mail_display = 0

        # Insertion de l&#39;enseignant
        id_user = self.__db.get_user_id(enseignant_ldap.uid)
        if not id_user:
            self.__db.insert_moodle_user(enseignant_ldap.uid, enseignant_ldap.given_name, enseignant_ldap.sn,
                                         enseignant_ldap.mail,
                                         mail_display, etablissement_context.etablissement_theme)
            id_user = self.__db.get_user_id(enseignant_ldap.uid)
        else:
            self.__db.update_moodle_user(id_user, enseignant_ldap.given_name, enseignant_ldap.sn, enseignant_ldap.mail,
                                         mail_display, etablissement_context.etablissement_theme)

        # Mise à jour des droits sur les anciens etablissement
        if enseignant_ldap.uais is not None and not etablissement_context.etablissement_regroupe:
            # Recuperation des uais des etablissements dans lesquels l&#39;enseignant est autorise
            self.mettre_a_jour_droits_enseignant(enseignant_infos, id_user, enseignant_ldap.uais, log=log)

        # Ajout du role de createur de cours au niveau de la categorie inter-etablissement Moodle
        self.__db.add_role_to_user(self.__config.constantes.id_role_createur_cours,
                                   self.context.id_context_categorie_inter_etabs, id_user)
        log.info(&#34;Ajout du role de createur de cours dans la categorie inter-etablissements&#34;)

        # Si l&#39;enseignant fait partie d&#39;un CFA
        # Ajout du role createur de cours au niveau de la categorie inter-cfa
        if etablissement_context.structure_ldap.type == self.__config.constantes.type_structure_cfa:
            self.__db.add_role_to_user(self.__config.constantes.id_role_createur_cours,
                                       self.context.id_context_categorie_inter_cfa, id_user)
            log.info(&#34;Ajout du role de createur de cours dans la categorie inter-cfa&#34;)
        else:
            if  etablissement_context.structure_ldap.type.startswith(&#39;LYCEE&#39;) \
                or etablissement_context.structure_ldap.type == self.__config.constantes.type_structure_ens_adapte \
                or etablissement_context.structure_ldap.uai == &#39;0370074E&#39; \
                or ( etablissement_context.structure_ldap.type.startswith(&#39;COLLEGE&#39;) \
                or etablissement_context.structure_ldap.type == self.__config.constantes.type_structure_cfa_agricole  ) :
                if set(enseignant_ldap.profils).intersection([&#39;National_ENS&#39;,&#39;National_DOC&#39;,&#39;National_DIR&#39;, &#39;National_ETA&#39;, &#39;National_EVS&#39;]):
                    log.info(&#34;Ajout du rôle bigbluebutton pour l&#39;utilisateur %s&#34; % id_user)
                    self.__db.add_role_to_user(self.__config.constantes.id_role_bigbluebutton,
                                               self.__config.constantes.id_instance_moodle, id_user)

        # ajout du role de createur de cours dans l&#39;etablissement
        self.__db.add_role_to_user(self.__config.constantes.id_role_createur_cours,
                                   etablissement_context.id_context_categorie, id_user)

        # Ajouts des autres roles pour le personnel établissement
        if set(enseignant_ldap.profils).intersection([&#39;National_ENS&#39;, &#39;National_DIR&#39;, &#39;National_EVS&#39;, &#39;National_ETA&#39;]):
            # Ajout des roles sur le contexte forum
            self.__db.add_role_to_user(self.__config.constantes.id_role_eleve,
                                       etablissement_context.id_context_course_forum, id_user)
            # Inscription à la Zone Privée
            self.__db.enroll_user_in_course(self.__config.constantes.id_role_eleve,
                                            etablissement_context.id_zone_privee, id_user)

            if set(enseignant_ldap.profils).intersection([&#39;National_ENS&#39;, &#39;National_EVS&#39;, &#39;National_ETA&#39;]):
                if not etablissement_context.gere_admin_local:
                    self.__db.add_role_to_user(self.context.id_role_extended_teacher,
                                               etablissement_context.id_context_categorie,
                                               id_user)
            elif &#39;National_DIR&#39; in enseignant_ldap.profils:
                self.__db.add_role_to_user(self.__config.constantes.id_role_directeur,
                                           etablissement_context.id_context_categorie, id_user)

        # Ajout des droits d&#39;administration locale pour l&#39;etablissement
        if etablissement_context.gere_admin_local:
            for member in enseignant_ldap.is_member_of:
                # L&#39;enseignant est il administrateur Moodle ?
                admin_moodle = re.match(etablissement_context.regexp_admin_moodle, member, flags=re.IGNORECASE)
                if admin_moodle:
                    self.__db.insert_moodle_local_admin(etablissement_context.id_context_categorie, id_user)
                    log.info(&#34;Insertion d&#39;un admin  local %s %s %s&#34;,
                             enseignant_ldap.uid, enseignant_ldap.given_name, enseignant_ldap.sn)
                    # Si il est admin local on en fait un utilisateur avancé par default
                    if not self.__db.is_enseignant_avance(id_user, self.context.id_role_advanced_teacher):
                        self.__db.add_role_to_user(self.context.id_role_advanced_teacher, 1, id_user)
                    break
                else:
                    delete = self.__db.delete_moodle_local_admin(self.context.id_context_categorie_inter_etabs, id_user)
                    if delete:
                        log.info(&#34;Suppression d&#39;un admin local %s %s %s&#34;,
                                 enseignant_ldap.uid, enseignant_ldap.given_name, enseignant_ldap.sn)

        # Inscription dans les cohortes associees aux classes et au niveau de formation
        enseignant_cohorts = []
        enseignant_classes_for_etab = []
        #Récupération des classes de l&#39;établissement traité actuellement
        for classe in enseignant_ldap.classes:
            if classe.etab_dn == etablissement_context.structure_ldap.dn:
                enseignant_classes_for_etab.append(classe.classe)
        if enseignant_classes_for_etab:
            log.info(&#34;Inscription de l&#39;enseignant %s dans les cohortes de classes %s&#34;,
                     enseignant_ldap, enseignant_classes_for_etab)
            name_pattern = &#34;Profs de la Classe %s&#34;
            desc_pattern = &#34;Profs de la Classe %s&#34;
            #Création des cohortes de classes
            ids_classes_cohorts = self.get_or_create_classes_cohorts(etablissement_context.id_context_categorie,
                                                                     enseignant_classes_for_etab,
                                                                     self.context.timestamp_now_sql,
                                                                     name_pattern=name_pattern,
                                                                     desc_pattern=desc_pattern,
                                                                     log=log)
            #Inscription dans les cohortes de classe
            for ids_classe_cohorts in ids_classes_cohorts:
                self.__db.enroll_user_in_cohort(ids_classe_cohorts, id_user, self.context.timestamp_now_sql)

            enseignant_cohorts.extend(ids_classes_cohorts)

            #Inscription dans les cohortes de niveau de formation
            enseignant_niv_formation = set()
            for classe in enseignant_classes_for_etab:
                #Il est possible que l&#39;enseignant enseigne dans une classe mais qui n&#39;est pas dans cet établissement
                #Il sera alors inscrit dans la cohorte du niveau de formation correspondant à la classe lorsqu&#39;on le
                #traitera avec l&#39;autre établissement en question
                if classe in etablissement_context.classe_to_niv_formation.keys():
                    enseignant_niv_formation.add(etablissement_context.classe_to_niv_formation[classe])
                else:
                    log.error(&#34;Problème avec l&#39;enseignant %s pour l&#39;inscrire dans les cohortes de niveau de formation&#34;, enseignant_ldap)

            log.info(&#34;Inscription de l&#39;enseignant %s dans les cohortes de niveau de formation %s&#34;,
                     enseignant_ldap, enseignant_niv_formation)

            name_pattern = &#34;Profs du niveau de formation %s&#34;
            desc_pattern = &#34;Profs du niveau de formation %s&#34;
            #Création des cohortes de niveau de formation
            ids_niv_formation_cohorts = self.get_or_create_niv_formation_cohorts(etablissement_context.id_context_categorie,
                                                                                 enseignant_niv_formation,
                                                                                 self.context.timestamp_now_sql,
                                                                                 name_pattern=name_pattern,
                                                                                 desc_pattern=desc_pattern,
                                                                                 log=log)
            #Inscription dans les cohortes de niveau de formation
            for id_cohort_niv_formation in ids_niv_formation_cohorts:
                self.__db.enroll_user_in_cohort(id_cohort_niv_formation, id_user, self.context.timestamp_now_sql)

        log.info(&#34;Inscription de l&#39;enseignant %s dans la cohorte d&#39;enseignants de l&#39;établissement&#34;, enseignant_ldap)
        id_prof_etabs_cohort = self.get_or_create_profs_etab_cohort(etablissement_context, log)

        id_user = self.__db.get_user_id(enseignant_ldap.uid)
        self.__db.enroll_user_in_cohort(id_prof_etabs_cohort, id_user, self.context.timestamp_now_sql)

        # TODO lvillanne réaliser l&#39;inscription dans les cohortes de la dane

        # Mise a jour des dictionnaires concernant les cohortes
        for cohort_id in enseignant_cohorts:
            # Si la cohorte est deja connue
            if cohort_id in etablissement_context.enseignants_by_cohortes:
                etablissement_context.enseignants_by_cohortes[cohort_id].append(id_user)
            # Si la cohorte n&#39;a pas encore ete rencontree
            else:
                etablissement_context.enseignants_by_cohortes[cohort_id] = [id_user]

        # Mise a jour du Domaine
        user_domain = self.__config.constantes.default_domain
        if len(enseignant_ldap.domaines) == 1:
            user_domain = enseignant_ldap.domaines[0]
        else:
            if enseignant_ldap.uai_courant and enseignant_ldap.uai_courant in self.context.map_etab_domaine:
                user_domain = self.context.map_etab_domaine[enseignant_ldap.uai_courant][0]
        log.debug(&#34;Insertion du Domaine&#34;)
        self.__db.set_user_domain(id_user, self.context.id_field_domaine, user_domain)

    def handle_user_interetab(self, personne_ldap: PersonneLdap, log=getLogger()):
        &#34;&#34;&#34;
        Synchronise un utilisateur inter-etablissement
        :param personne_ldap:
        :param log:
        :return:
        &#34;&#34;&#34;
        if not personne_ldap.mail:
            personne_ldap.mail = self.__config.constantes.default_mail

        # Creation de l&#39;utilisateur
        id_user = self.__db.get_user_id(personne_ldap.uid)
        if not id_user:
            self.__db.insert_moodle_user(personne_ldap.uid, personne_ldap.given_name, personne_ldap.sn,
                                         personne_ldap.mail,
                                         self.__config.constantes.default_mail_display,
                                         self.__config.constantes.default_moodle_theme)
            id_user = self.__db.get_user_id(personne_ldap.uid)
        else:
            self.__db.update_moodle_user(id_user, personne_ldap.given_name, personne_ldap.sn, personne_ldap.mail,
                                         self.__config.constantes.default_mail_display,
                                         self.__config.constantes.default_moodle_theme)

        # Ajout du role de createur de cours
        self.__db.add_role_to_user(self.__config.constantes.id_role_createur_cours,
                                   self.context.id_context_categorie_inter_etabs, id_user)

        # Attribution du role admin local si necessaire
        for member in personne_ldap.is_member_of:
            admin = re.match(self.__action_config.inter_etablissements.ldap_valeur_attribut_admin, member,
                             flags=re.IGNORECASE)
            if admin:
                insert = self.__db.insert_moodle_local_admin(self.context.id_context_categorie_inter_etabs, id_user)
                if insert:
                    log.info(&#34;Insertion d&#39;un admin local %s %s %s&#34;,
                             personne_ldap.uid, personne_ldap.given_name, personne_ldap.sn)
                break
            else:
                delete = self.__db.delete_moodle_local_admin(self.context.id_context_categorie_inter_etabs, id_user)
                if delete:
                    log.info(&#34;Suppression d&#39;un admin local %s %s %s&#34;,
                             personne_ldap.uid, personne_ldap.given_name, personne_ldap.sn)

    def handle_inspecteur(self, personne_ldap: PersonneLdap, log=getLogger()):
        &#34;&#34;&#34;
        Synchronise un inspecteur
        :param personne_ldap:
        :param log:
        :return:
        &#34;&#34;&#34;
        if not personne_ldap.mail:
            personne_ldap.mail = self.__config.constantes.default_mail

            # Creation de l&#39;utilisateur
            self.__db.insert_moodle_user(personne_ldap.uid, personne_ldap.given_name, personne_ldap.sn,
                                         personne_ldap.mail,
                                         self.__config.constantes.default_mail_display,
                                         self.__config.constantes.default_moodle_theme)
        id_user = self.__db.get_user_id(personne_ldap.uid)
        if not id_user:
            self.__db.insert_moodle_user(personne_ldap.uid, personne_ldap.given_name, personne_ldap.sn,
                                         personne_ldap.mail,
                                         self.__config.constantes.default_mail_display,
                                         self.__config.constantes.default_moodle_theme)
            id_user = self.__db.get_user_id(personne_ldap.uid)
        else:
            self.__db.update_moodle_user(id_user, personne_ldap.given_name, personne_ldap.sn, personne_ldap.mail,
                                         self.__config.constantes.default_mail_display,
                                         self.__config.constantes.default_moodle_theme)

        # Ajout du role de createur de cours au niveau de la categorie inter-etablissement Moodle
        self.__db.add_role_to_user(self.__config.constantes.id_role_createur_cours,
                                   self.context.id_context_categorie_inter_etabs, id_user)
        log.info(&#34;Ajout du role de createur de cours dans la categorie inter-etablissements&#34;)

        # Mise a jour du Domaine
        user_domain = self.__config.constantes.default_domain
        if len(personne_ldap.domaines) == 1:
            user_domain = personne_ldap.domaines[0]
        else:
            if personne_ldap.uai_courant and personne_ldap.uai_courant in self.context.map_etab_domaine:
                user_domain = self.context.map_etab_domaine[personne_ldap.uai_courant][0]
        log.debug(&#34;Insertion du Domaine&#34;)
        self.__db.set_user_domain(id_user, self.context.id_field_domaine, user_domain)

    def mettre_a_jour_droits_enseignant(self, enseignant_infos, id_enseignant, uais_autorises, log=getLogger()):
        &#34;&#34;&#34;
        Fonction permettant de mettre a jour les droits d&#39;un enseignant.
        Cette mise a jour consiste a :
          - Supprimer les roles non autorises
          - ajouter les roles
        :param enseignant_infos:
        :param id_enseignant:
        :param uais_autorises:
        :param log:
        :return:
        &#34;&#34;&#34;
        # Recuperation des themes autorises pour l&#39;enseignant
        themes_autorises = [uai_autorise.lower() for uai_autorise in uais_autorises]
        log.debug(&#34;Etablissements autorises pour l&#39;enseignant pour %s : %s&#34;,
                  enseignant_infos, themes_autorises)

        #########################
        # ZONES PRIVEES
        #########################
        # Recuperation des ids des roles et les themes non autorises
        ids_roles_non_autorises, ids_themes_non_autorises = self.__db.get_ids_and_themes_not_allowed_roles(
            id_enseignant, themes_autorises)

        # Suppression des roles non autorises
        if ids_roles_non_autorises:
            self.__db.delete_roles(ids_roles_non_autorises)
            log.info(&#34;Suppression des rôles d&#39;enseignant pour %s dans les établissements %s&#34;
                     , enseignant_infos, str(ids_themes_non_autorises))
            log.info(&#34;Les seuls établissements autorisés pour cet enseignant sont %s&#34;, themes_autorises)

        #########################
        # FORUMS
        #########################
        # Recuperation des SIREN des etablissements dans lequel l&#39;enseignant travaille
        sirens = self.__db.get_descriptions_course_categories_by_themes(themes_autorises)

        # Shortname des forums associes
        # Ancien code : shortnames_forums = [ ( &#34;ZONE-PRIVEE-%s&#34; % str( siren ) ) for siren in sirens ]
        shortnames_forums = [&#34;ZONE-PRIVEE-%s&#34; % siren for siren in sirens]

        # Recuperation des roles sur les forums qui ne devraient plus exister
        ids_roles_non_autorises, forums_summaries = self.__db.get_ids_and_summaries_not_allowed_roles(id_enseignant,
                                                                                                      shortnames_forums)

        # Suppression des roles non autorises
        if ids_roles_non_autorises:
            # Suppression des roles
            self.__db.delete_roles(ids_roles_non_autorises)
            log.info(&#34;Suppression des rôles d&#39;enseignant pour %s sur les forum &#39;%s&#39; &#34;,
                     enseignant_infos, str(forums_summaries))
            log.info(&#34;Les seuls établissements autorisés pour cet enseignant sont &#39;%s&#39;&#34;, themes_autorises)

    def get_or_create_cohort(self, id_context, name, id_number, description, time_created, log=getLogger()):
        &#34;&#34;&#34;
        Fonction permettant de creer une nouvelle cohorte pour un contexte donne.
        :param id_context:
        :param name:
        :param id_number:
        :param description:
        :param time_created:
        :return:
        &#34;&#34;&#34;
        id_cohort = self.__db.get_id_cohort(id_context, name)
        if id_cohort is None:
            self.__db.create_cohort(id_context, name, id_number, description, time_created)
            log.info(&#34;Creation de la cohorte (name=%s)&#34;, name)
            return self.__db.get_id_cohort(id_context, name)
        return id_cohort

    def get_or_create_dane_lycee_en_cohort(self, id_context_dane, user_type: UserType, timestamp_now_sql, log=getLogger()):
        &#34;&#34;&#34;
        Charge ou créer une cohorte dane lycee_en soit pour les élèves, les enseignant ou le personnel de direction
        :param id_context_dane:
        :param user_type:
        :param timestamp_now_sql:
        :param log:
        :return:
        &#34;&#34;&#34;
        all_cohort_name = {
            UserType.ELEVE: &#39;Élèves des lycées de l\&#39;éducation national&#39;,
            UserType.ENSEIGNANT: &#39;Enseignants des lycées de l\&#39;éducation national&#39;,
            UserType.PERSONNEL_DE_DIRECTION: &#39;Personnel de direction des lycées de l\&#39;éducation national&#39;
        }
        cohort_name = all_cohort_name[user_type]
        cohort_description = cohort_name
        id_cohort = self.get_or_create_cohort(id_context_dane, cohort_name, cohort_name, cohort_description,
                                              timestamp_now_sql, log)
        return id_cohort

    def get_or_create_dane_dep_clg_cohort(self, id_context_dane, user_type: UserType, departement, timestamp_now_sql, log=getLogger()):
        &#34;&#34;&#34;
        Charge ou créer une cohorte dane dep_clg soit pour les élèves, les enseignant ou le personnel de direction
        :param id_context_dane:
        :param user_type:
        :param departement:
        :param timestamp_now_sql:
        :param log:
        :return:
        &#34;&#34;&#34;
        all_cohort_name = {
            UserType.ELEVE: &#39;Élèves des collèges du {}&#39;,
            UserType.ENSEIGNANT: &#39;Enseignants des collèges du {}&#39;,
            UserType.PERSONNEL_DE_DIRECTION: &#39;Personnel de direction des collèges du {}&#39;
        }
        cohort_name = all_cohort_name[user_type].format(departement)
        cohort_description = cohort_name
        id_cohort = self.get_or_create_cohort(id_context_dane, cohort_name, cohort_name, cohort_description,
                                              timestamp_now_sql, log)
        return id_cohort

    def get_or_create_formation_cohort(self, id_context_etab, niveau_formation, timestamp_now_sql, log=getLogger()):
        &#34;&#34;&#34;
        Charge ou créer une cohorte de formation
        :param id_context_etab:
        :param niveau_formation:
        :param timestamp_now_sql:
        :param log:
        :return:
        &#34;&#34;&#34;
        cohort_name = &#39;Élèves du Niveau de formation %s&#39; % niveau_formation
        cohort_description = &#39;Eleves avec le niveau de formation %s&#39; % niveau_formation
        id_cohort = self.get_or_create_cohort(id_context_etab, cohort_name, cohort_name, cohort_description,
                                              timestamp_now_sql, log)
        return id_cohort

    def get_or_create_classes_cohorts(self, id_context_etab, classes_names, time_created, name_pattern=None,
                                      desc_pattern=None, log=getLogger()):
        &#34;&#34;&#34;
        Charge ou crée des cohortes a partir de classes liées a un établissement.
        :param id_context_etab:
        :param classes_names:
        :param time_created:
        :param name_pattern:
        :param desc_pattern:
        :return:
        &#34;&#34;&#34;

        if name_pattern is None:
            name_pattern = &#34;Élèves de la Classe %s&#34;
        if desc_pattern is None:
            desc_pattern = &#34;Élèves de la Classe %s&#34;

        ids_cohorts = []
        for class_name in classes_names:
            cohort_name = name_pattern % class_name
            cohort_description = desc_pattern % class_name
            id_cohort = self.get_or_create_cohort(id_context_etab,
                                                  cohort_name,
                                                  cohort_name,
                                                  cohort_description,
                                                  time_created,
                                                  log=log)
            ids_cohorts.append(id_cohort)
        return ids_cohorts

    def get_or_create_niv_formation_cohorts(self, id_context_etab, niveaux_formation, time_created, name_pattern, desc_pattern, log=getLogger()):
        &#34;&#34;&#34;
        Charge ou crée des cohortes a partir de niveau de formation liés a un établissement.
        :param id_context_etab:
        :param niveaux_formation:
        :param time_created:
        :param name_pattern:
        :param desc_pattern:
        :return:
        &#34;&#34;&#34;

        ids_cohorts = []
        for niveau_formation in niveaux_formation:
            cohort_name = name_pattern % niveau_formation
            cohort_description = desc_pattern % niveau_formation
            id_cohort = self.get_or_create_cohort(id_context_etab,
                                                  cohort_name,
                                                  cohort_name,
                                                  cohort_description,
                                                  time_created,
                                                  log=log)
            ids_cohorts.append(id_cohort)
        return ids_cohorts

    def get_or_create_profs_etab_cohort(self, etab_context: EtablissementContext, log=getLogger()):
        &#34;&#34;&#34;
        Charge ou crée la cohorte d&#39;enseignant de l&#39;établissement.
        :param etab_context:
        :param log:
        :return:
        &#34;&#34;&#34;
        cohort_name = &#39;Profs de l\&#39;établissement (%s)&#39; % etab_context.uai
        cohort_description = &#39;Enseignants de l\&#39;établissement %s&#39; % etab_context.uai
        id_cohort_enseignants = self.get_or_create_cohort(etab_context.id_context_categorie,
                                                          cohort_name,
                                                          cohort_name,
                                                          cohort_description,
                                                          self.context.timestamp_now_sql,
                                                          log=log)
        return id_cohort_enseignants

    def get_users_by_cohorts_comparators_eleves_classes(self, etab_context: EtablissementContext, cohortname_pattern_re: str,
                                         cohortname_pattern: str) -&gt; (Dict[str, List[str]], Dict[str, List[str]]):
        &#34;&#34;&#34;
        Renvoie deux dictionnaires listant les élèves (uid) dans chacune des classes.
        Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
        :param etab_context: EtablissementContext
        :param cohortname_pattern_re: str
        :param cohortname_pattern: str
        :return:
        &#34;&#34;&#34;
        # Récupére les cohortes qui correspondent au pattern et qui sont lié à l&#39;établissement du context
        classes_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

        # Dictionnaire contenant la liste des élèves par cohorte provenant de la bdd
        eleves_by_cohorts_db = {}
        # Pour chaque cohorte de la bdd
        for cohort in classes_cohorts:
            matches = re.search(cohortname_pattern_re, cohort.name)
            # On récupére le nom de la classe (fin du nom de la cohorte qui lui est fixe)
            classe_name = matches.group(2)
            # On créé le tableau vide pour y stocker les élèves
            eleves_by_cohorts_db[classe_name] = []
            # Et on stocke les élèves de cette cohorte en provenant ce la bdd
            for username in self.__db.get_cohort_members(cohort.id):
                eleves_by_cohorts_db[classe_name].append(username.lower())

        # Dictionnaire contenant la liste des élèves par cohorte provenant du ldap
        eleves_by_cohorts_ldap = {}
        # Pour chaque cohorte de la bdd
        for classe in eleves_by_cohorts_db:
            # On créé le tableau vide pour y stocker les élèves
            eleves_by_cohorts_ldap[classe] = []
            # Et on stocke les élèves de cette cohorte en provenant du ldap
            for eleve in self.__ldap.search_eleves_in_classe(classe, etab_context.uai):
                eleves_by_cohorts_ldap[classe].append(eleve.uid.lower())

        return eleves_by_cohorts_db, eleves_by_cohorts_ldap

    def get_users_by_dane_cohorts(self, cohortname_pattern: str) -&gt; List[str]:
        &#34;&#34;&#34;
        Renvoie un dictionnaire listant les utilisateurs BDD (uid) dans la cohorte dane.
        :param cohortname_pattern: str
        :return:
        &#34;&#34;&#34;
        # Récupére les cohortes qui correspondent au pattern et qui sont lié à l&#39;établissement du context
        classes_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

        # Dictionnaire contenant la liste des élèves par cohorte provenant de la bdd
        eleves_by_cohorts_db = {}
        # Pour chaque cohorte de la bdd
        for cohort in classes_cohorts:
            matches = re.search(cohortname_pattern_re, cohort.name)
            # On récupére le nom de la classe (fin du nom de la cohorte qui lui est fixe)
            classe_name = matches.group(2)
            # On créé le tableau vide pour y stocker les élèves
            eleves_by_cohorts_db[classe_name] = []
            # Et on stocke les élèves de cette cohorte en provenant ce la bdd
            for username in self.__db.get_cohort_members(cohort.id):
                eleves_by_cohorts_db[classe_name].append(username.lower())

        # Dictionnaire contenant la liste des élèves par cohorte provenant du ldap
        eleves_by_cohorts_ldap = {}
        # Pour chaque cohorte de la bdd
        for classe in eleves_by_cohorts_db:
            # On créé le tableau vide pour y stocker les élèves
            eleves_by_cohorts_ldap[classe] = []
            # Et on stocke les élèves de cette cohorte en provenant du ldap
            for eleve in self.__ldap.search_eleves_in_classe(classe, etab_context.uai):
                eleves_by_cohorts_ldap[classe].append(eleve.uid.lower())

        return eleves_by_cohorts_db, eleves_by_cohorts_ldap

    def get_users_by_cohorts_comparators_eleves_niveau(self, etab_context: EtablissementContext, cohortname_pattern_re: str,
                                         cohortname_pattern: str) -&gt; (Dict[str, List[str]], Dict[str, List[str]]):
        &#34;&#34;&#34;
        Renvoie deux dictionnaires listant les élèves (uid) dans chacun des niveaux de formation
        Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
        :param etab_context: EtablissementContext
        :param cohortname_pattern_re: str
        :param cohortname_pattern: str
        :return:
        &#34;&#34;&#34;
        classes_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

        eleves_by_cohorts_db = {}
        for cohort in classes_cohorts:
            matches = re.search(cohortname_pattern_re, cohort.name)
            classe_name = matches.group(2)
            eleves_by_cohorts_db[classe_name] = []
            for username in self.__db.get_cohort_members(cohort.id):
                eleves_by_cohorts_db[classe_name].append(username.lower())

        eleves_by_cohorts_ldap = {}
        for niveau in eleves_by_cohorts_db:
            eleves_by_cohorts_ldap[niveau] = []
            for eleve in self.__ldap.search_eleves_in_niveau(niveau, etab_context.uai):
                eleves_by_cohorts_ldap[niveau].append(eleve.uid.lower())

        return eleves_by_cohorts_db, eleves_by_cohorts_ldap

    def get_users_by_cohorts_comparators_profs_classes(self, etab_context: EtablissementContext, cohortname_pattern_re: str,
                                         cohortname_pattern: str) -&gt; (Dict[str, List[str]], Dict[str, List[str]]):
        &#34;&#34;&#34;
        Renvoie deux dictionnaires listant les profs (uid) dans chacune des classes
        Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
        :param etab_context: EtablissementContext
        :param cohortname_pattern_re: str
        :param cohortname_pattern: str
        :return:
        &#34;&#34;&#34;
        classes_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

        profs_by_cohorts_db = {}
        for cohort in classes_cohorts:
            matches = re.search(cohortname_pattern_re, cohort.name)
            classe_name = matches.group(2)
            profs_by_cohorts_db[classe_name] = []
            for username in self.__db.get_cohort_members(cohort.id):
                profs_by_cohorts_db[classe_name].append(username.lower())

        profs_by_cohorts_ldap = {}
        for classe in profs_by_cohorts_db:
            profs_by_cohorts_ldap[classe] = []
            for prof in self.__ldap.search_enseignants_in_classe(classe, etab_context.uai):
                profs_by_cohorts_ldap[classe].append(prof.uid.lower())

        return profs_by_cohorts_db, profs_by_cohorts_ldap


    def get_users_by_cohorts_comparators_profs_etab(self, etab_context: EtablissementContext, cohortname_pattern_re: str,
                                         cohortname_pattern: str) -&gt; (Dict[str, List[str]], Dict[str, List[str]]):
        &#34;&#34;&#34;
        Renvoie deux dictionnaires listant les profs (uid) dans chacun des établissement
        Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
        :param etab_context: EtablissementContext
        :param cohortname_pattern_re: str
        :param cohortname_pattern: str
        :return:
        &#34;&#34;&#34;
        etab_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

        profs_by_cohorts_db = {}
        for cohort in etab_cohorts:
            matches = re.search(cohortname_pattern_re, cohort.name)
            etab_name = matches.group(2)
            profs_by_cohorts_db[etab_name] = []
            for username in self.__db.get_cohort_members(cohort.id):
                profs_by_cohorts_db[etab_name].append(username.lower())

        profs_by_cohorts_ldap = {}
        for etab in profs_by_cohorts_db:
            profs_by_cohorts_ldap[etab] = []
            for prof in self.__ldap.search_enseignants_in_etab(etab_context.uai):
                profs_by_cohorts_ldap[etab].append(prof.uid.lower())

        return profs_by_cohorts_db, profs_by_cohorts_ldap


    def get_users_by_cohorts_comparators_profs_niveau(self, etab_context: EtablissementContext, cohortname_pattern_re: str,
                                         cohortname_pattern: str) -&gt; (Dict[str, List[str]], Dict[str, List[str]]):
        &#34;&#34;&#34;
        Renvoie deux dictionnaires listant les profs (uid) dans chacun des niveaux de formation
        Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
        :param etab_context: EtablissementContext
        :param cohortname_pattern_re: str
        :param cohortname_pattern: str
        :return:
        &#34;&#34;&#34;

        #Construit le dictionnaire pour avoir l&#39;association classe -&gt; niveau de formation
        self.construct_classe_to_niv_formation(etab_context, self.__ldap.search_eleve(None, etab_context.uai))

        #Récupère les cohortes coté moodle
        levels_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

        profs_by_cohorts_db = {}
        for cohort in levels_cohorts:
            matches = re.search(cohortname_pattern_re, cohort.name)
            level_name = matches.group(2)
            profs_by_cohorts_db[level_name] = []
            for username in self.__db.get_cohort_members(cohort.id):
                profs_by_cohorts_db[level_name].append(username.lower())

        profs_by_cohorts_ldap = {}
        for niveau in profs_by_cohorts_db:
            profs_by_cohorts_ldap[niveau] = []
            for prof in self.__ldap.search_enseignants_in_niveau(niveau, etab_context.uai, etab_context.classe_to_niv_formation):
                profs_by_cohorts_ldap[niveau].append(prof.uid.lower())

        return profs_by_cohorts_db, profs_by_cohorts_ldap


    def list_contains_username(self, ldap_users: List[PersonneLdap], username: str):
        &#34;&#34;&#34;
        Vérifie si une liste d&#39;utilisateurs ldap contient un utilisateur via son username
        :param ldap_users:
        :param username:
        :return:
        &#34;&#34;&#34;
        for ldap_user in ldap_users:
            if ldap_user.uid.lower() == username.lower():
                return True
        return False

    def backup_course(self, courseid, log=getLogger()):
        &#34;&#34;&#34;
        Permet de lancer le backup un cours et de vérifier qu&#39;il s&#39;est bien passé
        :param courseid: L&#39;id du cours à backup
        :return: Un booléen a True si le backup s&#39;est bien passé, False sinon
        &#34;&#34;&#34;
        log.info(&#34;Backup du cours avec l&#39;id %d&#34;, courseid)
        cmd = self.__config.webservice.backup_cmd.replace(&#34;%courseid%&#34;, str(courseid))
        backup_process = os.popen(cmd)
        output = backup_process.read()
        m = re.search(self.__config.webservice.backup_success_re, output)
        return m is not None

    def check_and_process_user_courses(self, user_id: int, log=getLogger()):
        &#34;&#34;&#34;
        Effectue les traitements nécéssaires sur tous les cours d&#39;un l&#39;enseignant
        :param user_id: L&#39;enseignant dont on doit traiter les cours
        &#34;&#34;&#34;
        #Liste stockant tous les cours à supprimer
        course_ids_to_delete = []
        #Récupère tous les cours de l&#39;utilisateur
        user_courses_ids = [user_course[0] for user_course in self.__db.get_courses_ids_owned_or_teach(user_id)]
        #Date actuelle
        now = self.__db.get_timestamp_now()

        #Pour chaque cours de l&#39;utilisateur
        for courseid in user_courses_ids:
            log.info(&#34;Traitement du cours %d&#34;, courseid)
            #On récupère tous les Propriétaire de cours de ce cours
            owners_ids = [ownerid[0] for ownerid in self.__db.get_userids_owner_of_course(courseid)]
            #Si il est tout seul à posséder ce cours
            if len(owners_ids) == 1 and owners_ids[0] == user_id:
                #Récupération de la date de dernière modification
                timemodified = self.__db.get_course_timemodified(courseid)
                #Récupération du délai avant suppression du cours
                delay_backup_course = self.__config.delete.delay_backup_course

                #Test pour voir si le cours doit être supprimé
                if timemodified &lt; now - (delay_backup_course * SECONDS_PER_DAY):
                    log.info(&#34;Le cours %d n&#39;a pas été modifié depuis plus de %d jours, et l&#39;utilisateur %d est le seul&#34;
                    &#34; propriétaire de ce cours, il va donc être supprimé&#34;, courseid, user_id, delay_backup_course)
                    #Backup d&#39;abord
                    backup_success = self.backup_course(courseid, log)
                    if backup_success:
                        log.info(&#34;La backup du cours %d été sauvegardée&#34;, courseid)
                        course_ids_to_delete.append(courseid)
                    else:
                        log.error(&#34;Le backup du cours %d a échouée&#34;, courseid)

            #Sinon s&#39;il n&#39;est pas tout seul à posséder ce cours, on lui retire son rôle
            #Autrement dit on le désinscrit du cours
            else:
                log.info(&#34;L&#39;utilisateur %d n&#39;est pas le seul enseignant du cours %d, il va donc être désinscrit&#34;, user_id, courseid)
                self.__webservice.unenrol_user_from_course(user_id, courseid)

        #Suppression des cours
        if course_ids_to_delete:
            self.delete_courses(course_ids_to_delete)

    def anonymize_or_delete_users(self, ldap_users: List[PersonneLdap], db_users: List, log=getLogger()):
        &#34;&#34;&#34;
        Anonymise ou Supprime les utilisateurs devenus inutiles
        :param ldap_users: La liste de toutes les personnes du ldap
        :param db_users: La liste de toutes les personnes dans moodle
        :param log:
        :return:
        &#34;&#34;&#34;
        user_ids_to_delete = [] #Utilisateurs à supprimer
        user_ids_to_anonymize = [] #Utilisateurs à anonymiser
        user_ids_to_process_courses = [] #Enseignants dont les cours doivent subir un traitement
        now = self.__db.get_timestamp_now()
        is_teacher = False

        #Pour chaque utilisateur en BD
        for db_user in db_users:

            #Si jamais c&#39;est un utilisateur à ne pas supprimer
            if db_user[0] in self.__config.delete.ids_users_undeletable:
                continue

            #Si l&#39;utilisateur n&#39;est plus présent dans l&#39;annuaire LDAP, alors il faut faire un traitement
            if not self.list_contains_username(ldap_users, db_user[1]):
                log.info(&#34;L&#39;utilisateur %s n&#39;est plus présent dans l&#39;annuaire LDAP&#34;, db_user[1])
                #log.info(&#34;L&#39;utilisateur %s n&#39;a pas utilisé moodle depuis %f jours&#34;, db_user[1], (now - db_user[2])/SECONDS_PER_DAY)
                #Dans tous les cas, si jamais il n&#39;a jamais utilisé moodle alors on peut le supprimer
                if not self.__db.user_has_used_moodle(db_user[0]):
                    log.info(&#34;L&#39;utilisateur %s n&#39;a jamais utilisé moodle. Il va être supprimé&#34;, db_user[1])
                    user_ids_to_delete.append(db_user[0])

                #Traitement pour les utilisateurs ayant déjà utilisé moodle
                else:
                    #Booléen pour savoir si l&#39;utilisateur qu&#39;on traite est un enseignant ou non
                    is_teacher = self.__db.user_has_role(db_user[0], self.__config.delete.ids_roles_teachers)

                    #Récupération des délais avant anonymisation et avant suppression
                    delete_delay = self.__config.delete.delay_delete_teacher if is_teacher else \
                        self.__config.delete.delay_delete_student
                    anon_delay = self.__config.delete.delay_anonymize_teacher if is_teacher else \
                        self.__config.delete.delay_anonymize_student

                    #Récupération de la liste des cours de l&#39;utilisateur
                    user_courses = self.__webservice.get_courses_user_enrolled(db_user[0])

                    #Si c&#39;est un enseignant il ne faut pas tenir compte des cours ou il est propriétaire/enseignant
                    if is_teacher:
                        owned_courses = self.__db.get_courses_ids_owned_or_teach(db_user[0])
                        for course_owned in owned_courses:
                            if course_owned in user_courses:
                                user_courses.remove(course_owned)

                    #Cas ou on doit supprimer un élève : plus présent dans le ldap, et
                    #pas de connexion a moodle depuis plus de delay_force_delete jours
                    if not is_teacher:
                        if db_user[2] &lt; now - (self.__config.delete.delay_force_delete * SECONDS_PER_DAY):
                            log.info(&#34;L&#39;élève %s ne s&#39;est pas connecté depuis au moins %s jours. Il va être supprimé&#34;, db_user[1], self.__config.delete.delay_force_delete)
                            user_ids_to_delete.append(db_user[0])

                    #Suite du traitement si on ne sait pas encore si on doit supprimer l&#39;utilisateur
                    if db_user[0] not in user_ids_to_delete:

                        #Cas ou on doit supprimer un utilisateur : plus présent dans le ldap
                        #et pas de connection à moodle depuis plus de delete_delay jours
                        if db_user[2] &lt; now - (delete_delay * SECONDS_PER_DAY):
                            if len(user_courses) == 0: #inscription à aucun cours
                                #Différence de traitement au niveau des références entre un enseignant et un élève
                                if is_teacher:
                                    if not self.__db.enseignant_has_references(db_user[0]): #si pas de références
                                        log.info(&#34;L&#39;élève %s ne s&#39;est pas connecté depuis au moins %s jours et n&#39;est pas inscrit à un cours,&#34;
                                        &#34; ni ne possède de référénces. Il va être supprimé&#34;, db_user[1], delete_delay)
                                        user_ids_to_delete.append(db_user[0])
                                else:
                                    if not self.__db.eleve_has_references(db_user[0]): #si pas de références
                                        log.info(&#34;L&#39;enseignant %s ne s&#39;est pas connecté depuis au moins %s jours et n&#39;est pas inscrit à un cours,&#34;
                                        &#34; ni ne possède de référénces. Il va être supprimé&#34;, db_user[1], delete_delay)
                                        user_ids_to_delete.append(db_user[0])

                        if db_user[0] not in user_ids_to_delete:
                            #Cas ou on doit anonymiser un utilisateur : plus présent dans le ldap,
                            #pas inscrit dans un seul cours avec le rôle propriétaire ou enseignant,
                            #et pas de connection à moodle depuis plus de anon_delay jours
                            if db_user[2] &lt; now - (anon_delay * SECONDS_PER_DAY): #délai de connexion
                                #Différence de traitement au niveau des références entre un enseignant et un élève
                                if is_teacher:
                                    #On vérifie que l&#39;enseignant n&#39;est pas inscrit dans un seul cours avec le rôle propriétaire ou enseignant
                                    if len(self.__db.get_courses_ids_owned_or_teach(db_user[0])) == 0:
                                        #S&#39;il doit être anonymisé, on vérifie qu&#39;il ne l&#39;est pas déjà
                                        if self.__db.get_user_data(db_user[0])[10] != self.__config.constantes.anonymous_name:
                                            log.info(&#34;L&#39;enseignant %s ne s&#39;est pas connecté depuis au moins %s jours et est inscrit à des cours ou possèdes des références.&#34;
                                            &#34; Il va être anonymisé&#34;, db_user[1], anon_delay)
                                            user_ids_to_anonymize.append(db_user[0])
                                        else:
                                            log.info(&#34;L&#39;enseignant %s doit être anonymisé, mais il est déja anonymisé&#34;, db_user[1])
                                else:
                                    #Même principe pour les élèves
                                    if self.__db.get_user_data(db_user[0])[10] != self.__config.constantes.anonymous_name:
                                        log.info(&#34;L&#39;élève %s ne s&#39;est pas connecté depuis au moins %s jours et est inscrit à des cours ou possèdes des références.&#34;
                                        &#34; Il va être anonymisé&#34;, db_user[1], anon_delay)
                                        user_ids_to_anonymize.append(db_user[0])
                                    else:
                                        log.info(&#34;L&#39;élève %s doit être anonymisé, mais il est déja anonymisé&#34;, db_user[1])

                            #Cas ou on doit effectuer un traitement sur les cours d&#39;un prof : plus présent dans le ldap,
                            #inscrit avec le role propriétaire de cours ou enseignant dans au moins 1 cours,
                            #et pas de connection à moodle depuis plus de delay_backup_course jours
                            if is_teacher and (db_user[2] &lt; now - (self.__config.delete.delay_backup_course * SECONDS_PER_DAY)):
                                owned_or_teach_courses = [user_course[0] for user_course in self.__db.get_courses_ids_owned_or_teach(db_user[0])]
                                if len(owned_or_teach_courses) &gt; 0:
                                    log.info(&#34;L&#39;enseignant %s ne s&#39;est pas connecté depuis au moins %s jours. Un traitement&#34;
                                             &#34; va être effectué sur ses cours&#34;, db_user[1], self.__config.delete.delay_backup_course)
                                    user_ids_to_process_courses.append(db_user[0])

        #Traitement sur les cours des enseignants
        for user_id in user_ids_to_process_courses:
            log.info(&#34;Traitement des cours de l&#39;enseignant %s&#34;, user_id)
            self.check_and_process_user_courses(user_id, log=log)

        #Pour chaque utilisateur à supprimer
        if user_ids_to_delete:
            log.info(&#34;Suppression des utilisateurs en cours...&#34;)
            self.delete_users(user_ids_to_delete, log=log)
            log.info(&#34;%d utilisateurs supprimés&#34;, len(user_ids_to_delete))

        #De même pour user_ids_to_anonymize
        if user_ids_to_anonymize:
            log.info(&#34;Anonymisation des utilisateurs en cours...&#34;)
            self.__db.anonymize_users(user_ids_to_anonymize)
            log.info(&#34;%d utilisateurs anonymisés&#34;, len(user_ids_to_anonymize))


    def delete_empty_cohorts(self):
        &#34;&#34;&#34;
        Supprime les cohortes vides
        &#34;&#34;&#34;
        #Récupère les ids des cohortes
        empty_cohorts_ids = self.__db.get_empty_cohorts()
        if len(empty_cohorts_ids) &gt; 0:
            #Fait appel au webservice moodle pour suppression
            self.__webservice.delete_cohorts(empty_cohorts_ids)

    def delete_users(self, userids: List[int], log=getLogger()) -&gt; int:
        &#34;&#34;&#34;
        Supprime les utilisateurs d&#39;une liste en paginant les appels au webservice
        :param userids: La liste des id des utilisateurs à supprimer
        :param pagesize:  Le nombre d&#39;utilisateurs supprimés en un seul appel au webservice
        :param log:
        :return:
        &#34;&#34;&#34;
        pagesize = self.__config.webservice.user_delete_pagesize
        i = 0
        total = len(userids)
        userids_page = []
        for userid in userids:
            userids_page.append(userid)
            i += 1
            if i % pagesize == 0:
                self.__webservice.delete_users(userids_page)
                userids_page = []
                log.info(&#34;%d / %d utilisateurs supprimés&#34;, i, total)
        if i % pagesize &gt; 0:
            self.__webservice.delete_users(userids_page)
            log.info(&#34;%d / %d utilisateurs supprimés&#34;, i, total)
        return i


    def delete_courses(self, courseids: List[int], log=getLogger()) -&gt; int:
        &#34;&#34;&#34;
        Supprime les cours d&#39;une liste en paginant les appels au webservice
        :param courseids: La liste des id de cours à supprimer
        :param pagesize: Le nombre de cours supprimés en un seul appel au webservice
        :param log:
        :return:
        &#34;&#34;&#34;
        pagesize = self.__config.webservice.course_delete_pagesize
        i = 0
        total = len(courseids)
        courseids_page = []
        for courseid in courseids:
            courseids_page.append(courseid)
            i += 1
            if i % pagesize == 0:
                self.__webservice.delete_courses(courseids_page)
                courseids_page = []
                log.info(&#34;%d / %d cours supprimés&#34;, i, total)
        if i % pagesize &gt; 0:
            self.__webservice.delete_courses(courseids_page)
            log.info(&#34;%d / %d cours supprimés&#34;, i, total)
        return i


    def purge_cohorts(self, users_by_cohorts_db: Dict[str, List[str]],
                      users_by_cohorts_ldap: Dict[str, List[str]],
                      cohortname_pattern: str,
                      log=getLogger()):
        &#34;&#34;&#34;
        Vide les cohortes d&#39;utilisateurs conformément à l&#39;annuaire LDAP
        :param users_by_cohorts_db:
        :param users_by_cohorts_ldap:
        :param cohortname_pattern:
        :param log:
        :return:
        &#34;&#34;&#34;
        disenrolled_users = {}
        # On boucle avec à chaque fois une cohorte et son tableau d&#39;élèves de la bdd
        for cohort_db, eleves_db in users_by_cohorts_db.items():
            # Calcul du nom complet de la cohorte
            cohortname = cohortname_pattern % cohort_db
            # Si la cohorte n&#39;est pas présente dans le ldap (ce qui ne doit pas être possible, au pire on a un tableau vide)
            #  On désenrole les users de la cohortes côté bdd
            if cohort_db not in users_by_cohorts_ldap.keys():
                for username_db in users_by_cohorts_db[cohort_db]:
                    log.info(&#34;Désenrollement de l&#39;utilisateur %s de la cohorte \&#34;%s\&#34;&#34;, username_db, cohort_db)
                    self.__db.disenroll_user_from_username_and_cohortname(username_db, cohortname)
                    if cohort_db not in disenrolled_users.keys():
                        disenrolled_users[cohort_db] = []
                    disenrolled_users[cohort_db].append(username_db)
            # Sinon, on test pour chaque user si il est présent, et si il est absent on le désenrole
            else:
                for username_db in eleves_db:
                    if username_db not in users_by_cohorts_ldap[cohort_db]:
                        log.info(&#34;Désenrollement de l&#39;utilisateur %s de la cohorte \&#34;%s\&#34;&#34;, username_db, cohort_db)
                        self.__db.disenroll_user_from_username_and_cohortname(username_db, cohortname)
                        if cohort_db not in disenrolled_users.keys():
                            disenrolled_users[cohort_db] = []
                        disenrolled_users[cohort_db].append(username_db)

        # On retourne un dictionnaire des utilisateurs désenrolé par cohortes
        return disenrolled_users

    def purge_cohort_dane_elv_lycee_en(self, elv_lycee_en_ldap: list) -&gt; list:

        #Si on a des établissements dane
        if self.ids_cohorts_dane_lycee_en != {}:

            # Récupération des username des utilisateurs de la cohorte en db
            elv_lycee_en_db = self.__db.get_cohort_members(self.ids_cohorts_dane_lycee_en[UserType.ELEVE])
            # Liste des users désenrollé
            disenrolled_users = []

            # Boucle sur chaques user en db et le désenrole si il n&#39;est pas rpésent dans le ldap
            for username_db in elv_lycee_en_db:
                if username_db not in elv_lycee_en_ldap:
                    log.info(&#34;Désenrollement de l&#39;utilisateur %s de la cohorte dane elv_lycee_en&#34;, username_db)
                    self.__db.disenroll_user_from_username_and_cohortid(username_db, sself.ids_cohorts_dane_lycee_en[UserType.ELEVE])
                    disenrolled_users.append(username_db)

            # On retourne un dictionnaire des utilisateurs désenrolé par cohortes
            return disenrolled_users

    def mise_a_jour_cohorte_interetab(self, is_member_of, cohort_name, since_timestamp: datetime.datetime,
                                      log=getLogger()):
        &#34;&#34;&#34;
        Met à jour la cohorte inter-etablissement.
        :param is_member_of:
        :param cohort_name:
        :param since_timestamp:
        :param log:
        :return:
        &#34;&#34;&#34;
        # Creation de la cohort si necessaire
        self.get_or_create_cohort(self.context.id_context_categorie_inter_etabs, cohort_name, cohort_name,
                                  cohort_name, self.context.timestamp_now_sql, log=log)
        id_cohort = self.__db.get_id_cohort(self.context.id_context_categorie_inter_etabs, cohort_name)

        # Liste permettant de sauvegarder les utilisateurs de la cohorte
        self.context.utilisateurs_by_cohortes[id_cohort] = []

        # Recuperation des utilisateurs
        is_member_of_list = [is_member_of]

        # Ajout des utilisateurs dans la cohorte
        for personne_ldap in self.__ldap.search_personne(
                since_timestamp = since_timestamp,
                isMemberOf = is_member_of_list):
            user_id = self.__db.get_user_id(personne_ldap.uid)
            if user_id:
                self.__db.enroll_user_in_cohort(id_cohort, user_id, self.context.timestamp_now_sql)
                # Mise a jour des utilisateurs de la cohorte
                self.context.utilisateurs_by_cohortes[id_cohort].append(user_id)
            else:
                log.warning(&#34;Impossible d&#39;inserer l&#39;utilisateur %s dans la cohorte %s, &#34;
                            &#34;car il n&#39;est pas connu dans Moodle&#34;, personne_ldap, cohort_name)

    def insert_moodle_structure(self, grp, nom_structure, path, ou, siren, uai):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer une structure dans Moodle.
        :param grp:
        :param nom_structure:
        :param path:
        :param ou:
        :param siren:
        :param uai:
        :return:
        &#34;&#34;&#34;
        # Recuperation du timestamp
        now = self.__db.get_timestamp_now()

        # Creation de la description pour la structure
        description = siren
        if grp:
            description = siren + &#34;@&#34; + nom_structure

        #########################
        # PARTIE CATEGORIE
        #########################
        # Insertion de la categorie correspondant a l&#39;etablissement
        self.__db.insert_moodle_course_category(ou, description, description, uai)
        id_categorie_etablissement = self.__db.get_id_course_category_by_id_number(siren)

        # Mise a jour du path de la categorie
        path_etablissement = &#34;/%d&#34; % id_categorie_etablissement
        self.__db.update_course_category_path(id_categorie_etablissement, path_etablissement)

        #########################
        # PARTIE CONTEXTE
        #########################
        # Insertion du contexte associe a la categorie de l&#39;etablissement
        self.__db.insert_moodle_context(self.__config.constantes.niveau_ctx_categorie,
                                        PROFONDEUR_CTX_ETAB,
                                        id_categorie_etablissement)
        id_contexte_etablissement = self.__db.get_id_context(self.__config.constantes.niveau_ctx_categorie,
                                                             PROFONDEUR_CTX_ETAB,
                                                             id_categorie_etablissement)

        # Mise a jour du path de la categorie
        path_contexte_etablissement = &#34;%s/%d&#34; % (path, id_contexte_etablissement)
        self.__db.update_context_path(id_contexte_etablissement, path_contexte_etablissement)

        #########################
        # PARTIE ZONE PRIVEE
        #########################
        # Insertion du cours pour le forum de discussion
        id_zone_privee = self.__db.insert_zone_privee(id_categorie_etablissement, siren, ou, now)

        # Insertion du contexte associe
        id_contexte_zone_privee = self.__db.insert_zone_privee_context(id_zone_privee)

        # Mise a jour du path du contexte
        path_contexte_zone_privee = &#34;%s/%d&#34; % (path_contexte_etablissement, id_contexte_zone_privee)
        self.__db.update_context_path(id_contexte_zone_privee, path_contexte_zone_privee)

        #########################
        # PARTIE INSCRIPTIONS
        #########################
        # Ouverture du cours a l&#39;inscription manuelle
        role_id = self.__config.constantes.id_role_eleve
        self.__db.insert_moodle_enrol_capability(&#34;manual&#34;, 0, id_zone_privee, role_id)

        #########################
        # PARTIE FORUM
        #########################
        # Insertion du forum au sein de la zone privee
        course = id_zone_privee
        name = FORUM_NAME_ZONE_PRIVEE % ou
        intro = FORUM_INTRO_ZONE_PRIVEE
        intro_format = FORUM_INTRO_FORMAT_ZONE_PRIVEE
        max_bytes = FORUM_MAX_BYTES_ZONE_PRIVEE
        max_attachements = FORUM_MAX_ATTACHEMENTS_ZONE_PRIVEE
        time_modified = now

        id_forum = self.__db.get_id_forum(course)
        if id_forum is None:
            self.__db.insert_moodle_forum(course, name, intro, intro_format, max_bytes, max_attachements, time_modified)
            id_forum = self.__db.get_id_forum(course)

        #########################
        # PARTIE MODULE
        #########################
        # Insertion du module forum dans la zone privee
        course = id_zone_privee
        module = COURSE_MODULES_MODULE
        instance = id_forum
        added = now
        id_course_module = self.__db.get_id_course_module(course)
        if id_course_module is None:
            self.__db.insert_moodle_course_module(course, module, instance, added)
            id_course_module = self.__db.get_id_course_module(course)

        # Insertion du contexte pour le module de cours (forum)
        id_contexte_module = self.__db.get_id_context(self.__config.constantes.niveau_ctx_forum,
                                                      PROFONDEUR_CTX_MODULE_ZONE_PRIVEE,
                                                      id_course_module)
        if id_contexte_module is None:
            self.__db.insert_moodle_context(self.__config.constantes.niveau_ctx_forum,
                                            PROFONDEUR_CTX_MODULE_ZONE_PRIVEE,
                                            id_course_module)
            id_contexte_module = self.__db.get_id_context(self.__config.constantes.niveau_ctx_forum,
                                                          PROFONDEUR_CTX_MODULE_ZONE_PRIVEE,
                                                          id_course_module)

        # Mise a jour du path du contexte
        path_contexte_module = &#34;%s/%d&#34; % (path_contexte_zone_privee, id_contexte_module)
        self.__db.update_context_path(id_contexte_module, path_contexte_module)

        #########################
        # PARTIE BLOC
        #########################
        # Insertion du bloc de recherche forum
        parent_context_id = id_contexte_zone_privee
        block_name = BLOCK_FORUM_SEARCH_NAME
        show_in_subcontexts = BLOCK_FORUM_SEARCH_SHOW_IN_SUB_CTX
        page_type_pattern = BLOCK_FORUM_SEARCH_PAGE_TYPE_PATTERN
        sub_page_pattern = BLOCK_FORUM_SEARCH_SUB_PAGE_PATTERN
        default_region = BLOCK_FORUM_SEARCH_DEFAULT_REGION
        default_weight = BLOCK_FORUM_SEARCH_DEFAULT_WEIGHT

        id_block = self.__db.get_id_block(parent_context_id)
        if id_block is None:
            self.__db.insert_moodle_block(block_name, parent_context_id, show_in_subcontexts, page_type_pattern,
                                          sub_page_pattern, default_region, default_weight)
            id_block = self.__db.get_id_block(parent_context_id)

        # Insertion du contexte pour le bloc
        id_contexte_bloc = self.__db.get_id_context(self.__config.constantes.niveau_ctx_bloc,
                                                    PROFONDEUR_CTX_BLOCK_ZONE_PRIVEE,
                                                    id_block)
        if id_contexte_bloc is None:
            self.__db.insert_moodle_context(self.__config.constantes.niveau_ctx_bloc,
                                            PROFONDEUR_CTX_BLOCK_ZONE_PRIVEE,
                                            id_block)
            id_contexte_bloc = self.__db.get_id_context(self.__config.constantes.niveau_ctx_bloc,
                                                        PROFONDEUR_CTX_BLOCK_ZONE_PRIVEE,
                                                        id_block)

        # Mise a jour du path du contexte
        path_contexte_bloc = &#34;%s/%d&#34; % (path_contexte_zone_privee, id_contexte_bloc)
        self.__db.update_context_path(id_contexte_bloc, path_contexte_bloc)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="synchromoodle.synchronizer.est_grp_etab"><code class="name flex">
<span>def <span class="ident">est_grp_etab</span></span>(<span>uai: str, etablissements_config: <a title="synchromoodle.config.EtablissementsConfig" href="config.html#synchromoodle.config.EtablissementsConfig">EtablissementsConfig</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Indique si un établissement fait partie d'un regroupement d'établissement ou non
:param uai: code de l'établissement
:param etablissements_config: EtablissementsConfig
:return: True si l'établissement fait partie d'un regroupement d'établissement</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def est_grp_etab(uai: str, etablissements_config: EtablissementsConfig):
    &#34;&#34;&#34;
    Indique si un établissement fait partie d&#39;un regroupement d&#39;établissement ou non
    :param uai: code de l&#39;établissement
    :param etablissements_config: EtablissementsConfig
    :return: True si l&#39;établissement fait partie d&#39;un regroupement d&#39;établissement
    &#34;&#34;&#34;
    for regroupement in etablissements_config.etabRgp:
        if uai in regroupement.uais:
            return regroupement
    return False</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="synchromoodle.synchronizer.EtablissementContext"><code class="flex name class">
<span>class <span class="ident">EtablissementContext</span></span>
<span>(</span><span>uai: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Contexte de synchronisation d'établissement</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EtablissementContext:
    &#34;&#34;&#34;
    Contexte de synchronisation d&#39;établissement
    &#34;&#34;&#34;

    def __init__(self, uai: str):
        self.uai = uai  # type: str
        self.id_context_categorie = None
        self.id_context_course_forum = None
        self.etablissement_regroupe = None
        self.structure_ldap = None  # type: StructureLdap
        self.gere_admin_local = None  # type: bool
        self.regexp_admin_moodle = None  # type: str
        self.regexp_admin_local = None  # type: str
        self.id_zone_privee = None  # type: int
        self.etablissement_theme = None  # type: str
        self.eleves_by_cohortes = {}
        self.enseignants_by_cohortes = {}
        self.classe_to_niv_formation = {}
        self.departement = None  # type: str
        self.college = None  # type: bool
        self.lycee = None  # type: bool
        self.etablissement_en = None # type: bool</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.SyncContext"><code class="flex name class">
<span>class <span class="ident">SyncContext</span></span>
</code></dt>
<dd>
<div class="desc"><p>Contexte global de synchronisation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SyncContext:
    &#34;&#34;&#34;
    Contexte global de synchronisation
    &#34;&#34;&#34;

    def __init__(self):
        self.timestamp_now_sql = None
        self.map_etab_domaine = None  # type: Dict[str, List[str]]
        self.id_context_categorie_inter_etabs = None  # type: int
        self.id_context_categorie_inter_cfa = None  # type: int
        self.id_role_extended_teacher = None  # type: int
        self.id_role_advanced_teacher = None  # type: int
        self.id_field_classe = None  # type: int
        self.id_field_domaine = None  # type: int
        self.utilisateurs_by_cohortes = {}</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer"><code class="flex name class">
<span>class <span class="ident">Synchronizer</span></span>
<span>(</span><span>ldap: <a title="synchromoodle.ldaputils.Ldap" href="ldaputils.html#synchromoodle.ldaputils.Ldap">Ldap</a>, db: <a title="synchromoodle.dbutils.Database" href="dbutils.html#synchromoodle.dbutils.Database">Database</a>, config: <a title="synchromoodle.config.Config" href="config.html#synchromoodle.config.Config">Config</a>, action_config: <a title="synchromoodle.config.ActionConfig" href="config.html#synchromoodle.config.ActionConfig">ActionConfig</a> = None, arguments=Namespace(config=[]))</span>
</code></dt>
<dd>
<div class="desc"><p>Synchronise les objets métiers entre l'annuaire LDAP et le Moodle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Synchronizer:
    &#34;&#34;&#34;
    Synchronise les objets métiers entre l&#39;annuaire LDAP et le Moodle.
    &#34;&#34;&#34;

    def __init__(self, ldap: Ldap, db: Database, config: Config, action_config: ActionConfig = None,
                 arguments=DEFAULT_ARGS):
        self.__webservice = WebService(config.webservice)  # type: WebService
        self.__ldap = ldap  # type: Ldap
        self.__db = db  # type: Database
        self.__config = config  # type: Config
        self.__action_config = action_config if action_config \
            else next(iter(config.actions), ActionConfig())  # type: ActionConfig
        self.__arguments = arguments
        self.context = None  # type: SyncContext
        self.context_dane = None  # type: SyncContext
        self.ids_cohorts_dane_lycee_en = {}
        self.ids_cohorts_dane_dep_clg = {}

    def initialize(self):
        &#34;&#34;&#34;
        Initialise la synchronisation
        :return:
        &#34;&#34;&#34;
        self.context = SyncContext()

        # Recuperation du timestamp actuel
        self.context.timestamp_now_sql = self.__db.get_timestamp_now()

        # Récupération de la liste UAI-Domaine des établissements
        self.context.map_etab_domaine = self.__ldap.get_domaines_etabs()

        # Ids des categories inter etablissements
        id_categorie_inter_etabs = self.__db.get_id_categorie(
            self.__action_config.etablissements.inter_etab_categorie_name)
        self.context.id_context_categorie_inter_etabs = self.__db.get_id_context_categorie(id_categorie_inter_etabs)

        id_categorie_inter_cfa = self.__db.get_id_categorie(
            self.__action_config.etablissements.inter_etab_categorie_name_cfa)
        self.context.id_context_categorie_inter_cfa = self.__db.get_id_context_categorie(id_categorie_inter_cfa)

        # Recuperation des ids des roles
        self.context.id_role_extended_teacher = self.__db.get_id_role_by_shortname(&#39;extendedteacher&#39;)
        self.context.id_role_advanced_teacher = self.__db.get_id_role_by_shortname(&#39;advancedteacher&#39;)

        # Recuperation de l&#39;id du user info field pour la classe
        self.context.id_field_classe = self.__db.get_id_user_info_field_by_shortname(&#39;classe&#39;)

        # Recuperation de l&#39;id du champ personnalisé Domaine
        self.context.id_field_domaine = self.__db.get_id_user_info_field_by_shortname(&#39;Domaine&#39;)


    def handle_dane(self, uai_dane, log=getLogger()):
        # Récupération des informations de la dane pour les cohortes de la dane
        log.debug(&#34;Recherche de la structure dane dans l&#39;annuaire&#34;)
        structure_ldap = self.__ldap.get_structure(uai_dane)
        if structure_ldap:
            log.debug(&#34;La structure dane a été trouvée&#34;)
            etablissement_path = &#34;/1&#34;

            # Recuperation du bon theme
            etablissement_theme = structure_ldap.uai.lower()

            # Creation de la structure si elle n&#39;existe pas encore
            id_dane_categorie = self.__db.get_id_course_category_by_theme(context.etablissement_theme)
            if id_dane_categorie is None:
                log.info(&#34;Création de la structure dane&#34;)
                self.insert_moodle_structure(False, structure_ldap.nom,
                                                etablissement_path, structure_ldap.nom,
                                                structure_ldap.siren, etablissement_theme)
                id_dane_categorie = self.__db.get_id_course_category_by_id_number(structure_ldap.siren)

            # Récupération des identifiants de 3 cohortes pour les lycées de l&#39;enseignement national
            for user_type in UserType:
                self.ids_cohorts_dane_lycee_en[user_type] = \
                    self.get_or_create_dane_lycee_en_cohort(id_context_dane, user_type, self.context.timestamp_now_sql)

            # Pour les différents type d&#39;utilisateurs
            for user_type in UserType:
                self.ids_cohorts_dane_dep_clg[user_type] = {}
                # Récupération des identifiants des cohortes pour les collèges par départements
                for departement in self.__config.constantes.departements:
                    self.ids_cohorts_dane_dep_clg[user_type][departement] = \
                        get_or_create_dane_dep_clg_cohort(id_dane_categorie, user_type, departement, self.context.timestamp_now_sql)

            # TODO lvillanne ici avant on avait l&#39;ancien système de purge qui n&#39;est plus valable, donc a réimaginer


    def handle_etablissement(self, uai, log=getLogger(), readonly=False) -&gt; EtablissementContext:
        &#34;&#34;&#34;
        Synchronise un établissement
        :return: EtabContext
        &#34;&#34;&#34;

        context = EtablissementContext(uai)
        context.gere_admin_local = uai not in self.__action_config.etablissements.listeEtabSansAdmin
        context.etablissement_regroupe = est_grp_etab(uai, self.__action_config.etablissements)
        # Regex pour savoir si l&#39;utilisateur est administrateur moodle
        context.regexp_admin_moodle = self.__action_config.etablissements.prefixAdminMoodleLocal + &#34;.*_%s$&#34; % uai
        # Regex pour savoir si l&#39;utilisateur est administrateur local
        context.regexp_admin_local = self.__action_config.etablissements.prefixAdminLocal + &#34;.*_%s$&#34; % uai

        log.debug(&#34;Recherche de la structure dans l&#39;annuaire&#34;)
        structure_ldap = self.__ldap.get_structure(uai)
        if structure_ldap:
            log.debug(&#34;La structure a été trouvée&#34;)
            etablissement_path = &#34;/1&#34;

            # Si l&#39;etablissement fait partie d&#39;un groupement
            if context.etablissement_regroupe:
                etablissement_ou = context.etablissement_regroupe[&#34;nom&#34;]
                structure_ldap.uai = context.etablissement_regroupe[&#34;uais&#34;][0]
                log.debug(&#34;L&#39;établissement fait partie d&#39;un groupement: ou=%s, uai=%s&#34;,
                          etablissement_ou, structure_ldap.uai)
            else:
                etablissement_ou = structure_ldap.nom
                log.debug(&#34;L&#39;établissement ne fait partie d&#39;un groupement: ou=%s&#34;, etablissement_ou)

            # Recuperation du bon theme
            context.etablissement_theme = structure_ldap.uai.lower()

            # Affectation des informations utiles pour la constitution des groupes dane
            context.departement = context.uai[1:3] if context.uai[0] == &#39;0&#39; else context.uai[:3]
            context.college = structure_ldap.type == self.__config.constantes.type_structure_clg
            context.lycee = structure_ldap.type.startswith(self.__config.constantes.type_structure_lycee_start_with)
            context.etablissement_en = structure_ldap.jointure.startswith(self.__config.constantes.type_structure_jointure_en_start_with)

            # Creation de la structure si elle n&#39;existe pas encore
            id_etab_categorie = self.__db.get_id_course_category_by_theme(context.etablissement_theme)
            if id_etab_categorie is None and not readonly:
                log.info(&#34;Création de la structure&#34;)
                self.insert_moodle_structure(context.etablissement_regroupe, structure_ldap.nom,
                                             etablissement_path, etablissement_ou,
                                             structure_ldap.siren, context.etablissement_theme)
                id_etab_categorie = self.__db.get_id_course_category_by_id_number(structure_ldap.siren)

            # Mise a jour de la description dans la cas d&#39;un groupement d&#39;etablissement
            if context.etablissement_regroupe and not readonly:
                description = self.__db.get_description_course_category(id_etab_categorie)
                if description.find(structure_ldap.siren) == -1:
                    log.info(&#34;Mise à jour de la description&#34;)
                    description = &#34;%s$%s@%s&#34; % (description, structure_ldap.siren, structure_ldap.nom)
                    self.__db.update_course_category_description(id_etab_categorie, description)
                    self.__db.update_course_category_name(id_etab_categorie, etablissement_ou)

            # Recuperation de l&#39;id du contexte correspondant à l&#39;etablissement
            if id_etab_categorie is not None:
                context.id_context_categorie = self.__db.get_id_context_categorie(id_etab_categorie)

            context.id_zone_privee = self.__db.get_id_course_by_id_number(&#34;ZONE-PRIVEE-&#34; + structure_ldap.siren)

            # Recreation de la zone privee si celle-ci n&#39;existe plus
            if context.id_zone_privee is None and not readonly:
                log.info(&#34;Création de la zone privée&#34;)
                context.id_zone_privee = self.__db.insert_zone_privee(id_etab_categorie, structure_ldap.siren,
                                                                      etablissement_ou, self.context.timestamp_now_sql)

            if context.id_zone_privee is not None:
                context.id_context_course_forum = self.__db.get_id_context(self.__config.constantes.niveau_ctx_cours, 3,
                                                                           context.id_zone_privee)
            if context.id_context_course_forum is None and not readonly:
                log.info(&#34;Création du cours associé à la zone privée&#34;)
                context.id_context_course_forum = self.__db.insert_zone_privee_context(context.id_zone_privee)

            context.structure_ldap = structure_ldap
        return context


    def construct_classe_to_niv_formation(self, etablissement_context: EtablissementContext, list_eleve_ldap: list[EleveLdap], log=getLogger()):
        &#34;&#34;&#34;
        Associe au contexte de l&#39;établissement un dictionnaire associant une classe à
        un niveau de formation. Utilisé pour pouvoir récupérer le niveau de formation
        d&#39;un enseignant comme il n&#39;est pas présent directement dans le ldap
        &#34;&#34;&#34;
        for eleve_ldap in list_eleve_ldap:
            eleve_classes_for_etab = []
            for classe in eleve_ldap.classes:
                if classe.etab_dn == etablissement_context.structure_ldap.dn:
                    eleve_classes_for_etab.append(classe.classe)
            for classe in eleve_classes_for_etab:
                etablissement_context.classe_to_niv_formation[classe] = eleve_ldap.niveau_formation


    def handle_eleve(self, etablissement_context: EtablissementContext, eleve_ldap: EleveLdap, log=getLogger()):
        &#34;&#34;&#34;
        Synchronise un élève au sein d&#39;un établissement
        :param etablissement_context:
        :param eleve_ldap:
        :param log:
        :return:
        &#34;&#34;&#34;
        mail_display = self.__config.constantes.default_mail_display
        if not eleve_ldap.mail:
            eleve_ldap.mail = self.__config.constantes.default_mail
            log.info(&#34;Le mail de l&#39;élève n&#39;est pas défini dans l&#39;annuaire, &#34;
                     &#34;utilisation de la valeur par défault: %s&#34;, eleve_ldap.mail)

        eleve_id = self.__db.get_user_id(eleve_ldap.uid)

        if not eleve_id:
            log.info(&#34;Ajout de l&#39;utilisateur: %s&#34;, eleve_ldap)
            self.__db.insert_moodle_user(eleve_ldap.uid, eleve_ldap.given_name,
                                         eleve_ldap.sn, eleve_ldap.mail,
                                         mail_display, etablissement_context.etablissement_theme)
            eleve_id = self.__db.get_user_id(eleve_ldap.uid)
        else:
            log.info(&#34;Mise à jour de l&#39;utilisateur: %s&#34;, eleve_ldap)
            self.__db.update_moodle_user(eleve_id, eleve_ldap.given_name,
                                         eleve_ldap.sn, eleve_ldap.mail, mail_display,
                                         etablissement_context.etablissement_theme)

        # Ajout ou suppression du role d&#39;utilisateur avec droits limités Pour les eleves de college
        if etablissement_context.structure_ldap.type == self.__config.constantes.type_structure_clg:
            log.info(&#34;Ajout du rôle droit limités à l&#39;utilisateur: %s&#34;, eleve_ldap)
            self.__db.add_role_to_user(self.__config.constantes.id_role_utilisateur_limite,
                                       self.__config.constantes.id_instance_moodle, eleve_id)
        else:
            self.__db.remove_role_to_user(self.__config.constantes.id_role_utilisateur_limite,
                                          self.__config.constantes.id_instance_moodle, eleve_id)
            log.info(
                &#34;Suppression du role d&#39;utilisateur avec des droits limites à l&#39;utilisateur %s %s %s (id = %s)&#34;
                , eleve_ldap.given_name, eleve_ldap.sn, eleve_ldap.uid, str(eleve_id))

        # Inscription dans les cohortes associees aux classes
        eleve_cohorts = []
        eleve_classes_for_etab = []
        for classe in eleve_ldap.classes:
            if classe.etab_dn == etablissement_context.structure_ldap.dn:
                eleve_classes_for_etab.append(classe.classe)
        if eleve_classes_for_etab:
            log.info(&#34;Inscription de l&#39;élève %s &#34;
                     &#34;dans les cohortes de classes %s&#34;, eleve_ldap, eleve_classes_for_etab)
            ids_classes_cohorts = self.get_or_create_classes_cohorts(etablissement_context.id_context_categorie,
                                                                     eleve_classes_for_etab,
                                                                     self.context.timestamp_now_sql,
                                                                     log=log)
            for ids_classe_cohorts in ids_classes_cohorts:
                self.__db.enroll_user_in_cohort(ids_classe_cohorts, eleve_id, self.context.timestamp_now_sql)

            eleve_cohorts.extend(ids_classes_cohorts)

        # Inscription dans la cohorte associee au niveau de formation
        if eleve_ldap.niveau_formation:
            log.info(&#34;Inscription de l&#39;élève %s &#34;
                     &#34;dans la cohorte de niveau de formation %s&#34;, eleve_ldap, eleve_ldap.niveau_formation)
            id_formation_cohort = self.get_or_create_formation_cohort(etablissement_context.id_context_categorie,
                                                                      eleve_ldap.niveau_formation,
                                                                      self.context.timestamp_now_sql,
                                                                      log=log)
            self.__db.enroll_user_in_cohort(id_formation_cohort, eleve_id, self.context.timestamp_now_sql)
            eleve_cohorts.append(id_formation_cohort)

        # Inscription dans les cohortes de la Dane
        if etablissement_context.college and etablissement_context.departement in self.__config.constantes.departements:
            self.__db.enroll_user_in_cohort(self.ids_cohorts_dane_dep_clg[UserType.ELEVE][etablissement_context.departement],
                eleve_id, self.context.timestamp_now_sql)
        elif etablissement_context.lycee and etablissement_context.etablissement_en:
            self.__db.enroll_user_in_cohort(self.ids_cohorts_dane_lycee_en[UserType.ELEVE], eleve_id, self.context.timestamp_now_sql)

        # Mise a jour de la classe
        id_user_info_data = self.__db.get_id_user_info_data(eleve_id, self.context.id_field_classe)
        if id_user_info_data is not None:
            self.__db.update_user_info_data(eleve_id, self.context.id_field_classe, eleve_ldap.classe.classe)
            log.debug(&#34;Mise à jour user_info_data&#34;)
        else:
            self.__db.insert_moodle_user_info_data(eleve_id, self.context.id_field_classe, eleve_ldap.classe.classe)
            log.debug(&#34;Insertion user_info_data&#34;)

        # Mise a jour du Domaine
        user_domain = self.__config.constantes.default_domain
        if len(eleve_ldap.domaines) == 1:
            user_domain = eleve_ldap.domaines[0]
        else:
            if eleve_ldap.uai_courant and eleve_ldap.uai_courant in self.context.map_etab_domaine:
                user_domain = self.context.map_etab_domaine[eleve_ldap.uai_courant][0]
        log.debug(&#34;Insertion du Domaine&#34;)
        self.__db.set_user_domain(eleve_id, self.context.id_field_domaine, user_domain)


    def handle_enseignant(self, etablissement_context: EtablissementContext, enseignant_ldap: EnseignantLdap,
                          log=getLogger()):
        &#34;&#34;&#34;
        Met à jour un enseignant au sein d&#39;un établissement
        :param etablissement_context:
        :param enseignant_ldap:
        :param log:
        :return:
        &#34;&#34;&#34;

        enseignant_infos = &#34;%s %s %s&#34; % (enseignant_ldap.uid, enseignant_ldap.given_name, enseignant_ldap.sn)

        if enseignant_ldap.uai_courant and not etablissement_context.etablissement_regroupe:
            etablissement_context.etablissement_theme = enseignant_ldap.uai_courant.lower()

        if not enseignant_ldap.mail:
            enseignant_ldap.mail = self.__config.constantes.default_mail

        # Affichage du mail reserve aux membres de cours
        mail_display = self.__config.constantes.default_mail_display
        if etablissement_context.structure_ldap.uai in self.__action_config.etablissements.listeEtabSansMail:
            # Desactivation de l&#39;affichage du mail
            mail_display = 0

        # Insertion de l&#39;enseignant
        id_user = self.__db.get_user_id(enseignant_ldap.uid)
        if not id_user:
            self.__db.insert_moodle_user(enseignant_ldap.uid, enseignant_ldap.given_name, enseignant_ldap.sn,
                                         enseignant_ldap.mail,
                                         mail_display, etablissement_context.etablissement_theme)
            id_user = self.__db.get_user_id(enseignant_ldap.uid)
        else:
            self.__db.update_moodle_user(id_user, enseignant_ldap.given_name, enseignant_ldap.sn, enseignant_ldap.mail,
                                         mail_display, etablissement_context.etablissement_theme)

        # Mise à jour des droits sur les anciens etablissement
        if enseignant_ldap.uais is not None and not etablissement_context.etablissement_regroupe:
            # Recuperation des uais des etablissements dans lesquels l&#39;enseignant est autorise
            self.mettre_a_jour_droits_enseignant(enseignant_infos, id_user, enseignant_ldap.uais, log=log)

        # Ajout du role de createur de cours au niveau de la categorie inter-etablissement Moodle
        self.__db.add_role_to_user(self.__config.constantes.id_role_createur_cours,
                                   self.context.id_context_categorie_inter_etabs, id_user)
        log.info(&#34;Ajout du role de createur de cours dans la categorie inter-etablissements&#34;)

        # Si l&#39;enseignant fait partie d&#39;un CFA
        # Ajout du role createur de cours au niveau de la categorie inter-cfa
        if etablissement_context.structure_ldap.type == self.__config.constantes.type_structure_cfa:
            self.__db.add_role_to_user(self.__config.constantes.id_role_createur_cours,
                                       self.context.id_context_categorie_inter_cfa, id_user)
            log.info(&#34;Ajout du role de createur de cours dans la categorie inter-cfa&#34;)
        else:
            if  etablissement_context.structure_ldap.type.startswith(&#39;LYCEE&#39;) \
                or etablissement_context.structure_ldap.type == self.__config.constantes.type_structure_ens_adapte \
                or etablissement_context.structure_ldap.uai == &#39;0370074E&#39; \
                or ( etablissement_context.structure_ldap.type.startswith(&#39;COLLEGE&#39;) \
                or etablissement_context.structure_ldap.type == self.__config.constantes.type_structure_cfa_agricole  ) :
                if set(enseignant_ldap.profils).intersection([&#39;National_ENS&#39;,&#39;National_DOC&#39;,&#39;National_DIR&#39;, &#39;National_ETA&#39;, &#39;National_EVS&#39;]):
                    log.info(&#34;Ajout du rôle bigbluebutton pour l&#39;utilisateur %s&#34; % id_user)
                    self.__db.add_role_to_user(self.__config.constantes.id_role_bigbluebutton,
                                               self.__config.constantes.id_instance_moodle, id_user)

        # ajout du role de createur de cours dans l&#39;etablissement
        self.__db.add_role_to_user(self.__config.constantes.id_role_createur_cours,
                                   etablissement_context.id_context_categorie, id_user)

        # Ajouts des autres roles pour le personnel établissement
        if set(enseignant_ldap.profils).intersection([&#39;National_ENS&#39;, &#39;National_DIR&#39;, &#39;National_EVS&#39;, &#39;National_ETA&#39;]):
            # Ajout des roles sur le contexte forum
            self.__db.add_role_to_user(self.__config.constantes.id_role_eleve,
                                       etablissement_context.id_context_course_forum, id_user)
            # Inscription à la Zone Privée
            self.__db.enroll_user_in_course(self.__config.constantes.id_role_eleve,
                                            etablissement_context.id_zone_privee, id_user)

            if set(enseignant_ldap.profils).intersection([&#39;National_ENS&#39;, &#39;National_EVS&#39;, &#39;National_ETA&#39;]):
                if not etablissement_context.gere_admin_local:
                    self.__db.add_role_to_user(self.context.id_role_extended_teacher,
                                               etablissement_context.id_context_categorie,
                                               id_user)
            elif &#39;National_DIR&#39; in enseignant_ldap.profils:
                self.__db.add_role_to_user(self.__config.constantes.id_role_directeur,
                                           etablissement_context.id_context_categorie, id_user)

        # Ajout des droits d&#39;administration locale pour l&#39;etablissement
        if etablissement_context.gere_admin_local:
            for member in enseignant_ldap.is_member_of:
                # L&#39;enseignant est il administrateur Moodle ?
                admin_moodle = re.match(etablissement_context.regexp_admin_moodle, member, flags=re.IGNORECASE)
                if admin_moodle:
                    self.__db.insert_moodle_local_admin(etablissement_context.id_context_categorie, id_user)
                    log.info(&#34;Insertion d&#39;un admin  local %s %s %s&#34;,
                             enseignant_ldap.uid, enseignant_ldap.given_name, enseignant_ldap.sn)
                    # Si il est admin local on en fait un utilisateur avancé par default
                    if not self.__db.is_enseignant_avance(id_user, self.context.id_role_advanced_teacher):
                        self.__db.add_role_to_user(self.context.id_role_advanced_teacher, 1, id_user)
                    break
                else:
                    delete = self.__db.delete_moodle_local_admin(self.context.id_context_categorie_inter_etabs, id_user)
                    if delete:
                        log.info(&#34;Suppression d&#39;un admin local %s %s %s&#34;,
                                 enseignant_ldap.uid, enseignant_ldap.given_name, enseignant_ldap.sn)

        # Inscription dans les cohortes associees aux classes et au niveau de formation
        enseignant_cohorts = []
        enseignant_classes_for_etab = []
        #Récupération des classes de l&#39;établissement traité actuellement
        for classe in enseignant_ldap.classes:
            if classe.etab_dn == etablissement_context.structure_ldap.dn:
                enseignant_classes_for_etab.append(classe.classe)
        if enseignant_classes_for_etab:
            log.info(&#34;Inscription de l&#39;enseignant %s dans les cohortes de classes %s&#34;,
                     enseignant_ldap, enseignant_classes_for_etab)
            name_pattern = &#34;Profs de la Classe %s&#34;
            desc_pattern = &#34;Profs de la Classe %s&#34;
            #Création des cohortes de classes
            ids_classes_cohorts = self.get_or_create_classes_cohorts(etablissement_context.id_context_categorie,
                                                                     enseignant_classes_for_etab,
                                                                     self.context.timestamp_now_sql,
                                                                     name_pattern=name_pattern,
                                                                     desc_pattern=desc_pattern,
                                                                     log=log)
            #Inscription dans les cohortes de classe
            for ids_classe_cohorts in ids_classes_cohorts:
                self.__db.enroll_user_in_cohort(ids_classe_cohorts, id_user, self.context.timestamp_now_sql)

            enseignant_cohorts.extend(ids_classes_cohorts)

            #Inscription dans les cohortes de niveau de formation
            enseignant_niv_formation = set()
            for classe in enseignant_classes_for_etab:
                #Il est possible que l&#39;enseignant enseigne dans une classe mais qui n&#39;est pas dans cet établissement
                #Il sera alors inscrit dans la cohorte du niveau de formation correspondant à la classe lorsqu&#39;on le
                #traitera avec l&#39;autre établissement en question
                if classe in etablissement_context.classe_to_niv_formation.keys():
                    enseignant_niv_formation.add(etablissement_context.classe_to_niv_formation[classe])
                else:
                    log.error(&#34;Problème avec l&#39;enseignant %s pour l&#39;inscrire dans les cohortes de niveau de formation&#34;, enseignant_ldap)

            log.info(&#34;Inscription de l&#39;enseignant %s dans les cohortes de niveau de formation %s&#34;,
                     enseignant_ldap, enseignant_niv_formation)

            name_pattern = &#34;Profs du niveau de formation %s&#34;
            desc_pattern = &#34;Profs du niveau de formation %s&#34;
            #Création des cohortes de niveau de formation
            ids_niv_formation_cohorts = self.get_or_create_niv_formation_cohorts(etablissement_context.id_context_categorie,
                                                                                 enseignant_niv_formation,
                                                                                 self.context.timestamp_now_sql,
                                                                                 name_pattern=name_pattern,
                                                                                 desc_pattern=desc_pattern,
                                                                                 log=log)
            #Inscription dans les cohortes de niveau de formation
            for id_cohort_niv_formation in ids_niv_formation_cohorts:
                self.__db.enroll_user_in_cohort(id_cohort_niv_formation, id_user, self.context.timestamp_now_sql)

        log.info(&#34;Inscription de l&#39;enseignant %s dans la cohorte d&#39;enseignants de l&#39;établissement&#34;, enseignant_ldap)
        id_prof_etabs_cohort = self.get_or_create_profs_etab_cohort(etablissement_context, log)

        id_user = self.__db.get_user_id(enseignant_ldap.uid)
        self.__db.enroll_user_in_cohort(id_prof_etabs_cohort, id_user, self.context.timestamp_now_sql)

        # TODO lvillanne réaliser l&#39;inscription dans les cohortes de la dane

        # Mise a jour des dictionnaires concernant les cohortes
        for cohort_id in enseignant_cohorts:
            # Si la cohorte est deja connue
            if cohort_id in etablissement_context.enseignants_by_cohortes:
                etablissement_context.enseignants_by_cohortes[cohort_id].append(id_user)
            # Si la cohorte n&#39;a pas encore ete rencontree
            else:
                etablissement_context.enseignants_by_cohortes[cohort_id] = [id_user]

        # Mise a jour du Domaine
        user_domain = self.__config.constantes.default_domain
        if len(enseignant_ldap.domaines) == 1:
            user_domain = enseignant_ldap.domaines[0]
        else:
            if enseignant_ldap.uai_courant and enseignant_ldap.uai_courant in self.context.map_etab_domaine:
                user_domain = self.context.map_etab_domaine[enseignant_ldap.uai_courant][0]
        log.debug(&#34;Insertion du Domaine&#34;)
        self.__db.set_user_domain(id_user, self.context.id_field_domaine, user_domain)

    def handle_user_interetab(self, personne_ldap: PersonneLdap, log=getLogger()):
        &#34;&#34;&#34;
        Synchronise un utilisateur inter-etablissement
        :param personne_ldap:
        :param log:
        :return:
        &#34;&#34;&#34;
        if not personne_ldap.mail:
            personne_ldap.mail = self.__config.constantes.default_mail

        # Creation de l&#39;utilisateur
        id_user = self.__db.get_user_id(personne_ldap.uid)
        if not id_user:
            self.__db.insert_moodle_user(personne_ldap.uid, personne_ldap.given_name, personne_ldap.sn,
                                         personne_ldap.mail,
                                         self.__config.constantes.default_mail_display,
                                         self.__config.constantes.default_moodle_theme)
            id_user = self.__db.get_user_id(personne_ldap.uid)
        else:
            self.__db.update_moodle_user(id_user, personne_ldap.given_name, personne_ldap.sn, personne_ldap.mail,
                                         self.__config.constantes.default_mail_display,
                                         self.__config.constantes.default_moodle_theme)

        # Ajout du role de createur de cours
        self.__db.add_role_to_user(self.__config.constantes.id_role_createur_cours,
                                   self.context.id_context_categorie_inter_etabs, id_user)

        # Attribution du role admin local si necessaire
        for member in personne_ldap.is_member_of:
            admin = re.match(self.__action_config.inter_etablissements.ldap_valeur_attribut_admin, member,
                             flags=re.IGNORECASE)
            if admin:
                insert = self.__db.insert_moodle_local_admin(self.context.id_context_categorie_inter_etabs, id_user)
                if insert:
                    log.info(&#34;Insertion d&#39;un admin local %s %s %s&#34;,
                             personne_ldap.uid, personne_ldap.given_name, personne_ldap.sn)
                break
            else:
                delete = self.__db.delete_moodle_local_admin(self.context.id_context_categorie_inter_etabs, id_user)
                if delete:
                    log.info(&#34;Suppression d&#39;un admin local %s %s %s&#34;,
                             personne_ldap.uid, personne_ldap.given_name, personne_ldap.sn)

    def handle_inspecteur(self, personne_ldap: PersonneLdap, log=getLogger()):
        &#34;&#34;&#34;
        Synchronise un inspecteur
        :param personne_ldap:
        :param log:
        :return:
        &#34;&#34;&#34;
        if not personne_ldap.mail:
            personne_ldap.mail = self.__config.constantes.default_mail

            # Creation de l&#39;utilisateur
            self.__db.insert_moodle_user(personne_ldap.uid, personne_ldap.given_name, personne_ldap.sn,
                                         personne_ldap.mail,
                                         self.__config.constantes.default_mail_display,
                                         self.__config.constantes.default_moodle_theme)
        id_user = self.__db.get_user_id(personne_ldap.uid)
        if not id_user:
            self.__db.insert_moodle_user(personne_ldap.uid, personne_ldap.given_name, personne_ldap.sn,
                                         personne_ldap.mail,
                                         self.__config.constantes.default_mail_display,
                                         self.__config.constantes.default_moodle_theme)
            id_user = self.__db.get_user_id(personne_ldap.uid)
        else:
            self.__db.update_moodle_user(id_user, personne_ldap.given_name, personne_ldap.sn, personne_ldap.mail,
                                         self.__config.constantes.default_mail_display,
                                         self.__config.constantes.default_moodle_theme)

        # Ajout du role de createur de cours au niveau de la categorie inter-etablissement Moodle
        self.__db.add_role_to_user(self.__config.constantes.id_role_createur_cours,
                                   self.context.id_context_categorie_inter_etabs, id_user)
        log.info(&#34;Ajout du role de createur de cours dans la categorie inter-etablissements&#34;)

        # Mise a jour du Domaine
        user_domain = self.__config.constantes.default_domain
        if len(personne_ldap.domaines) == 1:
            user_domain = personne_ldap.domaines[0]
        else:
            if personne_ldap.uai_courant and personne_ldap.uai_courant in self.context.map_etab_domaine:
                user_domain = self.context.map_etab_domaine[personne_ldap.uai_courant][0]
        log.debug(&#34;Insertion du Domaine&#34;)
        self.__db.set_user_domain(id_user, self.context.id_field_domaine, user_domain)

    def mettre_a_jour_droits_enseignant(self, enseignant_infos, id_enseignant, uais_autorises, log=getLogger()):
        &#34;&#34;&#34;
        Fonction permettant de mettre a jour les droits d&#39;un enseignant.
        Cette mise a jour consiste a :
          - Supprimer les roles non autorises
          - ajouter les roles
        :param enseignant_infos:
        :param id_enseignant:
        :param uais_autorises:
        :param log:
        :return:
        &#34;&#34;&#34;
        # Recuperation des themes autorises pour l&#39;enseignant
        themes_autorises = [uai_autorise.lower() for uai_autorise in uais_autorises]
        log.debug(&#34;Etablissements autorises pour l&#39;enseignant pour %s : %s&#34;,
                  enseignant_infos, themes_autorises)

        #########################
        # ZONES PRIVEES
        #########################
        # Recuperation des ids des roles et les themes non autorises
        ids_roles_non_autorises, ids_themes_non_autorises = self.__db.get_ids_and_themes_not_allowed_roles(
            id_enseignant, themes_autorises)

        # Suppression des roles non autorises
        if ids_roles_non_autorises:
            self.__db.delete_roles(ids_roles_non_autorises)
            log.info(&#34;Suppression des rôles d&#39;enseignant pour %s dans les établissements %s&#34;
                     , enseignant_infos, str(ids_themes_non_autorises))
            log.info(&#34;Les seuls établissements autorisés pour cet enseignant sont %s&#34;, themes_autorises)

        #########################
        # FORUMS
        #########################
        # Recuperation des SIREN des etablissements dans lequel l&#39;enseignant travaille
        sirens = self.__db.get_descriptions_course_categories_by_themes(themes_autorises)

        # Shortname des forums associes
        # Ancien code : shortnames_forums = [ ( &#34;ZONE-PRIVEE-%s&#34; % str( siren ) ) for siren in sirens ]
        shortnames_forums = [&#34;ZONE-PRIVEE-%s&#34; % siren for siren in sirens]

        # Recuperation des roles sur les forums qui ne devraient plus exister
        ids_roles_non_autorises, forums_summaries = self.__db.get_ids_and_summaries_not_allowed_roles(id_enseignant,
                                                                                                      shortnames_forums)

        # Suppression des roles non autorises
        if ids_roles_non_autorises:
            # Suppression des roles
            self.__db.delete_roles(ids_roles_non_autorises)
            log.info(&#34;Suppression des rôles d&#39;enseignant pour %s sur les forum &#39;%s&#39; &#34;,
                     enseignant_infos, str(forums_summaries))
            log.info(&#34;Les seuls établissements autorisés pour cet enseignant sont &#39;%s&#39;&#34;, themes_autorises)

    def get_or_create_cohort(self, id_context, name, id_number, description, time_created, log=getLogger()):
        &#34;&#34;&#34;
        Fonction permettant de creer une nouvelle cohorte pour un contexte donne.
        :param id_context:
        :param name:
        :param id_number:
        :param description:
        :param time_created:
        :return:
        &#34;&#34;&#34;
        id_cohort = self.__db.get_id_cohort(id_context, name)
        if id_cohort is None:
            self.__db.create_cohort(id_context, name, id_number, description, time_created)
            log.info(&#34;Creation de la cohorte (name=%s)&#34;, name)
            return self.__db.get_id_cohort(id_context, name)
        return id_cohort

    def get_or_create_dane_lycee_en_cohort(self, id_context_dane, user_type: UserType, timestamp_now_sql, log=getLogger()):
        &#34;&#34;&#34;
        Charge ou créer une cohorte dane lycee_en soit pour les élèves, les enseignant ou le personnel de direction
        :param id_context_dane:
        :param user_type:
        :param timestamp_now_sql:
        :param log:
        :return:
        &#34;&#34;&#34;
        all_cohort_name = {
            UserType.ELEVE: &#39;Élèves des lycées de l\&#39;éducation national&#39;,
            UserType.ENSEIGNANT: &#39;Enseignants des lycées de l\&#39;éducation national&#39;,
            UserType.PERSONNEL_DE_DIRECTION: &#39;Personnel de direction des lycées de l\&#39;éducation national&#39;
        }
        cohort_name = all_cohort_name[user_type]
        cohort_description = cohort_name
        id_cohort = self.get_or_create_cohort(id_context_dane, cohort_name, cohort_name, cohort_description,
                                              timestamp_now_sql, log)
        return id_cohort

    def get_or_create_dane_dep_clg_cohort(self, id_context_dane, user_type: UserType, departement, timestamp_now_sql, log=getLogger()):
        &#34;&#34;&#34;
        Charge ou créer une cohorte dane dep_clg soit pour les élèves, les enseignant ou le personnel de direction
        :param id_context_dane:
        :param user_type:
        :param departement:
        :param timestamp_now_sql:
        :param log:
        :return:
        &#34;&#34;&#34;
        all_cohort_name = {
            UserType.ELEVE: &#39;Élèves des collèges du {}&#39;,
            UserType.ENSEIGNANT: &#39;Enseignants des collèges du {}&#39;,
            UserType.PERSONNEL_DE_DIRECTION: &#39;Personnel de direction des collèges du {}&#39;
        }
        cohort_name = all_cohort_name[user_type].format(departement)
        cohort_description = cohort_name
        id_cohort = self.get_or_create_cohort(id_context_dane, cohort_name, cohort_name, cohort_description,
                                              timestamp_now_sql, log)
        return id_cohort

    def get_or_create_formation_cohort(self, id_context_etab, niveau_formation, timestamp_now_sql, log=getLogger()):
        &#34;&#34;&#34;
        Charge ou créer une cohorte de formation
        :param id_context_etab:
        :param niveau_formation:
        :param timestamp_now_sql:
        :param log:
        :return:
        &#34;&#34;&#34;
        cohort_name = &#39;Élèves du Niveau de formation %s&#39; % niveau_formation
        cohort_description = &#39;Eleves avec le niveau de formation %s&#39; % niveau_formation
        id_cohort = self.get_or_create_cohort(id_context_etab, cohort_name, cohort_name, cohort_description,
                                              timestamp_now_sql, log)
        return id_cohort

    def get_or_create_classes_cohorts(self, id_context_etab, classes_names, time_created, name_pattern=None,
                                      desc_pattern=None, log=getLogger()):
        &#34;&#34;&#34;
        Charge ou crée des cohortes a partir de classes liées a un établissement.
        :param id_context_etab:
        :param classes_names:
        :param time_created:
        :param name_pattern:
        :param desc_pattern:
        :return:
        &#34;&#34;&#34;

        if name_pattern is None:
            name_pattern = &#34;Élèves de la Classe %s&#34;
        if desc_pattern is None:
            desc_pattern = &#34;Élèves de la Classe %s&#34;

        ids_cohorts = []
        for class_name in classes_names:
            cohort_name = name_pattern % class_name
            cohort_description = desc_pattern % class_name
            id_cohort = self.get_or_create_cohort(id_context_etab,
                                                  cohort_name,
                                                  cohort_name,
                                                  cohort_description,
                                                  time_created,
                                                  log=log)
            ids_cohorts.append(id_cohort)
        return ids_cohorts

    def get_or_create_niv_formation_cohorts(self, id_context_etab, niveaux_formation, time_created, name_pattern, desc_pattern, log=getLogger()):
        &#34;&#34;&#34;
        Charge ou crée des cohortes a partir de niveau de formation liés a un établissement.
        :param id_context_etab:
        :param niveaux_formation:
        :param time_created:
        :param name_pattern:
        :param desc_pattern:
        :return:
        &#34;&#34;&#34;

        ids_cohorts = []
        for niveau_formation in niveaux_formation:
            cohort_name = name_pattern % niveau_formation
            cohort_description = desc_pattern % niveau_formation
            id_cohort = self.get_or_create_cohort(id_context_etab,
                                                  cohort_name,
                                                  cohort_name,
                                                  cohort_description,
                                                  time_created,
                                                  log=log)
            ids_cohorts.append(id_cohort)
        return ids_cohorts

    def get_or_create_profs_etab_cohort(self, etab_context: EtablissementContext, log=getLogger()):
        &#34;&#34;&#34;
        Charge ou crée la cohorte d&#39;enseignant de l&#39;établissement.
        :param etab_context:
        :param log:
        :return:
        &#34;&#34;&#34;
        cohort_name = &#39;Profs de l\&#39;établissement (%s)&#39; % etab_context.uai
        cohort_description = &#39;Enseignants de l\&#39;établissement %s&#39; % etab_context.uai
        id_cohort_enseignants = self.get_or_create_cohort(etab_context.id_context_categorie,
                                                          cohort_name,
                                                          cohort_name,
                                                          cohort_description,
                                                          self.context.timestamp_now_sql,
                                                          log=log)
        return id_cohort_enseignants

    def get_users_by_cohorts_comparators_eleves_classes(self, etab_context: EtablissementContext, cohortname_pattern_re: str,
                                         cohortname_pattern: str) -&gt; (Dict[str, List[str]], Dict[str, List[str]]):
        &#34;&#34;&#34;
        Renvoie deux dictionnaires listant les élèves (uid) dans chacune des classes.
        Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
        :param etab_context: EtablissementContext
        :param cohortname_pattern_re: str
        :param cohortname_pattern: str
        :return:
        &#34;&#34;&#34;
        # Récupére les cohortes qui correspondent au pattern et qui sont lié à l&#39;établissement du context
        classes_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

        # Dictionnaire contenant la liste des élèves par cohorte provenant de la bdd
        eleves_by_cohorts_db = {}
        # Pour chaque cohorte de la bdd
        for cohort in classes_cohorts:
            matches = re.search(cohortname_pattern_re, cohort.name)
            # On récupére le nom de la classe (fin du nom de la cohorte qui lui est fixe)
            classe_name = matches.group(2)
            # On créé le tableau vide pour y stocker les élèves
            eleves_by_cohorts_db[classe_name] = []
            # Et on stocke les élèves de cette cohorte en provenant ce la bdd
            for username in self.__db.get_cohort_members(cohort.id):
                eleves_by_cohorts_db[classe_name].append(username.lower())

        # Dictionnaire contenant la liste des élèves par cohorte provenant du ldap
        eleves_by_cohorts_ldap = {}
        # Pour chaque cohorte de la bdd
        for classe in eleves_by_cohorts_db:
            # On créé le tableau vide pour y stocker les élèves
            eleves_by_cohorts_ldap[classe] = []
            # Et on stocke les élèves de cette cohorte en provenant du ldap
            for eleve in self.__ldap.search_eleves_in_classe(classe, etab_context.uai):
                eleves_by_cohorts_ldap[classe].append(eleve.uid.lower())

        return eleves_by_cohorts_db, eleves_by_cohorts_ldap

    def get_users_by_dane_cohorts(self, cohortname_pattern: str) -&gt; List[str]:
        &#34;&#34;&#34;
        Renvoie un dictionnaire listant les utilisateurs BDD (uid) dans la cohorte dane.
        :param cohortname_pattern: str
        :return:
        &#34;&#34;&#34;
        # Récupére les cohortes qui correspondent au pattern et qui sont lié à l&#39;établissement du context
        classes_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

        # Dictionnaire contenant la liste des élèves par cohorte provenant de la bdd
        eleves_by_cohorts_db = {}
        # Pour chaque cohorte de la bdd
        for cohort in classes_cohorts:
            matches = re.search(cohortname_pattern_re, cohort.name)
            # On récupére le nom de la classe (fin du nom de la cohorte qui lui est fixe)
            classe_name = matches.group(2)
            # On créé le tableau vide pour y stocker les élèves
            eleves_by_cohorts_db[classe_name] = []
            # Et on stocke les élèves de cette cohorte en provenant ce la bdd
            for username in self.__db.get_cohort_members(cohort.id):
                eleves_by_cohorts_db[classe_name].append(username.lower())

        # Dictionnaire contenant la liste des élèves par cohorte provenant du ldap
        eleves_by_cohorts_ldap = {}
        # Pour chaque cohorte de la bdd
        for classe in eleves_by_cohorts_db:
            # On créé le tableau vide pour y stocker les élèves
            eleves_by_cohorts_ldap[classe] = []
            # Et on stocke les élèves de cette cohorte en provenant du ldap
            for eleve in self.__ldap.search_eleves_in_classe(classe, etab_context.uai):
                eleves_by_cohorts_ldap[classe].append(eleve.uid.lower())

        return eleves_by_cohorts_db, eleves_by_cohorts_ldap

    def get_users_by_cohorts_comparators_eleves_niveau(self, etab_context: EtablissementContext, cohortname_pattern_re: str,
                                         cohortname_pattern: str) -&gt; (Dict[str, List[str]], Dict[str, List[str]]):
        &#34;&#34;&#34;
        Renvoie deux dictionnaires listant les élèves (uid) dans chacun des niveaux de formation
        Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
        :param etab_context: EtablissementContext
        :param cohortname_pattern_re: str
        :param cohortname_pattern: str
        :return:
        &#34;&#34;&#34;
        classes_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

        eleves_by_cohorts_db = {}
        for cohort in classes_cohorts:
            matches = re.search(cohortname_pattern_re, cohort.name)
            classe_name = matches.group(2)
            eleves_by_cohorts_db[classe_name] = []
            for username in self.__db.get_cohort_members(cohort.id):
                eleves_by_cohorts_db[classe_name].append(username.lower())

        eleves_by_cohorts_ldap = {}
        for niveau in eleves_by_cohorts_db:
            eleves_by_cohorts_ldap[niveau] = []
            for eleve in self.__ldap.search_eleves_in_niveau(niveau, etab_context.uai):
                eleves_by_cohorts_ldap[niveau].append(eleve.uid.lower())

        return eleves_by_cohorts_db, eleves_by_cohorts_ldap

    def get_users_by_cohorts_comparators_profs_classes(self, etab_context: EtablissementContext, cohortname_pattern_re: str,
                                         cohortname_pattern: str) -&gt; (Dict[str, List[str]], Dict[str, List[str]]):
        &#34;&#34;&#34;
        Renvoie deux dictionnaires listant les profs (uid) dans chacune des classes
        Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
        :param etab_context: EtablissementContext
        :param cohortname_pattern_re: str
        :param cohortname_pattern: str
        :return:
        &#34;&#34;&#34;
        classes_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

        profs_by_cohorts_db = {}
        for cohort in classes_cohorts:
            matches = re.search(cohortname_pattern_re, cohort.name)
            classe_name = matches.group(2)
            profs_by_cohorts_db[classe_name] = []
            for username in self.__db.get_cohort_members(cohort.id):
                profs_by_cohorts_db[classe_name].append(username.lower())

        profs_by_cohorts_ldap = {}
        for classe in profs_by_cohorts_db:
            profs_by_cohorts_ldap[classe] = []
            for prof in self.__ldap.search_enseignants_in_classe(classe, etab_context.uai):
                profs_by_cohorts_ldap[classe].append(prof.uid.lower())

        return profs_by_cohorts_db, profs_by_cohorts_ldap


    def get_users_by_cohorts_comparators_profs_etab(self, etab_context: EtablissementContext, cohortname_pattern_re: str,
                                         cohortname_pattern: str) -&gt; (Dict[str, List[str]], Dict[str, List[str]]):
        &#34;&#34;&#34;
        Renvoie deux dictionnaires listant les profs (uid) dans chacun des établissement
        Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
        :param etab_context: EtablissementContext
        :param cohortname_pattern_re: str
        :param cohortname_pattern: str
        :return:
        &#34;&#34;&#34;
        etab_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

        profs_by_cohorts_db = {}
        for cohort in etab_cohorts:
            matches = re.search(cohortname_pattern_re, cohort.name)
            etab_name = matches.group(2)
            profs_by_cohorts_db[etab_name] = []
            for username in self.__db.get_cohort_members(cohort.id):
                profs_by_cohorts_db[etab_name].append(username.lower())

        profs_by_cohorts_ldap = {}
        for etab in profs_by_cohorts_db:
            profs_by_cohorts_ldap[etab] = []
            for prof in self.__ldap.search_enseignants_in_etab(etab_context.uai):
                profs_by_cohorts_ldap[etab].append(prof.uid.lower())

        return profs_by_cohorts_db, profs_by_cohorts_ldap


    def get_users_by_cohorts_comparators_profs_niveau(self, etab_context: EtablissementContext, cohortname_pattern_re: str,
                                         cohortname_pattern: str) -&gt; (Dict[str, List[str]], Dict[str, List[str]]):
        &#34;&#34;&#34;
        Renvoie deux dictionnaires listant les profs (uid) dans chacun des niveaux de formation
        Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
        :param etab_context: EtablissementContext
        :param cohortname_pattern_re: str
        :param cohortname_pattern: str
        :return:
        &#34;&#34;&#34;

        #Construit le dictionnaire pour avoir l&#39;association classe -&gt; niveau de formation
        self.construct_classe_to_niv_formation(etab_context, self.__ldap.search_eleve(None, etab_context.uai))

        #Récupère les cohortes coté moodle
        levels_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

        profs_by_cohorts_db = {}
        for cohort in levels_cohorts:
            matches = re.search(cohortname_pattern_re, cohort.name)
            level_name = matches.group(2)
            profs_by_cohorts_db[level_name] = []
            for username in self.__db.get_cohort_members(cohort.id):
                profs_by_cohorts_db[level_name].append(username.lower())

        profs_by_cohorts_ldap = {}
        for niveau in profs_by_cohorts_db:
            profs_by_cohorts_ldap[niveau] = []
            for prof in self.__ldap.search_enseignants_in_niveau(niveau, etab_context.uai, etab_context.classe_to_niv_formation):
                profs_by_cohorts_ldap[niveau].append(prof.uid.lower())

        return profs_by_cohorts_db, profs_by_cohorts_ldap


    def list_contains_username(self, ldap_users: List[PersonneLdap], username: str):
        &#34;&#34;&#34;
        Vérifie si une liste d&#39;utilisateurs ldap contient un utilisateur via son username
        :param ldap_users:
        :param username:
        :return:
        &#34;&#34;&#34;
        for ldap_user in ldap_users:
            if ldap_user.uid.lower() == username.lower():
                return True
        return False

    def backup_course(self, courseid, log=getLogger()):
        &#34;&#34;&#34;
        Permet de lancer le backup un cours et de vérifier qu&#39;il s&#39;est bien passé
        :param courseid: L&#39;id du cours à backup
        :return: Un booléen a True si le backup s&#39;est bien passé, False sinon
        &#34;&#34;&#34;
        log.info(&#34;Backup du cours avec l&#39;id %d&#34;, courseid)
        cmd = self.__config.webservice.backup_cmd.replace(&#34;%courseid%&#34;, str(courseid))
        backup_process = os.popen(cmd)
        output = backup_process.read()
        m = re.search(self.__config.webservice.backup_success_re, output)
        return m is not None

    def check_and_process_user_courses(self, user_id: int, log=getLogger()):
        &#34;&#34;&#34;
        Effectue les traitements nécéssaires sur tous les cours d&#39;un l&#39;enseignant
        :param user_id: L&#39;enseignant dont on doit traiter les cours
        &#34;&#34;&#34;
        #Liste stockant tous les cours à supprimer
        course_ids_to_delete = []
        #Récupère tous les cours de l&#39;utilisateur
        user_courses_ids = [user_course[0] for user_course in self.__db.get_courses_ids_owned_or_teach(user_id)]
        #Date actuelle
        now = self.__db.get_timestamp_now()

        #Pour chaque cours de l&#39;utilisateur
        for courseid in user_courses_ids:
            log.info(&#34;Traitement du cours %d&#34;, courseid)
            #On récupère tous les Propriétaire de cours de ce cours
            owners_ids = [ownerid[0] for ownerid in self.__db.get_userids_owner_of_course(courseid)]
            #Si il est tout seul à posséder ce cours
            if len(owners_ids) == 1 and owners_ids[0] == user_id:
                #Récupération de la date de dernière modification
                timemodified = self.__db.get_course_timemodified(courseid)
                #Récupération du délai avant suppression du cours
                delay_backup_course = self.__config.delete.delay_backup_course

                #Test pour voir si le cours doit être supprimé
                if timemodified &lt; now - (delay_backup_course * SECONDS_PER_DAY):
                    log.info(&#34;Le cours %d n&#39;a pas été modifié depuis plus de %d jours, et l&#39;utilisateur %d est le seul&#34;
                    &#34; propriétaire de ce cours, il va donc être supprimé&#34;, courseid, user_id, delay_backup_course)
                    #Backup d&#39;abord
                    backup_success = self.backup_course(courseid, log)
                    if backup_success:
                        log.info(&#34;La backup du cours %d été sauvegardée&#34;, courseid)
                        course_ids_to_delete.append(courseid)
                    else:
                        log.error(&#34;Le backup du cours %d a échouée&#34;, courseid)

            #Sinon s&#39;il n&#39;est pas tout seul à posséder ce cours, on lui retire son rôle
            #Autrement dit on le désinscrit du cours
            else:
                log.info(&#34;L&#39;utilisateur %d n&#39;est pas le seul enseignant du cours %d, il va donc être désinscrit&#34;, user_id, courseid)
                self.__webservice.unenrol_user_from_course(user_id, courseid)

        #Suppression des cours
        if course_ids_to_delete:
            self.delete_courses(course_ids_to_delete)

    def anonymize_or_delete_users(self, ldap_users: List[PersonneLdap], db_users: List, log=getLogger()):
        &#34;&#34;&#34;
        Anonymise ou Supprime les utilisateurs devenus inutiles
        :param ldap_users: La liste de toutes les personnes du ldap
        :param db_users: La liste de toutes les personnes dans moodle
        :param log:
        :return:
        &#34;&#34;&#34;
        user_ids_to_delete = [] #Utilisateurs à supprimer
        user_ids_to_anonymize = [] #Utilisateurs à anonymiser
        user_ids_to_process_courses = [] #Enseignants dont les cours doivent subir un traitement
        now = self.__db.get_timestamp_now()
        is_teacher = False

        #Pour chaque utilisateur en BD
        for db_user in db_users:

            #Si jamais c&#39;est un utilisateur à ne pas supprimer
            if db_user[0] in self.__config.delete.ids_users_undeletable:
                continue

            #Si l&#39;utilisateur n&#39;est plus présent dans l&#39;annuaire LDAP, alors il faut faire un traitement
            if not self.list_contains_username(ldap_users, db_user[1]):
                log.info(&#34;L&#39;utilisateur %s n&#39;est plus présent dans l&#39;annuaire LDAP&#34;, db_user[1])
                #log.info(&#34;L&#39;utilisateur %s n&#39;a pas utilisé moodle depuis %f jours&#34;, db_user[1], (now - db_user[2])/SECONDS_PER_DAY)
                #Dans tous les cas, si jamais il n&#39;a jamais utilisé moodle alors on peut le supprimer
                if not self.__db.user_has_used_moodle(db_user[0]):
                    log.info(&#34;L&#39;utilisateur %s n&#39;a jamais utilisé moodle. Il va être supprimé&#34;, db_user[1])
                    user_ids_to_delete.append(db_user[0])

                #Traitement pour les utilisateurs ayant déjà utilisé moodle
                else:
                    #Booléen pour savoir si l&#39;utilisateur qu&#39;on traite est un enseignant ou non
                    is_teacher = self.__db.user_has_role(db_user[0], self.__config.delete.ids_roles_teachers)

                    #Récupération des délais avant anonymisation et avant suppression
                    delete_delay = self.__config.delete.delay_delete_teacher if is_teacher else \
                        self.__config.delete.delay_delete_student
                    anon_delay = self.__config.delete.delay_anonymize_teacher if is_teacher else \
                        self.__config.delete.delay_anonymize_student

                    #Récupération de la liste des cours de l&#39;utilisateur
                    user_courses = self.__webservice.get_courses_user_enrolled(db_user[0])

                    #Si c&#39;est un enseignant il ne faut pas tenir compte des cours ou il est propriétaire/enseignant
                    if is_teacher:
                        owned_courses = self.__db.get_courses_ids_owned_or_teach(db_user[0])
                        for course_owned in owned_courses:
                            if course_owned in user_courses:
                                user_courses.remove(course_owned)

                    #Cas ou on doit supprimer un élève : plus présent dans le ldap, et
                    #pas de connexion a moodle depuis plus de delay_force_delete jours
                    if not is_teacher:
                        if db_user[2] &lt; now - (self.__config.delete.delay_force_delete * SECONDS_PER_DAY):
                            log.info(&#34;L&#39;élève %s ne s&#39;est pas connecté depuis au moins %s jours. Il va être supprimé&#34;, db_user[1], self.__config.delete.delay_force_delete)
                            user_ids_to_delete.append(db_user[0])

                    #Suite du traitement si on ne sait pas encore si on doit supprimer l&#39;utilisateur
                    if db_user[0] not in user_ids_to_delete:

                        #Cas ou on doit supprimer un utilisateur : plus présent dans le ldap
                        #et pas de connection à moodle depuis plus de delete_delay jours
                        if db_user[2] &lt; now - (delete_delay * SECONDS_PER_DAY):
                            if len(user_courses) == 0: #inscription à aucun cours
                                #Différence de traitement au niveau des références entre un enseignant et un élève
                                if is_teacher:
                                    if not self.__db.enseignant_has_references(db_user[0]): #si pas de références
                                        log.info(&#34;L&#39;élève %s ne s&#39;est pas connecté depuis au moins %s jours et n&#39;est pas inscrit à un cours,&#34;
                                        &#34; ni ne possède de référénces. Il va être supprimé&#34;, db_user[1], delete_delay)
                                        user_ids_to_delete.append(db_user[0])
                                else:
                                    if not self.__db.eleve_has_references(db_user[0]): #si pas de références
                                        log.info(&#34;L&#39;enseignant %s ne s&#39;est pas connecté depuis au moins %s jours et n&#39;est pas inscrit à un cours,&#34;
                                        &#34; ni ne possède de référénces. Il va être supprimé&#34;, db_user[1], delete_delay)
                                        user_ids_to_delete.append(db_user[0])

                        if db_user[0] not in user_ids_to_delete:
                            #Cas ou on doit anonymiser un utilisateur : plus présent dans le ldap,
                            #pas inscrit dans un seul cours avec le rôle propriétaire ou enseignant,
                            #et pas de connection à moodle depuis plus de anon_delay jours
                            if db_user[2] &lt; now - (anon_delay * SECONDS_PER_DAY): #délai de connexion
                                #Différence de traitement au niveau des références entre un enseignant et un élève
                                if is_teacher:
                                    #On vérifie que l&#39;enseignant n&#39;est pas inscrit dans un seul cours avec le rôle propriétaire ou enseignant
                                    if len(self.__db.get_courses_ids_owned_or_teach(db_user[0])) == 0:
                                        #S&#39;il doit être anonymisé, on vérifie qu&#39;il ne l&#39;est pas déjà
                                        if self.__db.get_user_data(db_user[0])[10] != self.__config.constantes.anonymous_name:
                                            log.info(&#34;L&#39;enseignant %s ne s&#39;est pas connecté depuis au moins %s jours et est inscrit à des cours ou possèdes des références.&#34;
                                            &#34; Il va être anonymisé&#34;, db_user[1], anon_delay)
                                            user_ids_to_anonymize.append(db_user[0])
                                        else:
                                            log.info(&#34;L&#39;enseignant %s doit être anonymisé, mais il est déja anonymisé&#34;, db_user[1])
                                else:
                                    #Même principe pour les élèves
                                    if self.__db.get_user_data(db_user[0])[10] != self.__config.constantes.anonymous_name:
                                        log.info(&#34;L&#39;élève %s ne s&#39;est pas connecté depuis au moins %s jours et est inscrit à des cours ou possèdes des références.&#34;
                                        &#34; Il va être anonymisé&#34;, db_user[1], anon_delay)
                                        user_ids_to_anonymize.append(db_user[0])
                                    else:
                                        log.info(&#34;L&#39;élève %s doit être anonymisé, mais il est déja anonymisé&#34;, db_user[1])

                            #Cas ou on doit effectuer un traitement sur les cours d&#39;un prof : plus présent dans le ldap,
                            #inscrit avec le role propriétaire de cours ou enseignant dans au moins 1 cours,
                            #et pas de connection à moodle depuis plus de delay_backup_course jours
                            if is_teacher and (db_user[2] &lt; now - (self.__config.delete.delay_backup_course * SECONDS_PER_DAY)):
                                owned_or_teach_courses = [user_course[0] for user_course in self.__db.get_courses_ids_owned_or_teach(db_user[0])]
                                if len(owned_or_teach_courses) &gt; 0:
                                    log.info(&#34;L&#39;enseignant %s ne s&#39;est pas connecté depuis au moins %s jours. Un traitement&#34;
                                             &#34; va être effectué sur ses cours&#34;, db_user[1], self.__config.delete.delay_backup_course)
                                    user_ids_to_process_courses.append(db_user[0])

        #Traitement sur les cours des enseignants
        for user_id in user_ids_to_process_courses:
            log.info(&#34;Traitement des cours de l&#39;enseignant %s&#34;, user_id)
            self.check_and_process_user_courses(user_id, log=log)

        #Pour chaque utilisateur à supprimer
        if user_ids_to_delete:
            log.info(&#34;Suppression des utilisateurs en cours...&#34;)
            self.delete_users(user_ids_to_delete, log=log)
            log.info(&#34;%d utilisateurs supprimés&#34;, len(user_ids_to_delete))

        #De même pour user_ids_to_anonymize
        if user_ids_to_anonymize:
            log.info(&#34;Anonymisation des utilisateurs en cours...&#34;)
            self.__db.anonymize_users(user_ids_to_anonymize)
            log.info(&#34;%d utilisateurs anonymisés&#34;, len(user_ids_to_anonymize))


    def delete_empty_cohorts(self):
        &#34;&#34;&#34;
        Supprime les cohortes vides
        &#34;&#34;&#34;
        #Récupère les ids des cohortes
        empty_cohorts_ids = self.__db.get_empty_cohorts()
        if len(empty_cohorts_ids) &gt; 0:
            #Fait appel au webservice moodle pour suppression
            self.__webservice.delete_cohorts(empty_cohorts_ids)

    def delete_users(self, userids: List[int], log=getLogger()) -&gt; int:
        &#34;&#34;&#34;
        Supprime les utilisateurs d&#39;une liste en paginant les appels au webservice
        :param userids: La liste des id des utilisateurs à supprimer
        :param pagesize:  Le nombre d&#39;utilisateurs supprimés en un seul appel au webservice
        :param log:
        :return:
        &#34;&#34;&#34;
        pagesize = self.__config.webservice.user_delete_pagesize
        i = 0
        total = len(userids)
        userids_page = []
        for userid in userids:
            userids_page.append(userid)
            i += 1
            if i % pagesize == 0:
                self.__webservice.delete_users(userids_page)
                userids_page = []
                log.info(&#34;%d / %d utilisateurs supprimés&#34;, i, total)
        if i % pagesize &gt; 0:
            self.__webservice.delete_users(userids_page)
            log.info(&#34;%d / %d utilisateurs supprimés&#34;, i, total)
        return i


    def delete_courses(self, courseids: List[int], log=getLogger()) -&gt; int:
        &#34;&#34;&#34;
        Supprime les cours d&#39;une liste en paginant les appels au webservice
        :param courseids: La liste des id de cours à supprimer
        :param pagesize: Le nombre de cours supprimés en un seul appel au webservice
        :param log:
        :return:
        &#34;&#34;&#34;
        pagesize = self.__config.webservice.course_delete_pagesize
        i = 0
        total = len(courseids)
        courseids_page = []
        for courseid in courseids:
            courseids_page.append(courseid)
            i += 1
            if i % pagesize == 0:
                self.__webservice.delete_courses(courseids_page)
                courseids_page = []
                log.info(&#34;%d / %d cours supprimés&#34;, i, total)
        if i % pagesize &gt; 0:
            self.__webservice.delete_courses(courseids_page)
            log.info(&#34;%d / %d cours supprimés&#34;, i, total)
        return i


    def purge_cohorts(self, users_by_cohorts_db: Dict[str, List[str]],
                      users_by_cohorts_ldap: Dict[str, List[str]],
                      cohortname_pattern: str,
                      log=getLogger()):
        &#34;&#34;&#34;
        Vide les cohortes d&#39;utilisateurs conformément à l&#39;annuaire LDAP
        :param users_by_cohorts_db:
        :param users_by_cohorts_ldap:
        :param cohortname_pattern:
        :param log:
        :return:
        &#34;&#34;&#34;
        disenrolled_users = {}
        # On boucle avec à chaque fois une cohorte et son tableau d&#39;élèves de la bdd
        for cohort_db, eleves_db in users_by_cohorts_db.items():
            # Calcul du nom complet de la cohorte
            cohortname = cohortname_pattern % cohort_db
            # Si la cohorte n&#39;est pas présente dans le ldap (ce qui ne doit pas être possible, au pire on a un tableau vide)
            #  On désenrole les users de la cohortes côté bdd
            if cohort_db not in users_by_cohorts_ldap.keys():
                for username_db in users_by_cohorts_db[cohort_db]:
                    log.info(&#34;Désenrollement de l&#39;utilisateur %s de la cohorte \&#34;%s\&#34;&#34;, username_db, cohort_db)
                    self.__db.disenroll_user_from_username_and_cohortname(username_db, cohortname)
                    if cohort_db not in disenrolled_users.keys():
                        disenrolled_users[cohort_db] = []
                    disenrolled_users[cohort_db].append(username_db)
            # Sinon, on test pour chaque user si il est présent, et si il est absent on le désenrole
            else:
                for username_db in eleves_db:
                    if username_db not in users_by_cohorts_ldap[cohort_db]:
                        log.info(&#34;Désenrollement de l&#39;utilisateur %s de la cohorte \&#34;%s\&#34;&#34;, username_db, cohort_db)
                        self.__db.disenroll_user_from_username_and_cohortname(username_db, cohortname)
                        if cohort_db not in disenrolled_users.keys():
                            disenrolled_users[cohort_db] = []
                        disenrolled_users[cohort_db].append(username_db)

        # On retourne un dictionnaire des utilisateurs désenrolé par cohortes
        return disenrolled_users

    def purge_cohort_dane_elv_lycee_en(self, elv_lycee_en_ldap: list) -&gt; list:

        #Si on a des établissements dane
        if self.ids_cohorts_dane_lycee_en != {}:

            # Récupération des username des utilisateurs de la cohorte en db
            elv_lycee_en_db = self.__db.get_cohort_members(self.ids_cohorts_dane_lycee_en[UserType.ELEVE])
            # Liste des users désenrollé
            disenrolled_users = []

            # Boucle sur chaques user en db et le désenrole si il n&#39;est pas rpésent dans le ldap
            for username_db in elv_lycee_en_db:
                if username_db not in elv_lycee_en_ldap:
                    log.info(&#34;Désenrollement de l&#39;utilisateur %s de la cohorte dane elv_lycee_en&#34;, username_db)
                    self.__db.disenroll_user_from_username_and_cohortid(username_db, sself.ids_cohorts_dane_lycee_en[UserType.ELEVE])
                    disenrolled_users.append(username_db)

            # On retourne un dictionnaire des utilisateurs désenrolé par cohortes
            return disenrolled_users

    def mise_a_jour_cohorte_interetab(self, is_member_of, cohort_name, since_timestamp: datetime.datetime,
                                      log=getLogger()):
        &#34;&#34;&#34;
        Met à jour la cohorte inter-etablissement.
        :param is_member_of:
        :param cohort_name:
        :param since_timestamp:
        :param log:
        :return:
        &#34;&#34;&#34;
        # Creation de la cohort si necessaire
        self.get_or_create_cohort(self.context.id_context_categorie_inter_etabs, cohort_name, cohort_name,
                                  cohort_name, self.context.timestamp_now_sql, log=log)
        id_cohort = self.__db.get_id_cohort(self.context.id_context_categorie_inter_etabs, cohort_name)

        # Liste permettant de sauvegarder les utilisateurs de la cohorte
        self.context.utilisateurs_by_cohortes[id_cohort] = []

        # Recuperation des utilisateurs
        is_member_of_list = [is_member_of]

        # Ajout des utilisateurs dans la cohorte
        for personne_ldap in self.__ldap.search_personne(
                since_timestamp = since_timestamp,
                isMemberOf = is_member_of_list):
            user_id = self.__db.get_user_id(personne_ldap.uid)
            if user_id:
                self.__db.enroll_user_in_cohort(id_cohort, user_id, self.context.timestamp_now_sql)
                # Mise a jour des utilisateurs de la cohorte
                self.context.utilisateurs_by_cohortes[id_cohort].append(user_id)
            else:
                log.warning(&#34;Impossible d&#39;inserer l&#39;utilisateur %s dans la cohorte %s, &#34;
                            &#34;car il n&#39;est pas connu dans Moodle&#34;, personne_ldap, cohort_name)

    def insert_moodle_structure(self, grp, nom_structure, path, ou, siren, uai):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer une structure dans Moodle.
        :param grp:
        :param nom_structure:
        :param path:
        :param ou:
        :param siren:
        :param uai:
        :return:
        &#34;&#34;&#34;
        # Recuperation du timestamp
        now = self.__db.get_timestamp_now()

        # Creation de la description pour la structure
        description = siren
        if grp:
            description = siren + &#34;@&#34; + nom_structure

        #########################
        # PARTIE CATEGORIE
        #########################
        # Insertion de la categorie correspondant a l&#39;etablissement
        self.__db.insert_moodle_course_category(ou, description, description, uai)
        id_categorie_etablissement = self.__db.get_id_course_category_by_id_number(siren)

        # Mise a jour du path de la categorie
        path_etablissement = &#34;/%d&#34; % id_categorie_etablissement
        self.__db.update_course_category_path(id_categorie_etablissement, path_etablissement)

        #########################
        # PARTIE CONTEXTE
        #########################
        # Insertion du contexte associe a la categorie de l&#39;etablissement
        self.__db.insert_moodle_context(self.__config.constantes.niveau_ctx_categorie,
                                        PROFONDEUR_CTX_ETAB,
                                        id_categorie_etablissement)
        id_contexte_etablissement = self.__db.get_id_context(self.__config.constantes.niveau_ctx_categorie,
                                                             PROFONDEUR_CTX_ETAB,
                                                             id_categorie_etablissement)

        # Mise a jour du path de la categorie
        path_contexte_etablissement = &#34;%s/%d&#34; % (path, id_contexte_etablissement)
        self.__db.update_context_path(id_contexte_etablissement, path_contexte_etablissement)

        #########################
        # PARTIE ZONE PRIVEE
        #########################
        # Insertion du cours pour le forum de discussion
        id_zone_privee = self.__db.insert_zone_privee(id_categorie_etablissement, siren, ou, now)

        # Insertion du contexte associe
        id_contexte_zone_privee = self.__db.insert_zone_privee_context(id_zone_privee)

        # Mise a jour du path du contexte
        path_contexte_zone_privee = &#34;%s/%d&#34; % (path_contexte_etablissement, id_contexte_zone_privee)
        self.__db.update_context_path(id_contexte_zone_privee, path_contexte_zone_privee)

        #########################
        # PARTIE INSCRIPTIONS
        #########################
        # Ouverture du cours a l&#39;inscription manuelle
        role_id = self.__config.constantes.id_role_eleve
        self.__db.insert_moodle_enrol_capability(&#34;manual&#34;, 0, id_zone_privee, role_id)

        #########################
        # PARTIE FORUM
        #########################
        # Insertion du forum au sein de la zone privee
        course = id_zone_privee
        name = FORUM_NAME_ZONE_PRIVEE % ou
        intro = FORUM_INTRO_ZONE_PRIVEE
        intro_format = FORUM_INTRO_FORMAT_ZONE_PRIVEE
        max_bytes = FORUM_MAX_BYTES_ZONE_PRIVEE
        max_attachements = FORUM_MAX_ATTACHEMENTS_ZONE_PRIVEE
        time_modified = now

        id_forum = self.__db.get_id_forum(course)
        if id_forum is None:
            self.__db.insert_moodle_forum(course, name, intro, intro_format, max_bytes, max_attachements, time_modified)
            id_forum = self.__db.get_id_forum(course)

        #########################
        # PARTIE MODULE
        #########################
        # Insertion du module forum dans la zone privee
        course = id_zone_privee
        module = COURSE_MODULES_MODULE
        instance = id_forum
        added = now
        id_course_module = self.__db.get_id_course_module(course)
        if id_course_module is None:
            self.__db.insert_moodle_course_module(course, module, instance, added)
            id_course_module = self.__db.get_id_course_module(course)

        # Insertion du contexte pour le module de cours (forum)
        id_contexte_module = self.__db.get_id_context(self.__config.constantes.niveau_ctx_forum,
                                                      PROFONDEUR_CTX_MODULE_ZONE_PRIVEE,
                                                      id_course_module)
        if id_contexte_module is None:
            self.__db.insert_moodle_context(self.__config.constantes.niveau_ctx_forum,
                                            PROFONDEUR_CTX_MODULE_ZONE_PRIVEE,
                                            id_course_module)
            id_contexte_module = self.__db.get_id_context(self.__config.constantes.niveau_ctx_forum,
                                                          PROFONDEUR_CTX_MODULE_ZONE_PRIVEE,
                                                          id_course_module)

        # Mise a jour du path du contexte
        path_contexte_module = &#34;%s/%d&#34; % (path_contexte_zone_privee, id_contexte_module)
        self.__db.update_context_path(id_contexte_module, path_contexte_module)

        #########################
        # PARTIE BLOC
        #########################
        # Insertion du bloc de recherche forum
        parent_context_id = id_contexte_zone_privee
        block_name = BLOCK_FORUM_SEARCH_NAME
        show_in_subcontexts = BLOCK_FORUM_SEARCH_SHOW_IN_SUB_CTX
        page_type_pattern = BLOCK_FORUM_SEARCH_PAGE_TYPE_PATTERN
        sub_page_pattern = BLOCK_FORUM_SEARCH_SUB_PAGE_PATTERN
        default_region = BLOCK_FORUM_SEARCH_DEFAULT_REGION
        default_weight = BLOCK_FORUM_SEARCH_DEFAULT_WEIGHT

        id_block = self.__db.get_id_block(parent_context_id)
        if id_block is None:
            self.__db.insert_moodle_block(block_name, parent_context_id, show_in_subcontexts, page_type_pattern,
                                          sub_page_pattern, default_region, default_weight)
            id_block = self.__db.get_id_block(parent_context_id)

        # Insertion du contexte pour le bloc
        id_contexte_bloc = self.__db.get_id_context(self.__config.constantes.niveau_ctx_bloc,
                                                    PROFONDEUR_CTX_BLOCK_ZONE_PRIVEE,
                                                    id_block)
        if id_contexte_bloc is None:
            self.__db.insert_moodle_context(self.__config.constantes.niveau_ctx_bloc,
                                            PROFONDEUR_CTX_BLOCK_ZONE_PRIVEE,
                                            id_block)
            id_contexte_bloc = self.__db.get_id_context(self.__config.constantes.niveau_ctx_bloc,
                                                        PROFONDEUR_CTX_BLOCK_ZONE_PRIVEE,
                                                        id_block)

        # Mise a jour du path du contexte
        path_contexte_bloc = &#34;%s/%d&#34; % (path_contexte_zone_privee, id_contexte_bloc)
        self.__db.update_context_path(id_contexte_bloc, path_contexte_bloc)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="synchromoodle.synchronizer.Synchronizer.anonymize_or_delete_users"><code class="name flex">
<span>def <span class="ident">anonymize_or_delete_users</span></span>(<span>self, ldap_users: List[<a title="synchromoodle.ldaputils.PersonneLdap" href="ldaputils.html#synchromoodle.ldaputils.PersonneLdap">PersonneLdap</a>], db_users: List, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Anonymise ou Supprime les utilisateurs devenus inutiles
:param ldap_users: La liste de toutes les personnes du ldap
:param db_users: La liste de toutes les personnes dans moodle
:param log:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def anonymize_or_delete_users(self, ldap_users: List[PersonneLdap], db_users: List, log=getLogger()):
    &#34;&#34;&#34;
    Anonymise ou Supprime les utilisateurs devenus inutiles
    :param ldap_users: La liste de toutes les personnes du ldap
    :param db_users: La liste de toutes les personnes dans moodle
    :param log:
    :return:
    &#34;&#34;&#34;
    user_ids_to_delete = [] #Utilisateurs à supprimer
    user_ids_to_anonymize = [] #Utilisateurs à anonymiser
    user_ids_to_process_courses = [] #Enseignants dont les cours doivent subir un traitement
    now = self.__db.get_timestamp_now()
    is_teacher = False

    #Pour chaque utilisateur en BD
    for db_user in db_users:

        #Si jamais c&#39;est un utilisateur à ne pas supprimer
        if db_user[0] in self.__config.delete.ids_users_undeletable:
            continue

        #Si l&#39;utilisateur n&#39;est plus présent dans l&#39;annuaire LDAP, alors il faut faire un traitement
        if not self.list_contains_username(ldap_users, db_user[1]):
            log.info(&#34;L&#39;utilisateur %s n&#39;est plus présent dans l&#39;annuaire LDAP&#34;, db_user[1])
            #log.info(&#34;L&#39;utilisateur %s n&#39;a pas utilisé moodle depuis %f jours&#34;, db_user[1], (now - db_user[2])/SECONDS_PER_DAY)
            #Dans tous les cas, si jamais il n&#39;a jamais utilisé moodle alors on peut le supprimer
            if not self.__db.user_has_used_moodle(db_user[0]):
                log.info(&#34;L&#39;utilisateur %s n&#39;a jamais utilisé moodle. Il va être supprimé&#34;, db_user[1])
                user_ids_to_delete.append(db_user[0])

            #Traitement pour les utilisateurs ayant déjà utilisé moodle
            else:
                #Booléen pour savoir si l&#39;utilisateur qu&#39;on traite est un enseignant ou non
                is_teacher = self.__db.user_has_role(db_user[0], self.__config.delete.ids_roles_teachers)

                #Récupération des délais avant anonymisation et avant suppression
                delete_delay = self.__config.delete.delay_delete_teacher if is_teacher else \
                    self.__config.delete.delay_delete_student
                anon_delay = self.__config.delete.delay_anonymize_teacher if is_teacher else \
                    self.__config.delete.delay_anonymize_student

                #Récupération de la liste des cours de l&#39;utilisateur
                user_courses = self.__webservice.get_courses_user_enrolled(db_user[0])

                #Si c&#39;est un enseignant il ne faut pas tenir compte des cours ou il est propriétaire/enseignant
                if is_teacher:
                    owned_courses = self.__db.get_courses_ids_owned_or_teach(db_user[0])
                    for course_owned in owned_courses:
                        if course_owned in user_courses:
                            user_courses.remove(course_owned)

                #Cas ou on doit supprimer un élève : plus présent dans le ldap, et
                #pas de connexion a moodle depuis plus de delay_force_delete jours
                if not is_teacher:
                    if db_user[2] &lt; now - (self.__config.delete.delay_force_delete * SECONDS_PER_DAY):
                        log.info(&#34;L&#39;élève %s ne s&#39;est pas connecté depuis au moins %s jours. Il va être supprimé&#34;, db_user[1], self.__config.delete.delay_force_delete)
                        user_ids_to_delete.append(db_user[0])

                #Suite du traitement si on ne sait pas encore si on doit supprimer l&#39;utilisateur
                if db_user[0] not in user_ids_to_delete:

                    #Cas ou on doit supprimer un utilisateur : plus présent dans le ldap
                    #et pas de connection à moodle depuis plus de delete_delay jours
                    if db_user[2] &lt; now - (delete_delay * SECONDS_PER_DAY):
                        if len(user_courses) == 0: #inscription à aucun cours
                            #Différence de traitement au niveau des références entre un enseignant et un élève
                            if is_teacher:
                                if not self.__db.enseignant_has_references(db_user[0]): #si pas de références
                                    log.info(&#34;L&#39;élève %s ne s&#39;est pas connecté depuis au moins %s jours et n&#39;est pas inscrit à un cours,&#34;
                                    &#34; ni ne possède de référénces. Il va être supprimé&#34;, db_user[1], delete_delay)
                                    user_ids_to_delete.append(db_user[0])
                            else:
                                if not self.__db.eleve_has_references(db_user[0]): #si pas de références
                                    log.info(&#34;L&#39;enseignant %s ne s&#39;est pas connecté depuis au moins %s jours et n&#39;est pas inscrit à un cours,&#34;
                                    &#34; ni ne possède de référénces. Il va être supprimé&#34;, db_user[1], delete_delay)
                                    user_ids_to_delete.append(db_user[0])

                    if db_user[0] not in user_ids_to_delete:
                        #Cas ou on doit anonymiser un utilisateur : plus présent dans le ldap,
                        #pas inscrit dans un seul cours avec le rôle propriétaire ou enseignant,
                        #et pas de connection à moodle depuis plus de anon_delay jours
                        if db_user[2] &lt; now - (anon_delay * SECONDS_PER_DAY): #délai de connexion
                            #Différence de traitement au niveau des références entre un enseignant et un élève
                            if is_teacher:
                                #On vérifie que l&#39;enseignant n&#39;est pas inscrit dans un seul cours avec le rôle propriétaire ou enseignant
                                if len(self.__db.get_courses_ids_owned_or_teach(db_user[0])) == 0:
                                    #S&#39;il doit être anonymisé, on vérifie qu&#39;il ne l&#39;est pas déjà
                                    if self.__db.get_user_data(db_user[0])[10] != self.__config.constantes.anonymous_name:
                                        log.info(&#34;L&#39;enseignant %s ne s&#39;est pas connecté depuis au moins %s jours et est inscrit à des cours ou possèdes des références.&#34;
                                        &#34; Il va être anonymisé&#34;, db_user[1], anon_delay)
                                        user_ids_to_anonymize.append(db_user[0])
                                    else:
                                        log.info(&#34;L&#39;enseignant %s doit être anonymisé, mais il est déja anonymisé&#34;, db_user[1])
                            else:
                                #Même principe pour les élèves
                                if self.__db.get_user_data(db_user[0])[10] != self.__config.constantes.anonymous_name:
                                    log.info(&#34;L&#39;élève %s ne s&#39;est pas connecté depuis au moins %s jours et est inscrit à des cours ou possèdes des références.&#34;
                                    &#34; Il va être anonymisé&#34;, db_user[1], anon_delay)
                                    user_ids_to_anonymize.append(db_user[0])
                                else:
                                    log.info(&#34;L&#39;élève %s doit être anonymisé, mais il est déja anonymisé&#34;, db_user[1])

                        #Cas ou on doit effectuer un traitement sur les cours d&#39;un prof : plus présent dans le ldap,
                        #inscrit avec le role propriétaire de cours ou enseignant dans au moins 1 cours,
                        #et pas de connection à moodle depuis plus de delay_backup_course jours
                        if is_teacher and (db_user[2] &lt; now - (self.__config.delete.delay_backup_course * SECONDS_PER_DAY)):
                            owned_or_teach_courses = [user_course[0] for user_course in self.__db.get_courses_ids_owned_or_teach(db_user[0])]
                            if len(owned_or_teach_courses) &gt; 0:
                                log.info(&#34;L&#39;enseignant %s ne s&#39;est pas connecté depuis au moins %s jours. Un traitement&#34;
                                         &#34; va être effectué sur ses cours&#34;, db_user[1], self.__config.delete.delay_backup_course)
                                user_ids_to_process_courses.append(db_user[0])

    #Traitement sur les cours des enseignants
    for user_id in user_ids_to_process_courses:
        log.info(&#34;Traitement des cours de l&#39;enseignant %s&#34;, user_id)
        self.check_and_process_user_courses(user_id, log=log)

    #Pour chaque utilisateur à supprimer
    if user_ids_to_delete:
        log.info(&#34;Suppression des utilisateurs en cours...&#34;)
        self.delete_users(user_ids_to_delete, log=log)
        log.info(&#34;%d utilisateurs supprimés&#34;, len(user_ids_to_delete))

    #De même pour user_ids_to_anonymize
    if user_ids_to_anonymize:
        log.info(&#34;Anonymisation des utilisateurs en cours...&#34;)
        self.__db.anonymize_users(user_ids_to_anonymize)
        log.info(&#34;%d utilisateurs anonymisés&#34;, len(user_ids_to_anonymize))</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.backup_course"><code class="name flex">
<span>def <span class="ident">backup_course</span></span>(<span>self, courseid, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Permet de lancer le backup un cours et de vérifier qu'il s'est bien passé
:param courseid: L'id du cours à backup
:return: Un booléen a True si le backup s'est bien passé, False sinon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backup_course(self, courseid, log=getLogger()):
    &#34;&#34;&#34;
    Permet de lancer le backup un cours et de vérifier qu&#39;il s&#39;est bien passé
    :param courseid: L&#39;id du cours à backup
    :return: Un booléen a True si le backup s&#39;est bien passé, False sinon
    &#34;&#34;&#34;
    log.info(&#34;Backup du cours avec l&#39;id %d&#34;, courseid)
    cmd = self.__config.webservice.backup_cmd.replace(&#34;%courseid%&#34;, str(courseid))
    backup_process = os.popen(cmd)
    output = backup_process.read()
    m = re.search(self.__config.webservice.backup_success_re, output)
    return m is not None</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.check_and_process_user_courses"><code class="name flex">
<span>def <span class="ident">check_and_process_user_courses</span></span>(<span>self, user_id: int, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Effectue les traitements nécéssaires sur tous les cours d'un l'enseignant
:param user_id: L'enseignant dont on doit traiter les cours</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_and_process_user_courses(self, user_id: int, log=getLogger()):
    &#34;&#34;&#34;
    Effectue les traitements nécéssaires sur tous les cours d&#39;un l&#39;enseignant
    :param user_id: L&#39;enseignant dont on doit traiter les cours
    &#34;&#34;&#34;
    #Liste stockant tous les cours à supprimer
    course_ids_to_delete = []
    #Récupère tous les cours de l&#39;utilisateur
    user_courses_ids = [user_course[0] for user_course in self.__db.get_courses_ids_owned_or_teach(user_id)]
    #Date actuelle
    now = self.__db.get_timestamp_now()

    #Pour chaque cours de l&#39;utilisateur
    for courseid in user_courses_ids:
        log.info(&#34;Traitement du cours %d&#34;, courseid)
        #On récupère tous les Propriétaire de cours de ce cours
        owners_ids = [ownerid[0] for ownerid in self.__db.get_userids_owner_of_course(courseid)]
        #Si il est tout seul à posséder ce cours
        if len(owners_ids) == 1 and owners_ids[0] == user_id:
            #Récupération de la date de dernière modification
            timemodified = self.__db.get_course_timemodified(courseid)
            #Récupération du délai avant suppression du cours
            delay_backup_course = self.__config.delete.delay_backup_course

            #Test pour voir si le cours doit être supprimé
            if timemodified &lt; now - (delay_backup_course * SECONDS_PER_DAY):
                log.info(&#34;Le cours %d n&#39;a pas été modifié depuis plus de %d jours, et l&#39;utilisateur %d est le seul&#34;
                &#34; propriétaire de ce cours, il va donc être supprimé&#34;, courseid, user_id, delay_backup_course)
                #Backup d&#39;abord
                backup_success = self.backup_course(courseid, log)
                if backup_success:
                    log.info(&#34;La backup du cours %d été sauvegardée&#34;, courseid)
                    course_ids_to_delete.append(courseid)
                else:
                    log.error(&#34;Le backup du cours %d a échouée&#34;, courseid)

        #Sinon s&#39;il n&#39;est pas tout seul à posséder ce cours, on lui retire son rôle
        #Autrement dit on le désinscrit du cours
        else:
            log.info(&#34;L&#39;utilisateur %d n&#39;est pas le seul enseignant du cours %d, il va donc être désinscrit&#34;, user_id, courseid)
            self.__webservice.unenrol_user_from_course(user_id, courseid)

    #Suppression des cours
    if course_ids_to_delete:
        self.delete_courses(course_ids_to_delete)</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.construct_classe_to_niv_formation"><code class="name flex">
<span>def <span class="ident">construct_classe_to_niv_formation</span></span>(<span>self, etablissement_context: <a title="synchromoodle.synchronizer.EtablissementContext" href="#synchromoodle.synchronizer.EtablissementContext">EtablissementContext</a>, list_eleve_ldap: list[<a title="synchromoodle.ldaputils.EleveLdap" href="ldaputils.html#synchromoodle.ldaputils.EleveLdap">EleveLdap</a>], log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Associe au contexte de l'établissement un dictionnaire associant une classe à
un niveau de formation. Utilisé pour pouvoir récupérer le niveau de formation
d'un enseignant comme il n'est pas présent directement dans le ldap</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_classe_to_niv_formation(self, etablissement_context: EtablissementContext, list_eleve_ldap: list[EleveLdap], log=getLogger()):
    &#34;&#34;&#34;
    Associe au contexte de l&#39;établissement un dictionnaire associant une classe à
    un niveau de formation. Utilisé pour pouvoir récupérer le niveau de formation
    d&#39;un enseignant comme il n&#39;est pas présent directement dans le ldap
    &#34;&#34;&#34;
    for eleve_ldap in list_eleve_ldap:
        eleve_classes_for_etab = []
        for classe in eleve_ldap.classes:
            if classe.etab_dn == etablissement_context.structure_ldap.dn:
                eleve_classes_for_etab.append(classe.classe)
        for classe in eleve_classes_for_etab:
            etablissement_context.classe_to_niv_formation[classe] = eleve_ldap.niveau_formation</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.delete_courses"><code class="name flex">
<span>def <span class="ident">delete_courses</span></span>(<span>self, courseids: List[int], log=&lt;RootLogger root (WARNING)&gt;) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Supprime les cours d'une liste en paginant les appels au webservice
:param courseids: La liste des id de cours à supprimer
:param pagesize: Le nombre de cours supprimés en un seul appel au webservice
:param log:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_courses(self, courseids: List[int], log=getLogger()) -&gt; int:
    &#34;&#34;&#34;
    Supprime les cours d&#39;une liste en paginant les appels au webservice
    :param courseids: La liste des id de cours à supprimer
    :param pagesize: Le nombre de cours supprimés en un seul appel au webservice
    :param log:
    :return:
    &#34;&#34;&#34;
    pagesize = self.__config.webservice.course_delete_pagesize
    i = 0
    total = len(courseids)
    courseids_page = []
    for courseid in courseids:
        courseids_page.append(courseid)
        i += 1
        if i % pagesize == 0:
            self.__webservice.delete_courses(courseids_page)
            courseids_page = []
            log.info(&#34;%d / %d cours supprimés&#34;, i, total)
    if i % pagesize &gt; 0:
        self.__webservice.delete_courses(courseids_page)
        log.info(&#34;%d / %d cours supprimés&#34;, i, total)
    return i</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.delete_empty_cohorts"><code class="name flex">
<span>def <span class="ident">delete_empty_cohorts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Supprime les cohortes vides</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_empty_cohorts(self):
    &#34;&#34;&#34;
    Supprime les cohortes vides
    &#34;&#34;&#34;
    #Récupère les ids des cohortes
    empty_cohorts_ids = self.__db.get_empty_cohorts()
    if len(empty_cohorts_ids) &gt; 0:
        #Fait appel au webservice moodle pour suppression
        self.__webservice.delete_cohorts(empty_cohorts_ids)</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.delete_users"><code class="name flex">
<span>def <span class="ident">delete_users</span></span>(<span>self, userids: List[int], log=&lt;RootLogger root (WARNING)&gt;) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Supprime les utilisateurs d'une liste en paginant les appels au webservice
:param userids: La liste des id des utilisateurs à supprimer
:param pagesize:
Le nombre d'utilisateurs supprimés en un seul appel au webservice
:param log:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_users(self, userids: List[int], log=getLogger()) -&gt; int:
    &#34;&#34;&#34;
    Supprime les utilisateurs d&#39;une liste en paginant les appels au webservice
    :param userids: La liste des id des utilisateurs à supprimer
    :param pagesize:  Le nombre d&#39;utilisateurs supprimés en un seul appel au webservice
    :param log:
    :return:
    &#34;&#34;&#34;
    pagesize = self.__config.webservice.user_delete_pagesize
    i = 0
    total = len(userids)
    userids_page = []
    for userid in userids:
        userids_page.append(userid)
        i += 1
        if i % pagesize == 0:
            self.__webservice.delete_users(userids_page)
            userids_page = []
            log.info(&#34;%d / %d utilisateurs supprimés&#34;, i, total)
    if i % pagesize &gt; 0:
        self.__webservice.delete_users(userids_page)
        log.info(&#34;%d / %d utilisateurs supprimés&#34;, i, total)
    return i</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.get_or_create_classes_cohorts"><code class="name flex">
<span>def <span class="ident">get_or_create_classes_cohorts</span></span>(<span>self, id_context_etab, classes_names, time_created, name_pattern=None, desc_pattern=None, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Charge ou crée des cohortes a partir de classes liées a un établissement.
:param id_context_etab:
:param classes_names:
:param time_created:
:param name_pattern:
:param desc_pattern:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_or_create_classes_cohorts(self, id_context_etab, classes_names, time_created, name_pattern=None,
                                  desc_pattern=None, log=getLogger()):
    &#34;&#34;&#34;
    Charge ou crée des cohortes a partir de classes liées a un établissement.
    :param id_context_etab:
    :param classes_names:
    :param time_created:
    :param name_pattern:
    :param desc_pattern:
    :return:
    &#34;&#34;&#34;

    if name_pattern is None:
        name_pattern = &#34;Élèves de la Classe %s&#34;
    if desc_pattern is None:
        desc_pattern = &#34;Élèves de la Classe %s&#34;

    ids_cohorts = []
    for class_name in classes_names:
        cohort_name = name_pattern % class_name
        cohort_description = desc_pattern % class_name
        id_cohort = self.get_or_create_cohort(id_context_etab,
                                              cohort_name,
                                              cohort_name,
                                              cohort_description,
                                              time_created,
                                              log=log)
        ids_cohorts.append(id_cohort)
    return ids_cohorts</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.get_or_create_cohort"><code class="name flex">
<span>def <span class="ident">get_or_create_cohort</span></span>(<span>self, id_context, name, id_number, description, time_created, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de creer une nouvelle cohorte pour un contexte donne.
:param id_context:
:param name:
:param id_number:
:param description:
:param time_created:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_or_create_cohort(self, id_context, name, id_number, description, time_created, log=getLogger()):
    &#34;&#34;&#34;
    Fonction permettant de creer une nouvelle cohorte pour un contexte donne.
    :param id_context:
    :param name:
    :param id_number:
    :param description:
    :param time_created:
    :return:
    &#34;&#34;&#34;
    id_cohort = self.__db.get_id_cohort(id_context, name)
    if id_cohort is None:
        self.__db.create_cohort(id_context, name, id_number, description, time_created)
        log.info(&#34;Creation de la cohorte (name=%s)&#34;, name)
        return self.__db.get_id_cohort(id_context, name)
    return id_cohort</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.get_or_create_dane_dep_clg_cohort"><code class="name flex">
<span>def <span class="ident">get_or_create_dane_dep_clg_cohort</span></span>(<span>self, id_context_dane, user_type: <a title="synchromoodle.synchronizer.UserType" href="#synchromoodle.synchronizer.UserType">UserType</a>, departement, timestamp_now_sql, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Charge ou créer une cohorte dane dep_clg soit pour les élèves, les enseignant ou le personnel de direction
:param id_context_dane:
:param user_type:
:param departement:
:param timestamp_now_sql:
:param log:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_or_create_dane_dep_clg_cohort(self, id_context_dane, user_type: UserType, departement, timestamp_now_sql, log=getLogger()):
    &#34;&#34;&#34;
    Charge ou créer une cohorte dane dep_clg soit pour les élèves, les enseignant ou le personnel de direction
    :param id_context_dane:
    :param user_type:
    :param departement:
    :param timestamp_now_sql:
    :param log:
    :return:
    &#34;&#34;&#34;
    all_cohort_name = {
        UserType.ELEVE: &#39;Élèves des collèges du {}&#39;,
        UserType.ENSEIGNANT: &#39;Enseignants des collèges du {}&#39;,
        UserType.PERSONNEL_DE_DIRECTION: &#39;Personnel de direction des collèges du {}&#39;
    }
    cohort_name = all_cohort_name[user_type].format(departement)
    cohort_description = cohort_name
    id_cohort = self.get_or_create_cohort(id_context_dane, cohort_name, cohort_name, cohort_description,
                                          timestamp_now_sql, log)
    return id_cohort</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.get_or_create_dane_lycee_en_cohort"><code class="name flex">
<span>def <span class="ident">get_or_create_dane_lycee_en_cohort</span></span>(<span>self, id_context_dane, user_type: <a title="synchromoodle.synchronizer.UserType" href="#synchromoodle.synchronizer.UserType">UserType</a>, timestamp_now_sql, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Charge ou créer une cohorte dane lycee_en soit pour les élèves, les enseignant ou le personnel de direction
:param id_context_dane:
:param user_type:
:param timestamp_now_sql:
:param log:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_or_create_dane_lycee_en_cohort(self, id_context_dane, user_type: UserType, timestamp_now_sql, log=getLogger()):
    &#34;&#34;&#34;
    Charge ou créer une cohorte dane lycee_en soit pour les élèves, les enseignant ou le personnel de direction
    :param id_context_dane:
    :param user_type:
    :param timestamp_now_sql:
    :param log:
    :return:
    &#34;&#34;&#34;
    all_cohort_name = {
        UserType.ELEVE: &#39;Élèves des lycées de l\&#39;éducation national&#39;,
        UserType.ENSEIGNANT: &#39;Enseignants des lycées de l\&#39;éducation national&#39;,
        UserType.PERSONNEL_DE_DIRECTION: &#39;Personnel de direction des lycées de l\&#39;éducation national&#39;
    }
    cohort_name = all_cohort_name[user_type]
    cohort_description = cohort_name
    id_cohort = self.get_or_create_cohort(id_context_dane, cohort_name, cohort_name, cohort_description,
                                          timestamp_now_sql, log)
    return id_cohort</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.get_or_create_formation_cohort"><code class="name flex">
<span>def <span class="ident">get_or_create_formation_cohort</span></span>(<span>self, id_context_etab, niveau_formation, timestamp_now_sql, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Charge ou créer une cohorte de formation
:param id_context_etab:
:param niveau_formation:
:param timestamp_now_sql:
:param log:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_or_create_formation_cohort(self, id_context_etab, niveau_formation, timestamp_now_sql, log=getLogger()):
    &#34;&#34;&#34;
    Charge ou créer une cohorte de formation
    :param id_context_etab:
    :param niveau_formation:
    :param timestamp_now_sql:
    :param log:
    :return:
    &#34;&#34;&#34;
    cohort_name = &#39;Élèves du Niveau de formation %s&#39; % niveau_formation
    cohort_description = &#39;Eleves avec le niveau de formation %s&#39; % niveau_formation
    id_cohort = self.get_or_create_cohort(id_context_etab, cohort_name, cohort_name, cohort_description,
                                          timestamp_now_sql, log)
    return id_cohort</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.get_or_create_niv_formation_cohorts"><code class="name flex">
<span>def <span class="ident">get_or_create_niv_formation_cohorts</span></span>(<span>self, id_context_etab, niveaux_formation, time_created, name_pattern, desc_pattern, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Charge ou crée des cohortes a partir de niveau de formation liés a un établissement.
:param id_context_etab:
:param niveaux_formation:
:param time_created:
:param name_pattern:
:param desc_pattern:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_or_create_niv_formation_cohorts(self, id_context_etab, niveaux_formation, time_created, name_pattern, desc_pattern, log=getLogger()):
    &#34;&#34;&#34;
    Charge ou crée des cohortes a partir de niveau de formation liés a un établissement.
    :param id_context_etab:
    :param niveaux_formation:
    :param time_created:
    :param name_pattern:
    :param desc_pattern:
    :return:
    &#34;&#34;&#34;

    ids_cohorts = []
    for niveau_formation in niveaux_formation:
        cohort_name = name_pattern % niveau_formation
        cohort_description = desc_pattern % niveau_formation
        id_cohort = self.get_or_create_cohort(id_context_etab,
                                              cohort_name,
                                              cohort_name,
                                              cohort_description,
                                              time_created,
                                              log=log)
        ids_cohorts.append(id_cohort)
    return ids_cohorts</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.get_or_create_profs_etab_cohort"><code class="name flex">
<span>def <span class="ident">get_or_create_profs_etab_cohort</span></span>(<span>self, etab_context: <a title="synchromoodle.synchronizer.EtablissementContext" href="#synchromoodle.synchronizer.EtablissementContext">EtablissementContext</a>, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Charge ou crée la cohorte d'enseignant de l'établissement.
:param etab_context:
:param log:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_or_create_profs_etab_cohort(self, etab_context: EtablissementContext, log=getLogger()):
    &#34;&#34;&#34;
    Charge ou crée la cohorte d&#39;enseignant de l&#39;établissement.
    :param etab_context:
    :param log:
    :return:
    &#34;&#34;&#34;
    cohort_name = &#39;Profs de l\&#39;établissement (%s)&#39; % etab_context.uai
    cohort_description = &#39;Enseignants de l\&#39;établissement %s&#39; % etab_context.uai
    id_cohort_enseignants = self.get_or_create_cohort(etab_context.id_context_categorie,
                                                      cohort_name,
                                                      cohort_name,
                                                      cohort_description,
                                                      self.context.timestamp_now_sql,
                                                      log=log)
    return id_cohort_enseignants</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.get_users_by_cohorts_comparators_eleves_classes"><code class="name flex">
<span>def <span class="ident">get_users_by_cohorts_comparators_eleves_classes</span></span>(<span>self, etab_context: <a title="synchromoodle.synchronizer.EtablissementContext" href="#synchromoodle.synchronizer.EtablissementContext">EtablissementContext</a>, cohortname_pattern_re: str, cohortname_pattern: str) ‑> (typing.Dict[str, typing.List[str]], typing.Dict[str, typing.List[str]])</span>
</code></dt>
<dd>
<div class="desc"><p>Renvoie deux dictionnaires listant les élèves (uid) dans chacune des classes.
Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
:param etab_context: EtablissementContext
:param cohortname_pattern_re: str
:param cohortname_pattern: str
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_users_by_cohorts_comparators_eleves_classes(self, etab_context: EtablissementContext, cohortname_pattern_re: str,
                                     cohortname_pattern: str) -&gt; (Dict[str, List[str]], Dict[str, List[str]]):
    &#34;&#34;&#34;
    Renvoie deux dictionnaires listant les élèves (uid) dans chacune des classes.
    Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
    :param etab_context: EtablissementContext
    :param cohortname_pattern_re: str
    :param cohortname_pattern: str
    :return:
    &#34;&#34;&#34;
    # Récupére les cohortes qui correspondent au pattern et qui sont lié à l&#39;établissement du context
    classes_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

    # Dictionnaire contenant la liste des élèves par cohorte provenant de la bdd
    eleves_by_cohorts_db = {}
    # Pour chaque cohorte de la bdd
    for cohort in classes_cohorts:
        matches = re.search(cohortname_pattern_re, cohort.name)
        # On récupére le nom de la classe (fin du nom de la cohorte qui lui est fixe)
        classe_name = matches.group(2)
        # On créé le tableau vide pour y stocker les élèves
        eleves_by_cohorts_db[classe_name] = []
        # Et on stocke les élèves de cette cohorte en provenant ce la bdd
        for username in self.__db.get_cohort_members(cohort.id):
            eleves_by_cohorts_db[classe_name].append(username.lower())

    # Dictionnaire contenant la liste des élèves par cohorte provenant du ldap
    eleves_by_cohorts_ldap = {}
    # Pour chaque cohorte de la bdd
    for classe in eleves_by_cohorts_db:
        # On créé le tableau vide pour y stocker les élèves
        eleves_by_cohorts_ldap[classe] = []
        # Et on stocke les élèves de cette cohorte en provenant du ldap
        for eleve in self.__ldap.search_eleves_in_classe(classe, etab_context.uai):
            eleves_by_cohorts_ldap[classe].append(eleve.uid.lower())

    return eleves_by_cohorts_db, eleves_by_cohorts_ldap</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.get_users_by_cohorts_comparators_eleves_niveau"><code class="name flex">
<span>def <span class="ident">get_users_by_cohorts_comparators_eleves_niveau</span></span>(<span>self, etab_context: <a title="synchromoodle.synchronizer.EtablissementContext" href="#synchromoodle.synchronizer.EtablissementContext">EtablissementContext</a>, cohortname_pattern_re: str, cohortname_pattern: str) ‑> (typing.Dict[str, typing.List[str]], typing.Dict[str, typing.List[str]])</span>
</code></dt>
<dd>
<div class="desc"><p>Renvoie deux dictionnaires listant les élèves (uid) dans chacun des niveaux de formation
Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
:param etab_context: EtablissementContext
:param cohortname_pattern_re: str
:param cohortname_pattern: str
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_users_by_cohorts_comparators_eleves_niveau(self, etab_context: EtablissementContext, cohortname_pattern_re: str,
                                     cohortname_pattern: str) -&gt; (Dict[str, List[str]], Dict[str, List[str]]):
    &#34;&#34;&#34;
    Renvoie deux dictionnaires listant les élèves (uid) dans chacun des niveaux de formation
    Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
    :param etab_context: EtablissementContext
    :param cohortname_pattern_re: str
    :param cohortname_pattern: str
    :return:
    &#34;&#34;&#34;
    classes_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

    eleves_by_cohorts_db = {}
    for cohort in classes_cohorts:
        matches = re.search(cohortname_pattern_re, cohort.name)
        classe_name = matches.group(2)
        eleves_by_cohorts_db[classe_name] = []
        for username in self.__db.get_cohort_members(cohort.id):
            eleves_by_cohorts_db[classe_name].append(username.lower())

    eleves_by_cohorts_ldap = {}
    for niveau in eleves_by_cohorts_db:
        eleves_by_cohorts_ldap[niveau] = []
        for eleve in self.__ldap.search_eleves_in_niveau(niveau, etab_context.uai):
            eleves_by_cohorts_ldap[niveau].append(eleve.uid.lower())

    return eleves_by_cohorts_db, eleves_by_cohorts_ldap</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.get_users_by_cohorts_comparators_profs_classes"><code class="name flex">
<span>def <span class="ident">get_users_by_cohorts_comparators_profs_classes</span></span>(<span>self, etab_context: <a title="synchromoodle.synchronizer.EtablissementContext" href="#synchromoodle.synchronizer.EtablissementContext">EtablissementContext</a>, cohortname_pattern_re: str, cohortname_pattern: str) ‑> (typing.Dict[str, typing.List[str]], typing.Dict[str, typing.List[str]])</span>
</code></dt>
<dd>
<div class="desc"><p>Renvoie deux dictionnaires listant les profs (uid) dans chacune des classes
Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
:param etab_context: EtablissementContext
:param cohortname_pattern_re: str
:param cohortname_pattern: str
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_users_by_cohorts_comparators_profs_classes(self, etab_context: EtablissementContext, cohortname_pattern_re: str,
                                     cohortname_pattern: str) -&gt; (Dict[str, List[str]], Dict[str, List[str]]):
    &#34;&#34;&#34;
    Renvoie deux dictionnaires listant les profs (uid) dans chacune des classes
    Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
    :param etab_context: EtablissementContext
    :param cohortname_pattern_re: str
    :param cohortname_pattern: str
    :return:
    &#34;&#34;&#34;
    classes_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

    profs_by_cohorts_db = {}
    for cohort in classes_cohorts:
        matches = re.search(cohortname_pattern_re, cohort.name)
        classe_name = matches.group(2)
        profs_by_cohorts_db[classe_name] = []
        for username in self.__db.get_cohort_members(cohort.id):
            profs_by_cohorts_db[classe_name].append(username.lower())

    profs_by_cohorts_ldap = {}
    for classe in profs_by_cohorts_db:
        profs_by_cohorts_ldap[classe] = []
        for prof in self.__ldap.search_enseignants_in_classe(classe, etab_context.uai):
            profs_by_cohorts_ldap[classe].append(prof.uid.lower())

    return profs_by_cohorts_db, profs_by_cohorts_ldap</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.get_users_by_cohorts_comparators_profs_etab"><code class="name flex">
<span>def <span class="ident">get_users_by_cohorts_comparators_profs_etab</span></span>(<span>self, etab_context: <a title="synchromoodle.synchronizer.EtablissementContext" href="#synchromoodle.synchronizer.EtablissementContext">EtablissementContext</a>, cohortname_pattern_re: str, cohortname_pattern: str) ‑> (typing.Dict[str, typing.List[str]], typing.Dict[str, typing.List[str]])</span>
</code></dt>
<dd>
<div class="desc"><p>Renvoie deux dictionnaires listant les profs (uid) dans chacun des établissement
Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
:param etab_context: EtablissementContext
:param cohortname_pattern_re: str
:param cohortname_pattern: str
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_users_by_cohorts_comparators_profs_etab(self, etab_context: EtablissementContext, cohortname_pattern_re: str,
                                     cohortname_pattern: str) -&gt; (Dict[str, List[str]], Dict[str, List[str]]):
    &#34;&#34;&#34;
    Renvoie deux dictionnaires listant les profs (uid) dans chacun des établissement
    Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
    :param etab_context: EtablissementContext
    :param cohortname_pattern_re: str
    :param cohortname_pattern: str
    :return:
    &#34;&#34;&#34;
    etab_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

    profs_by_cohorts_db = {}
    for cohort in etab_cohorts:
        matches = re.search(cohortname_pattern_re, cohort.name)
        etab_name = matches.group(2)
        profs_by_cohorts_db[etab_name] = []
        for username in self.__db.get_cohort_members(cohort.id):
            profs_by_cohorts_db[etab_name].append(username.lower())

    profs_by_cohorts_ldap = {}
    for etab in profs_by_cohorts_db:
        profs_by_cohorts_ldap[etab] = []
        for prof in self.__ldap.search_enseignants_in_etab(etab_context.uai):
            profs_by_cohorts_ldap[etab].append(prof.uid.lower())

    return profs_by_cohorts_db, profs_by_cohorts_ldap</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.get_users_by_cohorts_comparators_profs_niveau"><code class="name flex">
<span>def <span class="ident">get_users_by_cohorts_comparators_profs_niveau</span></span>(<span>self, etab_context: <a title="synchromoodle.synchronizer.EtablissementContext" href="#synchromoodle.synchronizer.EtablissementContext">EtablissementContext</a>, cohortname_pattern_re: str, cohortname_pattern: str) ‑> (typing.Dict[str, typing.List[str]], typing.Dict[str, typing.List[str]])</span>
</code></dt>
<dd>
<div class="desc"><p>Renvoie deux dictionnaires listant les profs (uid) dans chacun des niveaux de formation
Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
:param etab_context: EtablissementContext
:param cohortname_pattern_re: str
:param cohortname_pattern: str
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_users_by_cohorts_comparators_profs_niveau(self, etab_context: EtablissementContext, cohortname_pattern_re: str,
                                     cohortname_pattern: str) -&gt; (Dict[str, List[str]], Dict[str, List[str]]):
    &#34;&#34;&#34;
    Renvoie deux dictionnaires listant les profs (uid) dans chacun des niveaux de formation
    Le premier dictionnaire contient les valeurs de la BDD, le second celles du LDAP
    :param etab_context: EtablissementContext
    :param cohortname_pattern_re: str
    :param cohortname_pattern: str
    :return:
    &#34;&#34;&#34;

    #Construit le dictionnaire pour avoir l&#39;association classe -&gt; niveau de formation
    self.construct_classe_to_niv_formation(etab_context, self.__ldap.search_eleve(None, etab_context.uai))

    #Récupère les cohortes coté moodle
    levels_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

    profs_by_cohorts_db = {}
    for cohort in levels_cohorts:
        matches = re.search(cohortname_pattern_re, cohort.name)
        level_name = matches.group(2)
        profs_by_cohorts_db[level_name] = []
        for username in self.__db.get_cohort_members(cohort.id):
            profs_by_cohorts_db[level_name].append(username.lower())

    profs_by_cohorts_ldap = {}
    for niveau in profs_by_cohorts_db:
        profs_by_cohorts_ldap[niveau] = []
        for prof in self.__ldap.search_enseignants_in_niveau(niveau, etab_context.uai, etab_context.classe_to_niv_formation):
            profs_by_cohorts_ldap[niveau].append(prof.uid.lower())

    return profs_by_cohorts_db, profs_by_cohorts_ldap</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.get_users_by_dane_cohorts"><code class="name flex">
<span>def <span class="ident">get_users_by_dane_cohorts</span></span>(<span>self, cohortname_pattern: str) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Renvoie un dictionnaire listant les utilisateurs BDD (uid) dans la cohorte dane.
:param cohortname_pattern: str
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_users_by_dane_cohorts(self, cohortname_pattern: str) -&gt; List[str]:
    &#34;&#34;&#34;
    Renvoie un dictionnaire listant les utilisateurs BDD (uid) dans la cohorte dane.
    :param cohortname_pattern: str
    :return:
    &#34;&#34;&#34;
    # Récupére les cohortes qui correspondent au pattern et qui sont lié à l&#39;établissement du context
    classes_cohorts = self.__db.get_user_filtered_cohorts(etab_context.id_context_categorie, cohortname_pattern)

    # Dictionnaire contenant la liste des élèves par cohorte provenant de la bdd
    eleves_by_cohorts_db = {}
    # Pour chaque cohorte de la bdd
    for cohort in classes_cohorts:
        matches = re.search(cohortname_pattern_re, cohort.name)
        # On récupére le nom de la classe (fin du nom de la cohorte qui lui est fixe)
        classe_name = matches.group(2)
        # On créé le tableau vide pour y stocker les élèves
        eleves_by_cohorts_db[classe_name] = []
        # Et on stocke les élèves de cette cohorte en provenant ce la bdd
        for username in self.__db.get_cohort_members(cohort.id):
            eleves_by_cohorts_db[classe_name].append(username.lower())

    # Dictionnaire contenant la liste des élèves par cohorte provenant du ldap
    eleves_by_cohorts_ldap = {}
    # Pour chaque cohorte de la bdd
    for classe in eleves_by_cohorts_db:
        # On créé le tableau vide pour y stocker les élèves
        eleves_by_cohorts_ldap[classe] = []
        # Et on stocke les élèves de cette cohorte en provenant du ldap
        for eleve in self.__ldap.search_eleves_in_classe(classe, etab_context.uai):
            eleves_by_cohorts_ldap[classe].append(eleve.uid.lower())

    return eleves_by_cohorts_db, eleves_by_cohorts_ldap</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.handle_dane"><code class="name flex">
<span>def <span class="ident">handle_dane</span></span>(<span>self, uai_dane, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_dane(self, uai_dane, log=getLogger()):
    # Récupération des informations de la dane pour les cohortes de la dane
    log.debug(&#34;Recherche de la structure dane dans l&#39;annuaire&#34;)
    structure_ldap = self.__ldap.get_structure(uai_dane)
    if structure_ldap:
        log.debug(&#34;La structure dane a été trouvée&#34;)
        etablissement_path = &#34;/1&#34;

        # Recuperation du bon theme
        etablissement_theme = structure_ldap.uai.lower()

        # Creation de la structure si elle n&#39;existe pas encore
        id_dane_categorie = self.__db.get_id_course_category_by_theme(context.etablissement_theme)
        if id_dane_categorie is None:
            log.info(&#34;Création de la structure dane&#34;)
            self.insert_moodle_structure(False, structure_ldap.nom,
                                            etablissement_path, structure_ldap.nom,
                                            structure_ldap.siren, etablissement_theme)
            id_dane_categorie = self.__db.get_id_course_category_by_id_number(structure_ldap.siren)

        # Récupération des identifiants de 3 cohortes pour les lycées de l&#39;enseignement national
        for user_type in UserType:
            self.ids_cohorts_dane_lycee_en[user_type] = \
                self.get_or_create_dane_lycee_en_cohort(id_context_dane, user_type, self.context.timestamp_now_sql)

        # Pour les différents type d&#39;utilisateurs
        for user_type in UserType:
            self.ids_cohorts_dane_dep_clg[user_type] = {}
            # Récupération des identifiants des cohortes pour les collèges par départements
            for departement in self.__config.constantes.departements:
                self.ids_cohorts_dane_dep_clg[user_type][departement] = \
                    get_or_create_dane_dep_clg_cohort(id_dane_categorie, user_type, departement, self.context.timestamp_now_sql)

        # TODO lvillanne ici avant on avait l&#39;ancien système de purge qui n&#39;est plus valable, donc a réimaginer</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.handle_eleve"><code class="name flex">
<span>def <span class="ident">handle_eleve</span></span>(<span>self, etablissement_context: <a title="synchromoodle.synchronizer.EtablissementContext" href="#synchromoodle.synchronizer.EtablissementContext">EtablissementContext</a>, eleve_ldap: <a title="synchromoodle.ldaputils.EleveLdap" href="ldaputils.html#synchromoodle.ldaputils.EleveLdap">EleveLdap</a>, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Synchronise un élève au sein d'un établissement
:param etablissement_context:
:param eleve_ldap:
:param log:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_eleve(self, etablissement_context: EtablissementContext, eleve_ldap: EleveLdap, log=getLogger()):
    &#34;&#34;&#34;
    Synchronise un élève au sein d&#39;un établissement
    :param etablissement_context:
    :param eleve_ldap:
    :param log:
    :return:
    &#34;&#34;&#34;
    mail_display = self.__config.constantes.default_mail_display
    if not eleve_ldap.mail:
        eleve_ldap.mail = self.__config.constantes.default_mail
        log.info(&#34;Le mail de l&#39;élève n&#39;est pas défini dans l&#39;annuaire, &#34;
                 &#34;utilisation de la valeur par défault: %s&#34;, eleve_ldap.mail)

    eleve_id = self.__db.get_user_id(eleve_ldap.uid)

    if not eleve_id:
        log.info(&#34;Ajout de l&#39;utilisateur: %s&#34;, eleve_ldap)
        self.__db.insert_moodle_user(eleve_ldap.uid, eleve_ldap.given_name,
                                     eleve_ldap.sn, eleve_ldap.mail,
                                     mail_display, etablissement_context.etablissement_theme)
        eleve_id = self.__db.get_user_id(eleve_ldap.uid)
    else:
        log.info(&#34;Mise à jour de l&#39;utilisateur: %s&#34;, eleve_ldap)
        self.__db.update_moodle_user(eleve_id, eleve_ldap.given_name,
                                     eleve_ldap.sn, eleve_ldap.mail, mail_display,
                                     etablissement_context.etablissement_theme)

    # Ajout ou suppression du role d&#39;utilisateur avec droits limités Pour les eleves de college
    if etablissement_context.structure_ldap.type == self.__config.constantes.type_structure_clg:
        log.info(&#34;Ajout du rôle droit limités à l&#39;utilisateur: %s&#34;, eleve_ldap)
        self.__db.add_role_to_user(self.__config.constantes.id_role_utilisateur_limite,
                                   self.__config.constantes.id_instance_moodle, eleve_id)
    else:
        self.__db.remove_role_to_user(self.__config.constantes.id_role_utilisateur_limite,
                                      self.__config.constantes.id_instance_moodle, eleve_id)
        log.info(
            &#34;Suppression du role d&#39;utilisateur avec des droits limites à l&#39;utilisateur %s %s %s (id = %s)&#34;
            , eleve_ldap.given_name, eleve_ldap.sn, eleve_ldap.uid, str(eleve_id))

    # Inscription dans les cohortes associees aux classes
    eleve_cohorts = []
    eleve_classes_for_etab = []
    for classe in eleve_ldap.classes:
        if classe.etab_dn == etablissement_context.structure_ldap.dn:
            eleve_classes_for_etab.append(classe.classe)
    if eleve_classes_for_etab:
        log.info(&#34;Inscription de l&#39;élève %s &#34;
                 &#34;dans les cohortes de classes %s&#34;, eleve_ldap, eleve_classes_for_etab)
        ids_classes_cohorts = self.get_or_create_classes_cohorts(etablissement_context.id_context_categorie,
                                                                 eleve_classes_for_etab,
                                                                 self.context.timestamp_now_sql,
                                                                 log=log)
        for ids_classe_cohorts in ids_classes_cohorts:
            self.__db.enroll_user_in_cohort(ids_classe_cohorts, eleve_id, self.context.timestamp_now_sql)

        eleve_cohorts.extend(ids_classes_cohorts)

    # Inscription dans la cohorte associee au niveau de formation
    if eleve_ldap.niveau_formation:
        log.info(&#34;Inscription de l&#39;élève %s &#34;
                 &#34;dans la cohorte de niveau de formation %s&#34;, eleve_ldap, eleve_ldap.niveau_formation)
        id_formation_cohort = self.get_or_create_formation_cohort(etablissement_context.id_context_categorie,
                                                                  eleve_ldap.niveau_formation,
                                                                  self.context.timestamp_now_sql,
                                                                  log=log)
        self.__db.enroll_user_in_cohort(id_formation_cohort, eleve_id, self.context.timestamp_now_sql)
        eleve_cohorts.append(id_formation_cohort)

    # Inscription dans les cohortes de la Dane
    if etablissement_context.college and etablissement_context.departement in self.__config.constantes.departements:
        self.__db.enroll_user_in_cohort(self.ids_cohorts_dane_dep_clg[UserType.ELEVE][etablissement_context.departement],
            eleve_id, self.context.timestamp_now_sql)
    elif etablissement_context.lycee and etablissement_context.etablissement_en:
        self.__db.enroll_user_in_cohort(self.ids_cohorts_dane_lycee_en[UserType.ELEVE], eleve_id, self.context.timestamp_now_sql)

    # Mise a jour de la classe
    id_user_info_data = self.__db.get_id_user_info_data(eleve_id, self.context.id_field_classe)
    if id_user_info_data is not None:
        self.__db.update_user_info_data(eleve_id, self.context.id_field_classe, eleve_ldap.classe.classe)
        log.debug(&#34;Mise à jour user_info_data&#34;)
    else:
        self.__db.insert_moodle_user_info_data(eleve_id, self.context.id_field_classe, eleve_ldap.classe.classe)
        log.debug(&#34;Insertion user_info_data&#34;)

    # Mise a jour du Domaine
    user_domain = self.__config.constantes.default_domain
    if len(eleve_ldap.domaines) == 1:
        user_domain = eleve_ldap.domaines[0]
    else:
        if eleve_ldap.uai_courant and eleve_ldap.uai_courant in self.context.map_etab_domaine:
            user_domain = self.context.map_etab_domaine[eleve_ldap.uai_courant][0]
    log.debug(&#34;Insertion du Domaine&#34;)
    self.__db.set_user_domain(eleve_id, self.context.id_field_domaine, user_domain)</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.handle_enseignant"><code class="name flex">
<span>def <span class="ident">handle_enseignant</span></span>(<span>self, etablissement_context: <a title="synchromoodle.synchronizer.EtablissementContext" href="#synchromoodle.synchronizer.EtablissementContext">EtablissementContext</a>, enseignant_ldap: <a title="synchromoodle.ldaputils.EnseignantLdap" href="ldaputils.html#synchromoodle.ldaputils.EnseignantLdap">EnseignantLdap</a>, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Met à jour un enseignant au sein d'un établissement
:param etablissement_context:
:param enseignant_ldap:
:param log:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_enseignant(self, etablissement_context: EtablissementContext, enseignant_ldap: EnseignantLdap,
                      log=getLogger()):
    &#34;&#34;&#34;
    Met à jour un enseignant au sein d&#39;un établissement
    :param etablissement_context:
    :param enseignant_ldap:
    :param log:
    :return:
    &#34;&#34;&#34;

    enseignant_infos = &#34;%s %s %s&#34; % (enseignant_ldap.uid, enseignant_ldap.given_name, enseignant_ldap.sn)

    if enseignant_ldap.uai_courant and not etablissement_context.etablissement_regroupe:
        etablissement_context.etablissement_theme = enseignant_ldap.uai_courant.lower()

    if not enseignant_ldap.mail:
        enseignant_ldap.mail = self.__config.constantes.default_mail

    # Affichage du mail reserve aux membres de cours
    mail_display = self.__config.constantes.default_mail_display
    if etablissement_context.structure_ldap.uai in self.__action_config.etablissements.listeEtabSansMail:
        # Desactivation de l&#39;affichage du mail
        mail_display = 0

    # Insertion de l&#39;enseignant
    id_user = self.__db.get_user_id(enseignant_ldap.uid)
    if not id_user:
        self.__db.insert_moodle_user(enseignant_ldap.uid, enseignant_ldap.given_name, enseignant_ldap.sn,
                                     enseignant_ldap.mail,
                                     mail_display, etablissement_context.etablissement_theme)
        id_user = self.__db.get_user_id(enseignant_ldap.uid)
    else:
        self.__db.update_moodle_user(id_user, enseignant_ldap.given_name, enseignant_ldap.sn, enseignant_ldap.mail,
                                     mail_display, etablissement_context.etablissement_theme)

    # Mise à jour des droits sur les anciens etablissement
    if enseignant_ldap.uais is not None and not etablissement_context.etablissement_regroupe:
        # Recuperation des uais des etablissements dans lesquels l&#39;enseignant est autorise
        self.mettre_a_jour_droits_enseignant(enseignant_infos, id_user, enseignant_ldap.uais, log=log)

    # Ajout du role de createur de cours au niveau de la categorie inter-etablissement Moodle
    self.__db.add_role_to_user(self.__config.constantes.id_role_createur_cours,
                               self.context.id_context_categorie_inter_etabs, id_user)
    log.info(&#34;Ajout du role de createur de cours dans la categorie inter-etablissements&#34;)

    # Si l&#39;enseignant fait partie d&#39;un CFA
    # Ajout du role createur de cours au niveau de la categorie inter-cfa
    if etablissement_context.structure_ldap.type == self.__config.constantes.type_structure_cfa:
        self.__db.add_role_to_user(self.__config.constantes.id_role_createur_cours,
                                   self.context.id_context_categorie_inter_cfa, id_user)
        log.info(&#34;Ajout du role de createur de cours dans la categorie inter-cfa&#34;)
    else:
        if  etablissement_context.structure_ldap.type.startswith(&#39;LYCEE&#39;) \
            or etablissement_context.structure_ldap.type == self.__config.constantes.type_structure_ens_adapte \
            or etablissement_context.structure_ldap.uai == &#39;0370074E&#39; \
            or ( etablissement_context.structure_ldap.type.startswith(&#39;COLLEGE&#39;) \
            or etablissement_context.structure_ldap.type == self.__config.constantes.type_structure_cfa_agricole  ) :
            if set(enseignant_ldap.profils).intersection([&#39;National_ENS&#39;,&#39;National_DOC&#39;,&#39;National_DIR&#39;, &#39;National_ETA&#39;, &#39;National_EVS&#39;]):
                log.info(&#34;Ajout du rôle bigbluebutton pour l&#39;utilisateur %s&#34; % id_user)
                self.__db.add_role_to_user(self.__config.constantes.id_role_bigbluebutton,
                                           self.__config.constantes.id_instance_moodle, id_user)

    # ajout du role de createur de cours dans l&#39;etablissement
    self.__db.add_role_to_user(self.__config.constantes.id_role_createur_cours,
                               etablissement_context.id_context_categorie, id_user)

    # Ajouts des autres roles pour le personnel établissement
    if set(enseignant_ldap.profils).intersection([&#39;National_ENS&#39;, &#39;National_DIR&#39;, &#39;National_EVS&#39;, &#39;National_ETA&#39;]):
        # Ajout des roles sur le contexte forum
        self.__db.add_role_to_user(self.__config.constantes.id_role_eleve,
                                   etablissement_context.id_context_course_forum, id_user)
        # Inscription à la Zone Privée
        self.__db.enroll_user_in_course(self.__config.constantes.id_role_eleve,
                                        etablissement_context.id_zone_privee, id_user)

        if set(enseignant_ldap.profils).intersection([&#39;National_ENS&#39;, &#39;National_EVS&#39;, &#39;National_ETA&#39;]):
            if not etablissement_context.gere_admin_local:
                self.__db.add_role_to_user(self.context.id_role_extended_teacher,
                                           etablissement_context.id_context_categorie,
                                           id_user)
        elif &#39;National_DIR&#39; in enseignant_ldap.profils:
            self.__db.add_role_to_user(self.__config.constantes.id_role_directeur,
                                       etablissement_context.id_context_categorie, id_user)

    # Ajout des droits d&#39;administration locale pour l&#39;etablissement
    if etablissement_context.gere_admin_local:
        for member in enseignant_ldap.is_member_of:
            # L&#39;enseignant est il administrateur Moodle ?
            admin_moodle = re.match(etablissement_context.regexp_admin_moodle, member, flags=re.IGNORECASE)
            if admin_moodle:
                self.__db.insert_moodle_local_admin(etablissement_context.id_context_categorie, id_user)
                log.info(&#34;Insertion d&#39;un admin  local %s %s %s&#34;,
                         enseignant_ldap.uid, enseignant_ldap.given_name, enseignant_ldap.sn)
                # Si il est admin local on en fait un utilisateur avancé par default
                if not self.__db.is_enseignant_avance(id_user, self.context.id_role_advanced_teacher):
                    self.__db.add_role_to_user(self.context.id_role_advanced_teacher, 1, id_user)
                break
            else:
                delete = self.__db.delete_moodle_local_admin(self.context.id_context_categorie_inter_etabs, id_user)
                if delete:
                    log.info(&#34;Suppression d&#39;un admin local %s %s %s&#34;,
                             enseignant_ldap.uid, enseignant_ldap.given_name, enseignant_ldap.sn)

    # Inscription dans les cohortes associees aux classes et au niveau de formation
    enseignant_cohorts = []
    enseignant_classes_for_etab = []
    #Récupération des classes de l&#39;établissement traité actuellement
    for classe in enseignant_ldap.classes:
        if classe.etab_dn == etablissement_context.structure_ldap.dn:
            enseignant_classes_for_etab.append(classe.classe)
    if enseignant_classes_for_etab:
        log.info(&#34;Inscription de l&#39;enseignant %s dans les cohortes de classes %s&#34;,
                 enseignant_ldap, enseignant_classes_for_etab)
        name_pattern = &#34;Profs de la Classe %s&#34;
        desc_pattern = &#34;Profs de la Classe %s&#34;
        #Création des cohortes de classes
        ids_classes_cohorts = self.get_or_create_classes_cohorts(etablissement_context.id_context_categorie,
                                                                 enseignant_classes_for_etab,
                                                                 self.context.timestamp_now_sql,
                                                                 name_pattern=name_pattern,
                                                                 desc_pattern=desc_pattern,
                                                                 log=log)
        #Inscription dans les cohortes de classe
        for ids_classe_cohorts in ids_classes_cohorts:
            self.__db.enroll_user_in_cohort(ids_classe_cohorts, id_user, self.context.timestamp_now_sql)

        enseignant_cohorts.extend(ids_classes_cohorts)

        #Inscription dans les cohortes de niveau de formation
        enseignant_niv_formation = set()
        for classe in enseignant_classes_for_etab:
            #Il est possible que l&#39;enseignant enseigne dans une classe mais qui n&#39;est pas dans cet établissement
            #Il sera alors inscrit dans la cohorte du niveau de formation correspondant à la classe lorsqu&#39;on le
            #traitera avec l&#39;autre établissement en question
            if classe in etablissement_context.classe_to_niv_formation.keys():
                enseignant_niv_formation.add(etablissement_context.classe_to_niv_formation[classe])
            else:
                log.error(&#34;Problème avec l&#39;enseignant %s pour l&#39;inscrire dans les cohortes de niveau de formation&#34;, enseignant_ldap)

        log.info(&#34;Inscription de l&#39;enseignant %s dans les cohortes de niveau de formation %s&#34;,
                 enseignant_ldap, enseignant_niv_formation)

        name_pattern = &#34;Profs du niveau de formation %s&#34;
        desc_pattern = &#34;Profs du niveau de formation %s&#34;
        #Création des cohortes de niveau de formation
        ids_niv_formation_cohorts = self.get_or_create_niv_formation_cohorts(etablissement_context.id_context_categorie,
                                                                             enseignant_niv_formation,
                                                                             self.context.timestamp_now_sql,
                                                                             name_pattern=name_pattern,
                                                                             desc_pattern=desc_pattern,
                                                                             log=log)
        #Inscription dans les cohortes de niveau de formation
        for id_cohort_niv_formation in ids_niv_formation_cohorts:
            self.__db.enroll_user_in_cohort(id_cohort_niv_formation, id_user, self.context.timestamp_now_sql)

    log.info(&#34;Inscription de l&#39;enseignant %s dans la cohorte d&#39;enseignants de l&#39;établissement&#34;, enseignant_ldap)
    id_prof_etabs_cohort = self.get_or_create_profs_etab_cohort(etablissement_context, log)

    id_user = self.__db.get_user_id(enseignant_ldap.uid)
    self.__db.enroll_user_in_cohort(id_prof_etabs_cohort, id_user, self.context.timestamp_now_sql)

    # TODO lvillanne réaliser l&#39;inscription dans les cohortes de la dane

    # Mise a jour des dictionnaires concernant les cohortes
    for cohort_id in enseignant_cohorts:
        # Si la cohorte est deja connue
        if cohort_id in etablissement_context.enseignants_by_cohortes:
            etablissement_context.enseignants_by_cohortes[cohort_id].append(id_user)
        # Si la cohorte n&#39;a pas encore ete rencontree
        else:
            etablissement_context.enseignants_by_cohortes[cohort_id] = [id_user]

    # Mise a jour du Domaine
    user_domain = self.__config.constantes.default_domain
    if len(enseignant_ldap.domaines) == 1:
        user_domain = enseignant_ldap.domaines[0]
    else:
        if enseignant_ldap.uai_courant and enseignant_ldap.uai_courant in self.context.map_etab_domaine:
            user_domain = self.context.map_etab_domaine[enseignant_ldap.uai_courant][0]
    log.debug(&#34;Insertion du Domaine&#34;)
    self.__db.set_user_domain(id_user, self.context.id_field_domaine, user_domain)</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.handle_etablissement"><code class="name flex">
<span>def <span class="ident">handle_etablissement</span></span>(<span>self, uai, log=&lt;RootLogger root (WARNING)&gt;, readonly=False) ‑> <a title="synchromoodle.synchronizer.EtablissementContext" href="#synchromoodle.synchronizer.EtablissementContext">EtablissementContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Synchronise un établissement
:return: EtabContext</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_etablissement(self, uai, log=getLogger(), readonly=False) -&gt; EtablissementContext:
    &#34;&#34;&#34;
    Synchronise un établissement
    :return: EtabContext
    &#34;&#34;&#34;

    context = EtablissementContext(uai)
    context.gere_admin_local = uai not in self.__action_config.etablissements.listeEtabSansAdmin
    context.etablissement_regroupe = est_grp_etab(uai, self.__action_config.etablissements)
    # Regex pour savoir si l&#39;utilisateur est administrateur moodle
    context.regexp_admin_moodle = self.__action_config.etablissements.prefixAdminMoodleLocal + &#34;.*_%s$&#34; % uai
    # Regex pour savoir si l&#39;utilisateur est administrateur local
    context.regexp_admin_local = self.__action_config.etablissements.prefixAdminLocal + &#34;.*_%s$&#34; % uai

    log.debug(&#34;Recherche de la structure dans l&#39;annuaire&#34;)
    structure_ldap = self.__ldap.get_structure(uai)
    if structure_ldap:
        log.debug(&#34;La structure a été trouvée&#34;)
        etablissement_path = &#34;/1&#34;

        # Si l&#39;etablissement fait partie d&#39;un groupement
        if context.etablissement_regroupe:
            etablissement_ou = context.etablissement_regroupe[&#34;nom&#34;]
            structure_ldap.uai = context.etablissement_regroupe[&#34;uais&#34;][0]
            log.debug(&#34;L&#39;établissement fait partie d&#39;un groupement: ou=%s, uai=%s&#34;,
                      etablissement_ou, structure_ldap.uai)
        else:
            etablissement_ou = structure_ldap.nom
            log.debug(&#34;L&#39;établissement ne fait partie d&#39;un groupement: ou=%s&#34;, etablissement_ou)

        # Recuperation du bon theme
        context.etablissement_theme = structure_ldap.uai.lower()

        # Affectation des informations utiles pour la constitution des groupes dane
        context.departement = context.uai[1:3] if context.uai[0] == &#39;0&#39; else context.uai[:3]
        context.college = structure_ldap.type == self.__config.constantes.type_structure_clg
        context.lycee = structure_ldap.type.startswith(self.__config.constantes.type_structure_lycee_start_with)
        context.etablissement_en = structure_ldap.jointure.startswith(self.__config.constantes.type_structure_jointure_en_start_with)

        # Creation de la structure si elle n&#39;existe pas encore
        id_etab_categorie = self.__db.get_id_course_category_by_theme(context.etablissement_theme)
        if id_etab_categorie is None and not readonly:
            log.info(&#34;Création de la structure&#34;)
            self.insert_moodle_structure(context.etablissement_regroupe, structure_ldap.nom,
                                         etablissement_path, etablissement_ou,
                                         structure_ldap.siren, context.etablissement_theme)
            id_etab_categorie = self.__db.get_id_course_category_by_id_number(structure_ldap.siren)

        # Mise a jour de la description dans la cas d&#39;un groupement d&#39;etablissement
        if context.etablissement_regroupe and not readonly:
            description = self.__db.get_description_course_category(id_etab_categorie)
            if description.find(structure_ldap.siren) == -1:
                log.info(&#34;Mise à jour de la description&#34;)
                description = &#34;%s$%s@%s&#34; % (description, structure_ldap.siren, structure_ldap.nom)
                self.__db.update_course_category_description(id_etab_categorie, description)
                self.__db.update_course_category_name(id_etab_categorie, etablissement_ou)

        # Recuperation de l&#39;id du contexte correspondant à l&#39;etablissement
        if id_etab_categorie is not None:
            context.id_context_categorie = self.__db.get_id_context_categorie(id_etab_categorie)

        context.id_zone_privee = self.__db.get_id_course_by_id_number(&#34;ZONE-PRIVEE-&#34; + structure_ldap.siren)

        # Recreation de la zone privee si celle-ci n&#39;existe plus
        if context.id_zone_privee is None and not readonly:
            log.info(&#34;Création de la zone privée&#34;)
            context.id_zone_privee = self.__db.insert_zone_privee(id_etab_categorie, structure_ldap.siren,
                                                                  etablissement_ou, self.context.timestamp_now_sql)

        if context.id_zone_privee is not None:
            context.id_context_course_forum = self.__db.get_id_context(self.__config.constantes.niveau_ctx_cours, 3,
                                                                       context.id_zone_privee)
        if context.id_context_course_forum is None and not readonly:
            log.info(&#34;Création du cours associé à la zone privée&#34;)
            context.id_context_course_forum = self.__db.insert_zone_privee_context(context.id_zone_privee)

        context.structure_ldap = structure_ldap
    return context</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.handle_inspecteur"><code class="name flex">
<span>def <span class="ident">handle_inspecteur</span></span>(<span>self, personne_ldap: <a title="synchromoodle.ldaputils.PersonneLdap" href="ldaputils.html#synchromoodle.ldaputils.PersonneLdap">PersonneLdap</a>, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Synchronise un inspecteur
:param personne_ldap:
:param log:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_inspecteur(self, personne_ldap: PersonneLdap, log=getLogger()):
    &#34;&#34;&#34;
    Synchronise un inspecteur
    :param personne_ldap:
    :param log:
    :return:
    &#34;&#34;&#34;
    if not personne_ldap.mail:
        personne_ldap.mail = self.__config.constantes.default_mail

        # Creation de l&#39;utilisateur
        self.__db.insert_moodle_user(personne_ldap.uid, personne_ldap.given_name, personne_ldap.sn,
                                     personne_ldap.mail,
                                     self.__config.constantes.default_mail_display,
                                     self.__config.constantes.default_moodle_theme)
    id_user = self.__db.get_user_id(personne_ldap.uid)
    if not id_user:
        self.__db.insert_moodle_user(personne_ldap.uid, personne_ldap.given_name, personne_ldap.sn,
                                     personne_ldap.mail,
                                     self.__config.constantes.default_mail_display,
                                     self.__config.constantes.default_moodle_theme)
        id_user = self.__db.get_user_id(personne_ldap.uid)
    else:
        self.__db.update_moodle_user(id_user, personne_ldap.given_name, personne_ldap.sn, personne_ldap.mail,
                                     self.__config.constantes.default_mail_display,
                                     self.__config.constantes.default_moodle_theme)

    # Ajout du role de createur de cours au niveau de la categorie inter-etablissement Moodle
    self.__db.add_role_to_user(self.__config.constantes.id_role_createur_cours,
                               self.context.id_context_categorie_inter_etabs, id_user)
    log.info(&#34;Ajout du role de createur de cours dans la categorie inter-etablissements&#34;)

    # Mise a jour du Domaine
    user_domain = self.__config.constantes.default_domain
    if len(personne_ldap.domaines) == 1:
        user_domain = personne_ldap.domaines[0]
    else:
        if personne_ldap.uai_courant and personne_ldap.uai_courant in self.context.map_etab_domaine:
            user_domain = self.context.map_etab_domaine[personne_ldap.uai_courant][0]
    log.debug(&#34;Insertion du Domaine&#34;)
    self.__db.set_user_domain(id_user, self.context.id_field_domaine, user_domain)</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.handle_user_interetab"><code class="name flex">
<span>def <span class="ident">handle_user_interetab</span></span>(<span>self, personne_ldap: <a title="synchromoodle.ldaputils.PersonneLdap" href="ldaputils.html#synchromoodle.ldaputils.PersonneLdap">PersonneLdap</a>, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Synchronise un utilisateur inter-etablissement
:param personne_ldap:
:param log:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_user_interetab(self, personne_ldap: PersonneLdap, log=getLogger()):
    &#34;&#34;&#34;
    Synchronise un utilisateur inter-etablissement
    :param personne_ldap:
    :param log:
    :return:
    &#34;&#34;&#34;
    if not personne_ldap.mail:
        personne_ldap.mail = self.__config.constantes.default_mail

    # Creation de l&#39;utilisateur
    id_user = self.__db.get_user_id(personne_ldap.uid)
    if not id_user:
        self.__db.insert_moodle_user(personne_ldap.uid, personne_ldap.given_name, personne_ldap.sn,
                                     personne_ldap.mail,
                                     self.__config.constantes.default_mail_display,
                                     self.__config.constantes.default_moodle_theme)
        id_user = self.__db.get_user_id(personne_ldap.uid)
    else:
        self.__db.update_moodle_user(id_user, personne_ldap.given_name, personne_ldap.sn, personne_ldap.mail,
                                     self.__config.constantes.default_mail_display,
                                     self.__config.constantes.default_moodle_theme)

    # Ajout du role de createur de cours
    self.__db.add_role_to_user(self.__config.constantes.id_role_createur_cours,
                               self.context.id_context_categorie_inter_etabs, id_user)

    # Attribution du role admin local si necessaire
    for member in personne_ldap.is_member_of:
        admin = re.match(self.__action_config.inter_etablissements.ldap_valeur_attribut_admin, member,
                         flags=re.IGNORECASE)
        if admin:
            insert = self.__db.insert_moodle_local_admin(self.context.id_context_categorie_inter_etabs, id_user)
            if insert:
                log.info(&#34;Insertion d&#39;un admin local %s %s %s&#34;,
                         personne_ldap.uid, personne_ldap.given_name, personne_ldap.sn)
            break
        else:
            delete = self.__db.delete_moodle_local_admin(self.context.id_context_categorie_inter_etabs, id_user)
            if delete:
                log.info(&#34;Suppression d&#39;un admin local %s %s %s&#34;,
                         personne_ldap.uid, personne_ldap.given_name, personne_ldap.sn)</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialise la synchronisation
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self):
    &#34;&#34;&#34;
    Initialise la synchronisation
    :return:
    &#34;&#34;&#34;
    self.context = SyncContext()

    # Recuperation du timestamp actuel
    self.context.timestamp_now_sql = self.__db.get_timestamp_now()

    # Récupération de la liste UAI-Domaine des établissements
    self.context.map_etab_domaine = self.__ldap.get_domaines_etabs()

    # Ids des categories inter etablissements
    id_categorie_inter_etabs = self.__db.get_id_categorie(
        self.__action_config.etablissements.inter_etab_categorie_name)
    self.context.id_context_categorie_inter_etabs = self.__db.get_id_context_categorie(id_categorie_inter_etabs)

    id_categorie_inter_cfa = self.__db.get_id_categorie(
        self.__action_config.etablissements.inter_etab_categorie_name_cfa)
    self.context.id_context_categorie_inter_cfa = self.__db.get_id_context_categorie(id_categorie_inter_cfa)

    # Recuperation des ids des roles
    self.context.id_role_extended_teacher = self.__db.get_id_role_by_shortname(&#39;extendedteacher&#39;)
    self.context.id_role_advanced_teacher = self.__db.get_id_role_by_shortname(&#39;advancedteacher&#39;)

    # Recuperation de l&#39;id du user info field pour la classe
    self.context.id_field_classe = self.__db.get_id_user_info_field_by_shortname(&#39;classe&#39;)

    # Recuperation de l&#39;id du champ personnalisé Domaine
    self.context.id_field_domaine = self.__db.get_id_user_info_field_by_shortname(&#39;Domaine&#39;)</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.insert_moodle_structure"><code class="name flex">
<span>def <span class="ident">insert_moodle_structure</span></span>(<span>self, grp, nom_structure, path, ou, siren, uai)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'inserer une structure dans Moodle.
:param grp:
:param nom_structure:
:param path:
:param ou:
:param siren:
:param uai:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_moodle_structure(self, grp, nom_structure, path, ou, siren, uai):
    &#34;&#34;&#34;
    Fonction permettant d&#39;inserer une structure dans Moodle.
    :param grp:
    :param nom_structure:
    :param path:
    :param ou:
    :param siren:
    :param uai:
    :return:
    &#34;&#34;&#34;
    # Recuperation du timestamp
    now = self.__db.get_timestamp_now()

    # Creation de la description pour la structure
    description = siren
    if grp:
        description = siren + &#34;@&#34; + nom_structure

    #########################
    # PARTIE CATEGORIE
    #########################
    # Insertion de la categorie correspondant a l&#39;etablissement
    self.__db.insert_moodle_course_category(ou, description, description, uai)
    id_categorie_etablissement = self.__db.get_id_course_category_by_id_number(siren)

    # Mise a jour du path de la categorie
    path_etablissement = &#34;/%d&#34; % id_categorie_etablissement
    self.__db.update_course_category_path(id_categorie_etablissement, path_etablissement)

    #########################
    # PARTIE CONTEXTE
    #########################
    # Insertion du contexte associe a la categorie de l&#39;etablissement
    self.__db.insert_moodle_context(self.__config.constantes.niveau_ctx_categorie,
                                    PROFONDEUR_CTX_ETAB,
                                    id_categorie_etablissement)
    id_contexte_etablissement = self.__db.get_id_context(self.__config.constantes.niveau_ctx_categorie,
                                                         PROFONDEUR_CTX_ETAB,
                                                         id_categorie_etablissement)

    # Mise a jour du path de la categorie
    path_contexte_etablissement = &#34;%s/%d&#34; % (path, id_contexte_etablissement)
    self.__db.update_context_path(id_contexte_etablissement, path_contexte_etablissement)

    #########################
    # PARTIE ZONE PRIVEE
    #########################
    # Insertion du cours pour le forum de discussion
    id_zone_privee = self.__db.insert_zone_privee(id_categorie_etablissement, siren, ou, now)

    # Insertion du contexte associe
    id_contexte_zone_privee = self.__db.insert_zone_privee_context(id_zone_privee)

    # Mise a jour du path du contexte
    path_contexte_zone_privee = &#34;%s/%d&#34; % (path_contexte_etablissement, id_contexte_zone_privee)
    self.__db.update_context_path(id_contexte_zone_privee, path_contexte_zone_privee)

    #########################
    # PARTIE INSCRIPTIONS
    #########################
    # Ouverture du cours a l&#39;inscription manuelle
    role_id = self.__config.constantes.id_role_eleve
    self.__db.insert_moodle_enrol_capability(&#34;manual&#34;, 0, id_zone_privee, role_id)

    #########################
    # PARTIE FORUM
    #########################
    # Insertion du forum au sein de la zone privee
    course = id_zone_privee
    name = FORUM_NAME_ZONE_PRIVEE % ou
    intro = FORUM_INTRO_ZONE_PRIVEE
    intro_format = FORUM_INTRO_FORMAT_ZONE_PRIVEE
    max_bytes = FORUM_MAX_BYTES_ZONE_PRIVEE
    max_attachements = FORUM_MAX_ATTACHEMENTS_ZONE_PRIVEE
    time_modified = now

    id_forum = self.__db.get_id_forum(course)
    if id_forum is None:
        self.__db.insert_moodle_forum(course, name, intro, intro_format, max_bytes, max_attachements, time_modified)
        id_forum = self.__db.get_id_forum(course)

    #########################
    # PARTIE MODULE
    #########################
    # Insertion du module forum dans la zone privee
    course = id_zone_privee
    module = COURSE_MODULES_MODULE
    instance = id_forum
    added = now
    id_course_module = self.__db.get_id_course_module(course)
    if id_course_module is None:
        self.__db.insert_moodle_course_module(course, module, instance, added)
        id_course_module = self.__db.get_id_course_module(course)

    # Insertion du contexte pour le module de cours (forum)
    id_contexte_module = self.__db.get_id_context(self.__config.constantes.niveau_ctx_forum,
                                                  PROFONDEUR_CTX_MODULE_ZONE_PRIVEE,
                                                  id_course_module)
    if id_contexte_module is None:
        self.__db.insert_moodle_context(self.__config.constantes.niveau_ctx_forum,
                                        PROFONDEUR_CTX_MODULE_ZONE_PRIVEE,
                                        id_course_module)
        id_contexte_module = self.__db.get_id_context(self.__config.constantes.niveau_ctx_forum,
                                                      PROFONDEUR_CTX_MODULE_ZONE_PRIVEE,
                                                      id_course_module)

    # Mise a jour du path du contexte
    path_contexte_module = &#34;%s/%d&#34; % (path_contexte_zone_privee, id_contexte_module)
    self.__db.update_context_path(id_contexte_module, path_contexte_module)

    #########################
    # PARTIE BLOC
    #########################
    # Insertion du bloc de recherche forum
    parent_context_id = id_contexte_zone_privee
    block_name = BLOCK_FORUM_SEARCH_NAME
    show_in_subcontexts = BLOCK_FORUM_SEARCH_SHOW_IN_SUB_CTX
    page_type_pattern = BLOCK_FORUM_SEARCH_PAGE_TYPE_PATTERN
    sub_page_pattern = BLOCK_FORUM_SEARCH_SUB_PAGE_PATTERN
    default_region = BLOCK_FORUM_SEARCH_DEFAULT_REGION
    default_weight = BLOCK_FORUM_SEARCH_DEFAULT_WEIGHT

    id_block = self.__db.get_id_block(parent_context_id)
    if id_block is None:
        self.__db.insert_moodle_block(block_name, parent_context_id, show_in_subcontexts, page_type_pattern,
                                      sub_page_pattern, default_region, default_weight)
        id_block = self.__db.get_id_block(parent_context_id)

    # Insertion du contexte pour le bloc
    id_contexte_bloc = self.__db.get_id_context(self.__config.constantes.niveau_ctx_bloc,
                                                PROFONDEUR_CTX_BLOCK_ZONE_PRIVEE,
                                                id_block)
    if id_contexte_bloc is None:
        self.__db.insert_moodle_context(self.__config.constantes.niveau_ctx_bloc,
                                        PROFONDEUR_CTX_BLOCK_ZONE_PRIVEE,
                                        id_block)
        id_contexte_bloc = self.__db.get_id_context(self.__config.constantes.niveau_ctx_bloc,
                                                    PROFONDEUR_CTX_BLOCK_ZONE_PRIVEE,
                                                    id_block)

    # Mise a jour du path du contexte
    path_contexte_bloc = &#34;%s/%d&#34; % (path_contexte_zone_privee, id_contexte_bloc)
    self.__db.update_context_path(id_contexte_bloc, path_contexte_bloc)</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.list_contains_username"><code class="name flex">
<span>def <span class="ident">list_contains_username</span></span>(<span>self, ldap_users: List[<a title="synchromoodle.ldaputils.PersonneLdap" href="ldaputils.html#synchromoodle.ldaputils.PersonneLdap">PersonneLdap</a>], username: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Vérifie si une liste d'utilisateurs ldap contient un utilisateur via son username
:param ldap_users:
:param username:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_contains_username(self, ldap_users: List[PersonneLdap], username: str):
    &#34;&#34;&#34;
    Vérifie si une liste d&#39;utilisateurs ldap contient un utilisateur via son username
    :param ldap_users:
    :param username:
    :return:
    &#34;&#34;&#34;
    for ldap_user in ldap_users:
        if ldap_user.uid.lower() == username.lower():
            return True
    return False</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.mettre_a_jour_droits_enseignant"><code class="name flex">
<span>def <span class="ident">mettre_a_jour_droits_enseignant</span></span>(<span>self, enseignant_infos, id_enseignant, uais_autorises, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de mettre a jour les droits d'un enseignant.
Cette mise a jour consiste a :
- Supprimer les roles non autorises
- ajouter les roles
:param enseignant_infos:
:param id_enseignant:
:param uais_autorises:
:param log:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mettre_a_jour_droits_enseignant(self, enseignant_infos, id_enseignant, uais_autorises, log=getLogger()):
    &#34;&#34;&#34;
    Fonction permettant de mettre a jour les droits d&#39;un enseignant.
    Cette mise a jour consiste a :
      - Supprimer les roles non autorises
      - ajouter les roles
    :param enseignant_infos:
    :param id_enseignant:
    :param uais_autorises:
    :param log:
    :return:
    &#34;&#34;&#34;
    # Recuperation des themes autorises pour l&#39;enseignant
    themes_autorises = [uai_autorise.lower() for uai_autorise in uais_autorises]
    log.debug(&#34;Etablissements autorises pour l&#39;enseignant pour %s : %s&#34;,
              enseignant_infos, themes_autorises)

    #########################
    # ZONES PRIVEES
    #########################
    # Recuperation des ids des roles et les themes non autorises
    ids_roles_non_autorises, ids_themes_non_autorises = self.__db.get_ids_and_themes_not_allowed_roles(
        id_enseignant, themes_autorises)

    # Suppression des roles non autorises
    if ids_roles_non_autorises:
        self.__db.delete_roles(ids_roles_non_autorises)
        log.info(&#34;Suppression des rôles d&#39;enseignant pour %s dans les établissements %s&#34;
                 , enseignant_infos, str(ids_themes_non_autorises))
        log.info(&#34;Les seuls établissements autorisés pour cet enseignant sont %s&#34;, themes_autorises)

    #########################
    # FORUMS
    #########################
    # Recuperation des SIREN des etablissements dans lequel l&#39;enseignant travaille
    sirens = self.__db.get_descriptions_course_categories_by_themes(themes_autorises)

    # Shortname des forums associes
    # Ancien code : shortnames_forums = [ ( &#34;ZONE-PRIVEE-%s&#34; % str( siren ) ) for siren in sirens ]
    shortnames_forums = [&#34;ZONE-PRIVEE-%s&#34; % siren for siren in sirens]

    # Recuperation des roles sur les forums qui ne devraient plus exister
    ids_roles_non_autorises, forums_summaries = self.__db.get_ids_and_summaries_not_allowed_roles(id_enseignant,
                                                                                                  shortnames_forums)

    # Suppression des roles non autorises
    if ids_roles_non_autorises:
        # Suppression des roles
        self.__db.delete_roles(ids_roles_non_autorises)
        log.info(&#34;Suppression des rôles d&#39;enseignant pour %s sur les forum &#39;%s&#39; &#34;,
                 enseignant_infos, str(forums_summaries))
        log.info(&#34;Les seuls établissements autorisés pour cet enseignant sont &#39;%s&#39;&#34;, themes_autorises)</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.mise_a_jour_cohorte_interetab"><code class="name flex">
<span>def <span class="ident">mise_a_jour_cohorte_interetab</span></span>(<span>self, is_member_of, cohort_name, since_timestamp: datetime.datetime, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Met à jour la cohorte inter-etablissement.
:param is_member_of:
:param cohort_name:
:param since_timestamp:
:param log:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mise_a_jour_cohorte_interetab(self, is_member_of, cohort_name, since_timestamp: datetime.datetime,
                                  log=getLogger()):
    &#34;&#34;&#34;
    Met à jour la cohorte inter-etablissement.
    :param is_member_of:
    :param cohort_name:
    :param since_timestamp:
    :param log:
    :return:
    &#34;&#34;&#34;
    # Creation de la cohort si necessaire
    self.get_or_create_cohort(self.context.id_context_categorie_inter_etabs, cohort_name, cohort_name,
                              cohort_name, self.context.timestamp_now_sql, log=log)
    id_cohort = self.__db.get_id_cohort(self.context.id_context_categorie_inter_etabs, cohort_name)

    # Liste permettant de sauvegarder les utilisateurs de la cohorte
    self.context.utilisateurs_by_cohortes[id_cohort] = []

    # Recuperation des utilisateurs
    is_member_of_list = [is_member_of]

    # Ajout des utilisateurs dans la cohorte
    for personne_ldap in self.__ldap.search_personne(
            since_timestamp = since_timestamp,
            isMemberOf = is_member_of_list):
        user_id = self.__db.get_user_id(personne_ldap.uid)
        if user_id:
            self.__db.enroll_user_in_cohort(id_cohort, user_id, self.context.timestamp_now_sql)
            # Mise a jour des utilisateurs de la cohorte
            self.context.utilisateurs_by_cohortes[id_cohort].append(user_id)
        else:
            log.warning(&#34;Impossible d&#39;inserer l&#39;utilisateur %s dans la cohorte %s, &#34;
                        &#34;car il n&#39;est pas connu dans Moodle&#34;, personne_ldap, cohort_name)</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.purge_cohort_dane_elv_lycee_en"><code class="name flex">
<span>def <span class="ident">purge_cohort_dane_elv_lycee_en</span></span>(<span>self, elv_lycee_en_ldap: list) ‑> list</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def purge_cohort_dane_elv_lycee_en(self, elv_lycee_en_ldap: list) -&gt; list:

    #Si on a des établissements dane
    if self.ids_cohorts_dane_lycee_en != {}:

        # Récupération des username des utilisateurs de la cohorte en db
        elv_lycee_en_db = self.__db.get_cohort_members(self.ids_cohorts_dane_lycee_en[UserType.ELEVE])
        # Liste des users désenrollé
        disenrolled_users = []

        # Boucle sur chaques user en db et le désenrole si il n&#39;est pas rpésent dans le ldap
        for username_db in elv_lycee_en_db:
            if username_db not in elv_lycee_en_ldap:
                log.info(&#34;Désenrollement de l&#39;utilisateur %s de la cohorte dane elv_lycee_en&#34;, username_db)
                self.__db.disenroll_user_from_username_and_cohortid(username_db, sself.ids_cohorts_dane_lycee_en[UserType.ELEVE])
                disenrolled_users.append(username_db)

        # On retourne un dictionnaire des utilisateurs désenrolé par cohortes
        return disenrolled_users</code></pre>
</details>
</dd>
<dt id="synchromoodle.synchronizer.Synchronizer.purge_cohorts"><code class="name flex">
<span>def <span class="ident">purge_cohorts</span></span>(<span>self, users_by_cohorts_db: Dict[str, List[str]], users_by_cohorts_ldap: Dict[str, List[str]], cohortname_pattern: str, log=&lt;RootLogger root (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Vide les cohortes d'utilisateurs conformément à l'annuaire LDAP
:param users_by_cohorts_db:
:param users_by_cohorts_ldap:
:param cohortname_pattern:
:param log:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def purge_cohorts(self, users_by_cohorts_db: Dict[str, List[str]],
                  users_by_cohorts_ldap: Dict[str, List[str]],
                  cohortname_pattern: str,
                  log=getLogger()):
    &#34;&#34;&#34;
    Vide les cohortes d&#39;utilisateurs conformément à l&#39;annuaire LDAP
    :param users_by_cohorts_db:
    :param users_by_cohorts_ldap:
    :param cohortname_pattern:
    :param log:
    :return:
    &#34;&#34;&#34;
    disenrolled_users = {}
    # On boucle avec à chaque fois une cohorte et son tableau d&#39;élèves de la bdd
    for cohort_db, eleves_db in users_by_cohorts_db.items():
        # Calcul du nom complet de la cohorte
        cohortname = cohortname_pattern % cohort_db
        # Si la cohorte n&#39;est pas présente dans le ldap (ce qui ne doit pas être possible, au pire on a un tableau vide)
        #  On désenrole les users de la cohortes côté bdd
        if cohort_db not in users_by_cohorts_ldap.keys():
            for username_db in users_by_cohorts_db[cohort_db]:
                log.info(&#34;Désenrollement de l&#39;utilisateur %s de la cohorte \&#34;%s\&#34;&#34;, username_db, cohort_db)
                self.__db.disenroll_user_from_username_and_cohortname(username_db, cohortname)
                if cohort_db not in disenrolled_users.keys():
                    disenrolled_users[cohort_db] = []
                disenrolled_users[cohort_db].append(username_db)
        # Sinon, on test pour chaque user si il est présent, et si il est absent on le désenrole
        else:
            for username_db in eleves_db:
                if username_db not in users_by_cohorts_ldap[cohort_db]:
                    log.info(&#34;Désenrollement de l&#39;utilisateur %s de la cohorte \&#34;%s\&#34;&#34;, username_db, cohort_db)
                    self.__db.disenroll_user_from_username_and_cohortname(username_db, cohortname)
                    if cohort_db not in disenrolled_users.keys():
                        disenrolled_users[cohort_db] = []
                    disenrolled_users[cohort_db].append(username_db)

    # On retourne un dictionnaire des utilisateurs désenrolé par cohortes
    return disenrolled_users</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="synchromoodle.synchronizer.UserType"><code class="flex name class">
<span>class <span class="ident">UserType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserType(Enum):
    ELEVE = 1
    ENSEIGNANT = 2
    PERSONNEL_DE_DIRECTION = 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="synchromoodle.synchronizer.UserType.ELEVE"><code class="name">var <span class="ident">ELEVE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="synchromoodle.synchronizer.UserType.ENSEIGNANT"><code class="name">var <span class="ident">ENSEIGNANT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="synchromoodle.synchronizer.UserType.PERSONNEL_DE_DIRECTION"><code class="name">var <span class="ident">PERSONNEL_DE_DIRECTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="synchromoodle" href="index.html">synchromoodle</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="synchromoodle.synchronizer.est_grp_etab" href="#synchromoodle.synchronizer.est_grp_etab">est_grp_etab</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="synchromoodle.synchronizer.EtablissementContext" href="#synchromoodle.synchronizer.EtablissementContext">EtablissementContext</a></code></h4>
</li>
<li>
<h4><code><a title="synchromoodle.synchronizer.SyncContext" href="#synchromoodle.synchronizer.SyncContext">SyncContext</a></code></h4>
</li>
<li>
<h4><code><a title="synchromoodle.synchronizer.Synchronizer" href="#synchromoodle.synchronizer.Synchronizer">Synchronizer</a></code></h4>
<ul class="">
<li><code><a title="synchromoodle.synchronizer.Synchronizer.anonymize_or_delete_users" href="#synchromoodle.synchronizer.Synchronizer.anonymize_or_delete_users">anonymize_or_delete_users</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.backup_course" href="#synchromoodle.synchronizer.Synchronizer.backup_course">backup_course</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.check_and_process_user_courses" href="#synchromoodle.synchronizer.Synchronizer.check_and_process_user_courses">check_and_process_user_courses</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.construct_classe_to_niv_formation" href="#synchromoodle.synchronizer.Synchronizer.construct_classe_to_niv_formation">construct_classe_to_niv_formation</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.delete_courses" href="#synchromoodle.synchronizer.Synchronizer.delete_courses">delete_courses</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.delete_empty_cohorts" href="#synchromoodle.synchronizer.Synchronizer.delete_empty_cohorts">delete_empty_cohorts</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.delete_users" href="#synchromoodle.synchronizer.Synchronizer.delete_users">delete_users</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.get_or_create_classes_cohorts" href="#synchromoodle.synchronizer.Synchronizer.get_or_create_classes_cohorts">get_or_create_classes_cohorts</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.get_or_create_cohort" href="#synchromoodle.synchronizer.Synchronizer.get_or_create_cohort">get_or_create_cohort</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.get_or_create_dane_dep_clg_cohort" href="#synchromoodle.synchronizer.Synchronizer.get_or_create_dane_dep_clg_cohort">get_or_create_dane_dep_clg_cohort</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.get_or_create_dane_lycee_en_cohort" href="#synchromoodle.synchronizer.Synchronizer.get_or_create_dane_lycee_en_cohort">get_or_create_dane_lycee_en_cohort</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.get_or_create_formation_cohort" href="#synchromoodle.synchronizer.Synchronizer.get_or_create_formation_cohort">get_or_create_formation_cohort</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.get_or_create_niv_formation_cohorts" href="#synchromoodle.synchronizer.Synchronizer.get_or_create_niv_formation_cohorts">get_or_create_niv_formation_cohorts</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.get_or_create_profs_etab_cohort" href="#synchromoodle.synchronizer.Synchronizer.get_or_create_profs_etab_cohort">get_or_create_profs_etab_cohort</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.get_users_by_cohorts_comparators_eleves_classes" href="#synchromoodle.synchronizer.Synchronizer.get_users_by_cohorts_comparators_eleves_classes">get_users_by_cohorts_comparators_eleves_classes</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.get_users_by_cohorts_comparators_eleves_niveau" href="#synchromoodle.synchronizer.Synchronizer.get_users_by_cohorts_comparators_eleves_niveau">get_users_by_cohorts_comparators_eleves_niveau</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.get_users_by_cohorts_comparators_profs_classes" href="#synchromoodle.synchronizer.Synchronizer.get_users_by_cohorts_comparators_profs_classes">get_users_by_cohorts_comparators_profs_classes</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.get_users_by_cohorts_comparators_profs_etab" href="#synchromoodle.synchronizer.Synchronizer.get_users_by_cohorts_comparators_profs_etab">get_users_by_cohorts_comparators_profs_etab</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.get_users_by_cohorts_comparators_profs_niveau" href="#synchromoodle.synchronizer.Synchronizer.get_users_by_cohorts_comparators_profs_niveau">get_users_by_cohorts_comparators_profs_niveau</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.get_users_by_dane_cohorts" href="#synchromoodle.synchronizer.Synchronizer.get_users_by_dane_cohorts">get_users_by_dane_cohorts</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.handle_dane" href="#synchromoodle.synchronizer.Synchronizer.handle_dane">handle_dane</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.handle_eleve" href="#synchromoodle.synchronizer.Synchronizer.handle_eleve">handle_eleve</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.handle_enseignant" href="#synchromoodle.synchronizer.Synchronizer.handle_enseignant">handle_enseignant</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.handle_etablissement" href="#synchromoodle.synchronizer.Synchronizer.handle_etablissement">handle_etablissement</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.handle_inspecteur" href="#synchromoodle.synchronizer.Synchronizer.handle_inspecteur">handle_inspecteur</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.handle_user_interetab" href="#synchromoodle.synchronizer.Synchronizer.handle_user_interetab">handle_user_interetab</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.initialize" href="#synchromoodle.synchronizer.Synchronizer.initialize">initialize</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.insert_moodle_structure" href="#synchromoodle.synchronizer.Synchronizer.insert_moodle_structure">insert_moodle_structure</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.list_contains_username" href="#synchromoodle.synchronizer.Synchronizer.list_contains_username">list_contains_username</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.mettre_a_jour_droits_enseignant" href="#synchromoodle.synchronizer.Synchronizer.mettre_a_jour_droits_enseignant">mettre_a_jour_droits_enseignant</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.mise_a_jour_cohorte_interetab" href="#synchromoodle.synchronizer.Synchronizer.mise_a_jour_cohorte_interetab">mise_a_jour_cohorte_interetab</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.purge_cohort_dane_elv_lycee_en" href="#synchromoodle.synchronizer.Synchronizer.purge_cohort_dane_elv_lycee_en">purge_cohort_dane_elv_lycee_en</a></code></li>
<li><code><a title="synchromoodle.synchronizer.Synchronizer.purge_cohorts" href="#synchromoodle.synchronizer.Synchronizer.purge_cohorts">purge_cohorts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="synchromoodle.synchronizer.UserType" href="#synchromoodle.synchronizer.UserType">UserType</a></code></h4>
<ul class="">
<li><code><a title="synchromoodle.synchronizer.UserType.ELEVE" href="#synchromoodle.synchronizer.UserType.ELEVE">ELEVE</a></code></li>
<li><code><a title="synchromoodle.synchronizer.UserType.ENSEIGNANT" href="#synchromoodle.synchronizer.UserType.ENSEIGNANT">ENSEIGNANT</a></code></li>
<li><code><a title="synchromoodle.synchronizer.UserType.PERSONNEL_DE_DIRECTION" href="#synchromoodle.synchronizer.UserType.PERSONNEL_DE_DIRECTION">PERSONNEL_DE_DIRECTION</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>