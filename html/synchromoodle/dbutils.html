<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>synchromoodle.dbutils API documentation</title>
<meta name="description" content="Accès à la base de données Moodle" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>synchromoodle.dbutils</code></h1>
</header>
<section id="section-intro">
<p>Accès à la base de données Moodle</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># coding: utf-8
# pylint: disable=too-many-lines
&#34;&#34;&#34;
Accès à la base de données Moodle
&#34;&#34;&#34;

import mysql.connector
from mysql.connector import MySQLConnection
from mysql.connector.cursor import MySQLCursor

from synchromoodle.config import DatabaseConfig, ConstantesConfig

###############################################################################
# CONSTANTS
###############################################################################

#######################################
# CONTEXTES
#######################################
# Id du contexte systeme
ID_CONTEXT_SYSTEM = 1

# Profondeur pour le contexte etablissement
PROFONDEUR_CTX_ETAB = 2

# Profondeur pour le contexte du bloc de recherche de la zone privee
PROFONDEUR_CTX_BLOCK_ZONE_PRIVEE = 4

# Profondeur pour le contexte du module de la zone privee
PROFONDEUR_CTX_MODULE_ZONE_PRIVEE = 4

# Profondeur pour le contexte de la zone privee
PROFONDEUR_CTX_ZONE_PRIVEE = 3

#######################################
# COURS
#######################################

# Format pour la zone privee d&#39;un etablissement
COURSE_FORMAT_ZONE_PRIVEE = &#34;topics&#34;

# Fullname pour la zone privee d&#39;un etablissement
COURSE_FULLNAME_ZONE_PRIVEE = &#34;Zone privée&#34;

# Shortname pour la zone privee d&#39;un etablissement
# Le (%s) est reserve au siren de l&#39;etablissement
COURSE_SHORTNAME_ZONE_PRIVEE = &#34;ZONE-PRIVEE-%s&#34;

# Summary pour la zone privee d&#39;un etablissement
# Le (%s) est reserve a l&#39;organisation unit de l&#39;etablissement
COURSE_SUMMARY_ZONE_PRIVEE = &#34;Forum réservé au personnel éducatif de l&#39;établissement %s&#34;

# Visibilite pour la zone privee d&#39;un etablissement
COURSE_VISIBLE_ZONE_PRIVEE = 0

#######################################
# MODULE DE COURS
#######################################
# Nombre pour le module du forum dans la zone privee
COURSE_MODULES_MODULE = 5

#######################################
# ROLES
#######################################
# Enrol method =&gt; manual enrolment
ENROL_METHOD_MANUAL = &#34;manual&#34;

# Shortname du role admin local
SHORTNAME_ADMIN_LOCAL = &#34;adminlocal&#34;

# Shortname du role extended teacher
SHORTNAME_EXTENDED_TEACHER = &#34;extendedteacher&#34;

# Shortname du role advanced teacher
SHORTNAME_ADVANCED_TEACHER = &#34;advancedteacher&#34;

#######################################
# USER
#######################################
# Default authentication mode for a user
USER_AUTH = &#34;cas&#34;

# Default city for a user
USER_CITY = &#34;Non renseignée&#34;

# Default country for a user
USER_COUNTRY = &#34;FR&#34;

# Default language for a user
USER_LANG = &#34;fr&#34;

# Default moodle site for the user
# This field is a foreign key of the mdl_mnet_host
# Here &#34;3&#34; stands for the ID of lycees.netocentre.fr
USER_MNET_HOST_ID = 3


def array_to_safe_sql_list(elements, name=None):
    &#34;&#34;&#34;
    :param elements:
    :param name:
    :return:
    &#34;&#34;&#34;
    if name:
        format_strings = []
        params = {}
        for i, element in enumerate(elements):
            format_strings.append(&#39;%({name}_{i})s&#39;.format(name=name, i=i))
            params[&#39;{name}_{i}&#39;.format(name=name, i=i)] = element
        return &#39;,&#39;.join(format_strings), params
    format_strings = [&#39;%s&#39;] * len(elements)
    params = tuple(elements)
    return &#39;,&#39;.join(format_strings), params


class Cohort:
    &#34;&#34;&#34;
    Données associées à une cohorte.
    &#34;&#34;&#34;

    def __init__(self, cohortid=None, contextid=None,
                 name=None, idnumber=None,
                 description=None, descriptionformat=None,
                 visible=None, component=None,
                 timecreated=None, timemodified=None,
                 theme=None):
        self.id = cohortid
        self.contextid = contextid
        self.name = name
        self.idnumber = idnumber
        self.description = description
        self.descriptionformat = descriptionformat
        self.visible = visible
        self.component = component
        self.timecreated = timecreated
        self.timemodified = timemodified
        self.theme = theme


class Database:
    &#34;&#34;&#34;
    Couche d&#39;accès à la base de données Moodle.
    &#34;&#34;&#34;
    config = None  # type: DatabaseConfig
    constantes = None  # type: ConstantesConfig
    connection = None  # type: MySQLConnection
    mark = None  # type: MySQLCursor
    entete = None  # type: str

    def __init__(self, config: DatabaseConfig, constantes: ConstantesConfig):
        self.config = config
        self.constantes = constantes
        self.entete = config.entete

    def connect(self):
        &#34;&#34;&#34;
        Etablit la connexion à la base de données Moodle
        :return:
        &#34;&#34;&#34;
        self.connection = mysql.connector.connect(host=self.config.host,
                                                  user=self.config.user,
                                                  passwd=self.config.password,
                                                  db=self.config.database,
                                                  charset=self.config.charset,
                                                  port=self.config.port)
        self.mark = self.connection.cursor()

    def disconnect(self):
        &#34;&#34;&#34;
        Ferme la connexion à la base de données Moodle
        :return:
        &#34;&#34;&#34;
        if self.mark:
            self.mark.close()
            self.mark = None
        if self.connection:
            self.connection.close()
            self.connection = None

    def safe_fetchone(self):
        &#34;&#34;&#34;
        Retourne uniquement 1 résultat et lève une exception si la requête invoquée récupère plusieurs resultats
        :return:
        &#34;&#34;&#34;
        rows = self.mark.fetchall()
        count = len(rows)
        if count &gt; 1:
            raise mysql.connector.DatabaseError(&#34;Résultat de requête SQL invalide: 1 résultat attendu, %d reçus:\n%s&#34;
                                                % (count, self.mark.statement))
        return rows[0] if count == 1 else None

    def add_role_to_user(self, role_id, id_context, id_user):
        &#34;&#34;&#34;
        Fonction permettant d&#39;ajouter un role a un utilisateur
        pour un contexte donne
        :param role_id: int
        :param id_context: int
        :param id_user: int
        :return:
        &#34;&#34;&#34;
        id_role_assignment = self.get_id_role_assignment(role_id, id_context, id_user)
        if not id_role_assignment:
            # Ajout du role dans le contexte
            s = &#34;INSERT INTO {entete}role_assignments( roleid, contextid, userid )&#34; \
                &#34; VALUES ( %(role_id)s, %(id_context)s, %(id_user)s )&#34;.format(entete=self.entete)
            self.mark.execute(s, params={&#39;role_id&#39;: role_id, &#39;id_context&#39;: id_context, &#39;id_user&#39;: id_user})

    def remove_role_to_user(self, role_id, id_context, id_user):
        &#34;&#34;&#34;
        Fonction permettant de supprimer un role a un utilisateur
        pour un contexte donne
        :param role_id: int
        :param id_context: int
        :param id_user: int
        :return:
        &#34;&#34;&#34;
        id_role_assignment = self.get_id_role_assignment(role_id, id_context, id_user)
        if id_role_assignment:
            # Ajout du role dans le contexte
            s = &#34;DELETE FROM {entete}role_assignments&#34; \
                &#34; WHERE roleid = %(role_id)s&#34; \
                &#34; AND contextid = %(id_context)s&#34; \
                &#34; AND userid = %(id_user)s&#34;.format(entete=self.entete)
            self.mark.execute(s, params={&#39;role_id&#39;: role_id, &#39;id_context&#39;: id_context, &#39;id_user&#39;: id_user})

    def get_id_role_assignment(self, role_id, id_context, id_user):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un role
        assignement au sein de la BD moodle.
        :param role_id: int
        :param id_context: int
        :param id_user: int
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id FROM {entete}role_assignments&#34; \
            &#34; WHERE roleid = %(role_id)s AND contextid = %(id_context)s AND userid = %(id_user)s&#34; \
            &#34; LIMIT 1&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;role_id&#39;: role_id, &#39;id_context&#39;: id_context, &#39;id_user&#39;: id_user})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def add_role_to_user_for_contexts(self, role_id, ids_contexts_by_courses, id_user):
        &#34;&#34;&#34;
        Fonction permettant d&#39;ajouter un role a un utilisateur
        pour plusieurs contextes donnes
        :param role_id:
        :param ids_contexts_by_courses:
        :param id_user:
        :return:
        &#34;&#34;&#34;
        for id_course, id_context in ids_contexts_by_courses.iteritems():
            self.add_role_to_user(role_id, id_context, id_user)
            self.enroll_user_in_course(role_id, id_course, id_user)

    def enroll_user_in_course(self, role_id, id_course, id_user):
        &#34;&#34;&#34;
        Fonction permettant d&#39;enroler un utilisateur dans un cours
        :param role_id: L&#39;id du rôle à donner à l&#39;utilisateur dans le cours
        :param id_course: L&#39;id du cours dans lequel on veut inscrire l&#39;utilisateur
        :param id_user: L&#39;id de l&#39;utilisateur à inscrire
        :return:
        &#34;&#34;&#34;
        id_enrol = self.get_id_enrol(ENROL_METHOD_MANUAL, role_id, id_course)
        if not id_enrol:
            # Ajout de la methode d&#39;enrolment dans le cours
            s = &#34;INSERT INTO {entete}enrol(enrol, courseid, roleid)&#34; \
                &#34; VALUES (%(ENROL_METHOD_MANUAL)s, %(id_course)s, %(role_id)s)&#34; \
                .format(entete=self.entete)
            self.mark.execute(s, params={&#39;ENROL_METHOD_MANUAL&#39;: ENROL_METHOD_MANUAL, &#39;id_course&#39;: id_course,
                                         &#39;role_id&#39;: role_id})
            id_enrol = self.get_id_enrol_max()
        if id_enrol:
            # Enrolement de l&#39;utilisateur dans le cours
            s = &#34;INSERT IGNORE INTO {entete}user_enrolments(enrolid, userid)&#34; \
                &#34; VALUES (%(id_enrol)s, %(id_user)s)&#34; \
                .format(entete=self.entete)
            self.mark.execute(s, params={&#39;id_enrol&#39;: id_enrol, &#39;id_user&#39;: id_user})

    def get_id_enrol_max(self):
        &#34;&#34;&#34;
        Récupère l&#39;id maximum present dans la table permettant les enrolments
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id FROM {entete}enrol&#34; \
            &#34; ORDER BY id DESC LIMIT 1&#34; \
            .format(entete=self.entete)
        self.mark.execute(s)
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def create_cohort(self, id_context, name, id_number, description, time_created):
        &#34;&#34;&#34;
        Fonction permettant de creer une nouvelle cohorte pour
        un contexte donne.
        :param id_context:
        :param name:
        :param id_number:
        :param description:
        :param time_created:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}cohort(contextid, name, idnumber, description, descriptionformat, timecreated,&#34; \
            &#34; timemodified)&#34; \
            &#34; VALUES (%(id_context)s, %(name)s, %(id_number)s, %(description)s, 0, %(time_created)s,&#34; \
            &#34; %(time_created)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_context&#39;: id_context, &#39;name&#39;: name, &#39;id_number&#39;: id_number,
                                     &#39;description&#39;: description, &#39;time_created&#39;: time_created})

    def disenroll_user_from_username_and_cohortname(self, username, cohortname):
        &#34;&#34;&#34;
        Désenrole un utilisateur d&#39;une cohorte.
        :param username:
        :param cohortname:
        :return:
        &#34;&#34;&#34;
        self.mark.execute(&#34;DELETE {entete}cohort_members FROM {entete}cohort_members&#34;
                          &#34; INNER JOIN {entete}cohort&#34;
                          &#34; ON {entete}cohort_members.cohortid = {entete}cohort.id&#34;
                          &#34; INNER JOIN {entete}user&#34;
                          &#34; ON {entete}cohort_members.userid = {entete}user.id&#34;
                          &#34; WHERE {entete}user.username = %(username)s&#34;
                          &#34; AND {entete}cohort.name = %(cohortname)s&#34;.format(entete=self.entete),
                          params={
                              &#39;username&#39;: username,
                              &#39;cohortname&#39;: cohortname
                          })

    def disenroll_user_from_username_and_cohortid(self, username: str, cohortid):
        &#34;&#34;&#34;
        Désenrole un utilisateur d&#39;une cohorte.
        :param username:
        :param cohortid:
        :return:
        &#34;&#34;&#34;
        self.mark.execute(&#34;DELETE {entete}cohort_members FROM {entete}cohort_members&#34;
                          &#34; INNER JOIN {entete}cohort&#34;
                          &#34; ON {entete}cohort_members.cohortid = {entete}cohort.id&#34;
                          &#34; INNER JOIN {entete}user&#34;
                          &#34; ON {entete}cohort_members.userid = {entete}user.id&#34;
                          &#34; WHERE {entete}user.username = %(username)s&#34;
                          &#34; AND {entete}cohort.id = %(cohortid)s&#34;.format(entete=self.entete),
                          params={
                              &#39;username&#39;: username,
                              &#39;cohortid&#39;: cohortid
                          })

    def get_empty_cohorts(self):
        &#34;&#34;&#34;
        Retourne la liste des ids de toutes les cohortes qui n&#39;ont aucun membre
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id FROM {entete}cohort WHERE id NOT IN (SELECT cohortid FROM {entete}cohort_members)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s)
        result_set = self.mark.fetchall()
        if not result_set:
            return []
        cohort_ids = [result[0] for result in result_set]
        return cohort_ids

    def get_id_cohort(self, id_context, cohort_name):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;une cohorte
        par son nom et son contexte de rattachement.
        :param id_context:
        :param cohort_name:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}cohort&#34; \
            &#34; WHERE contextid = %(id_context)s&#34; \
            &#34; AND name = %(cohort_name)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_context&#39;: id_context, &#39;cohort_name&#39;: cohort_name})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_user_id(self, username):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un
        utilisateur moodle via son username.
        :param username: str
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id FROM {entete}user &#34; \
            &#34;WHERE username = %(username)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;username&#39;: username.lower()})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def enroll_user_in_cohort(self, id_cohort, id_user, time_added):
        &#34;&#34;&#34;
        Fonction permettant d&#39;ajouter un utilisateur a une
        cohorte.
        :param id_cohort:
        :param id_user:
        :param time_added:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT IGNORE&#34; \
            &#34; INTO {entete}cohort_members(cohortid, userid, timeadded)&#34; \
            &#34; VALUES (%(id_cohort)s, %(id_user)s, %(time_added)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_cohort&#39;: id_cohort, &#39;id_user&#39;: id_user, &#39;time_added&#39;: time_added})

    def purge_cohort_profs(self, id_cohort, list_profs):
        &#34;&#34;&#34;
        fonction permettant la purge d&#39;une cohort de profs
        :param id_cohort:
        :param list_profs:
        :return:
        &#34;&#34;&#34;
        ids_list, ids_list_params = array_to_safe_sql_list(list_profs, &#39;ids_list&#39;)
        s = &#34;DELETE FROM {entete}cohort_members&#34; \
            &#34; WHERE cohortid = %(id_cohort)s&#34; \
            &#34; AND userid NOT IN ({ids_list})&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={&#39;id_cohort&#39;: id_cohort, **ids_list_params})

    def delete_moodle_local_admins(self, id_context_categorie, ids_not_admin):
        &#34;&#34;&#34;
        Fonction permettant de supprimer les admins locaux
        d&#39;un contexte en gardant uniquement les admins specifies.
        :param id_context_categorie:
        :param ids_not_admin:
        :return:
        &#34;&#34;&#34;
        if not ids_not_admin:
            return
        # Construction de la liste des ids admins a conserver
        ids_list, ids_list_params = array_to_safe_sql_list(ids_not_admin, &#39;ids_list&#39;)
        # Recuperation de l&#39;id pour le role d&#39;admin local
        id_role_admin_local = self.get_id_role_admin_local()
        # Suppression des admins non presents dans la liste
        s = &#34;DELETE FROM {entete}role_assignments&#34; \
            &#34; WHERE roleid = %(id_role_admin_local)s&#34; \
            &#34; AND contextid = %(id_context_categorie)s&#34; \
            &#34; AND userid IN ({ids_list})&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={&#39;id_role_admin_local&#39;: id_role_admin_local,
                                     &#39;id_context_categorie&#39;: id_context_categorie, **ids_list_params})

    def get_id_role_admin_local(self):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id du role admin local
        au sein de la BD moodle.
        :return:
        &#34;&#34;&#34;
        return self.get_id_role_by_shortname(SHORTNAME_ADMIN_LOCAL)

    def get_id_role_by_shortname(self, short_name):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un role via son shortname
        :param short_name:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id FROM {entete}role&#34; \
            &#34; WHERE shortname = %(short_name)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;short_name&#39;: short_name})
        ligne = self.safe_fetchone()
        if ligne is None:
            raise ValueError(&#34;Le rôle %s n&#39;existe pas.&#34; % short_name)
        return ligne[0]

    def delete_moodle_local_admin(self, id_context_categorie, userid):
        &#34;&#34;&#34;
        Fonction permettant de supprimer les admins locaux
        d&#39;un contexte en gardant uniquement les admins specifies.
        :param id_context_categorie:
        :param userid:
        :return:
        &#34;&#34;&#34;
        id_role_admin_local = self.get_id_role_admin_local()
        self.delete_moodle_assignment(id_context_categorie, userid, id_role_admin_local)

    def delete_moodle_assignment(self, id_context_category, userid, roleid):
        &#34;&#34;&#34;
        Fonction permettant de supprimer un role à un utilisateur
        dans un contexte
        :param id_context_category:
        :param userid:
        :param roleid:
        :return:
        &#34;&#34;&#34;
        s = &#34;DELETE FROM {entete}role_assignments&#34; \
            &#34; WHERE contextid = %(id_context_category)s&#34; \
            &#34; AND roleid = %(roleid)s&#34; \
            &#34; AND userid = %(userid)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_context_category&#39;: id_context_category, &#39;roleid&#39;: roleid, &#39;userid&#39;: userid})

    def delete_role_for_contexts(self, role_id, ids_contexts_by_courses, id_user):
        &#34;&#34;&#34;
        Fonction permettant de supprimer un role sur differents
        contextes pour l&#39;utilisateur specifie.
        :param role_id:
        :param ids_contexts_by_courses:
        :param id_user:
        :return:
        &#34;&#34;&#34;
        # Suppression des enrolments dans les cours
        for id_course in ids_contexts_by_courses:
            # Recuperation de la methode d&#39;enrolment
            id_enrol = self.get_id_enrol(ENROL_METHOD_MANUAL, role_id, id_course)
            if not id_enrol:
                continue
            # Suppression de l&#39;enrolment associe
            id_user_enrolment = self.get_id_user_enrolment(id_enrol, id_user)
            if id_user_enrolment:
                s = &#34;DELETE FROM {entete}user_enrolments &#34; \
                    &#34;WHERE id = %(id_user_enrolment)s&#34; \
                    .format(entete=self.entete)
                self.mark.execute(s, params={&#39;id_user_enrolment&#39;: id_user_enrolment})

        # Suppression des roles dans les contextes
        ids_list, ids_list_params = array_to_safe_sql_list(ids_contexts_by_courses.values(), &#39;ids_list&#39;)
        s = &#34;DELETE FROM {entete}role_assignments&#34; \
            &#34; WHERE roleid = %(role_id)s&#34; \
            &#34; AND contextid IN ({ids_list})&#34; \
            &#34; AND userid = %(id_user)s&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={&#39;role_id&#39;: role_id, &#39;id_user&#39;: id_user, **ids_list_params})

    def get_id_enrol(self, enrol_method, role_id, id_course):
        &#34;&#34;&#34;
        Fonction permettant de recuperer un id
        dans la table permettant les enrolments
        :param enrol_method:
        :param role_id:
        :param id_course:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT e.id FROM {entete}enrol AS e&#34; \
            &#34; WHERE e.enrol = %(enrol_method)s&#34; \
            &#34; AND e.courseid = %(id_course)s&#34; \
            &#34; AND e.roleid = %(role_id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;enrol_method&#39;: enrol_method, &#39;id_course&#39;: id_course, &#39;role_id&#39;: role_id})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_user_enrolment(self, id_enrol, id_user):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un user enrolment
        :param id_enrol:
        :param id_user:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}user_enrolments &#34; \
            &#34; WHERE userid = %(id_user)s&#34; \
            &#34; AND enrolid = %(id_enrol)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_user&#39;: id_user, &#39;id_enrol&#39;: id_enrol})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def delete_roles(self, ids_roles):
        &#34;&#34;&#34;
        Fonction permettant de supprimer des roles.
        :param ids_roles:
        :return:
        &#34;&#34;&#34;
        # Construction de la liste des ids des roles concernes
        ids_list, ids_list_params = array_to_safe_sql_list(ids_roles, &#39;ids_list&#39;)
        s = &#34;DELETE FROM {entete}role_assignments&#34; \
            &#34; WHERE id IN ({ids_list})&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={**ids_list_params})

    def disenroll_user_from_cohorts(self, ids_cohorts_to_keep, id_user):
        &#34;&#34;&#34;
        Fonction permettant d&#39;enlever un utilisateur d&#39;une
        ou plusieurs cohortes.
        Seules les inscriptions dans les cohortes passees en
        parametres sont conservees.
        :param ids_cohorts_to_keep:
        :param id_user:
        :return:
        &#34;&#34;&#34;
        # Construction de la liste des ids des cohortes concernes
        ids_list, ids_list_params = array_to_safe_sql_list(ids_cohorts_to_keep, &#39;ids_list&#39;)
        s = &#34;DELETE FROM {entete}cohort_members&#34; \
            &#34; WHERE userid = %(id_user)s&#34; \
            &#34; AND cohortid NOT IN ({ids_list})&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={&#39;id_user&#39;: id_user, **ids_list_params})

    def disenroll_user_from_cohort(self, id_cohort, id_user):
        &#34;&#34;&#34;
        Fonction permettant d&#39;enlever un utilisateur d&#39;une
        cohorte.
        :param id_cohort:
        :param id_user:
        :return:
        &#34;&#34;&#34;
        s = &#34;DELETE FROM {entete}cohort_members&#34; \
            &#34; WHERE cohortid = %(id_cohort)s&#34; \
            &#34; AND userid = %(id_user)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_cohort&#39;: id_cohort, &#39;id_user&#39;: id_user})

    def get_cohort_name(self, id_cohort):
        &#34;&#34;&#34;
        Fonction permettant de recuperer le nom d&#39;une cohorte.
        :param id_cohort:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT name FROM {entete}cohort&#34; \
            &#34; WHERE id = %(id_cohort)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_cohort&#39;: id_cohort})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_description_course_category(self, id_category):
        &#34;&#34;&#34;
        Fonction permettant de recuperer la description d&#39;une
        categorie.
        :param id_category:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT description&#34; \
            &#34; FROM {entete}course_categories&#34; \
            &#34; WHERE id = %(id_category)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_category&#39;: id_category})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_descriptions_course_categories_by_themes(self, themes):
        &#34;&#34;&#34;
        Fonction permettant de recuperer les descriptions de categories.
        :param themes:
        :return:
        &#34;&#34;&#34;
        ids_list, ids_list_params = array_to_safe_sql_list(themes, &#39;ids_list&#39;)
        s = &#34;SELECT description&#34; \
            &#34; FROM {entete}course_categories&#34; \
            &#34; WHERE theme IN ({ids_list})&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={**ids_list_params})
        result_set = self.mark.fetchall()
        if not result_set:
            return []
        descriptions = [result[0] for result in result_set]
        return descriptions

    def get_id_block(self, parent_context_id):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un bloc.
        :param parent_context_id:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}block_instances&#34; \
            &#34; WHERE parentcontextid = %(parent_context_id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;parent_context_id&#39;: parent_context_id})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_course_timemodified(self, course_id: int):
        s = &#34;SELECT timemodified FROM {entete}course&#34; \
            &#34; WHERE id = %(course_id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;course_id&#39;: course_id})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def delete_course(self, course_id: int):
        s = &#34;DELETE FROM {entete}course WHERE id = %(course_id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={
            &#39;course_id&#39;: course_id
        })

    def get_courses_ids_owned_by(self, user_id: int):
        &#34;&#34;&#34;
        Recherche tous les cours dont l&#39;utilisateur est propriétaire
        :param user_id: L&#39;id de l&#39;utilisateur concerné
        :returns: La liste des cours dont l&#39;utilisateur est propriétaire
        &#34;&#34;&#34;
        s = &#34;SELECT instanceid FROM {entete}context AS context&#34; \
            &#34; INNER JOIN {entete}role_assignments AS role_assignments&#34; \
            &#34; ON context.id = role_assignments.contextid&#34; \
            &#34; WHERE role_assignments.userid = %(userid)s AND role_assignments.roleid = %(roleid)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id, &#39;roleid&#39;: self.constantes.id_role_proprietaire_cours})
        return self.mark.fetchall()

    def get_courses_ids_owned_or_teach(self, user_id: int):
        &#34;&#34;&#34;
        Retourne tous les cours auxquels participe un utilisateur
        en tant qu&#39;enseignant (role enseignant ou propriétaire de cours)
        :param user_id: L&#39;id de l&#39;utilisateur concerné
        :returns: La liste des cours dans lequel enseigne l&#39;utilisateur
        &#34;&#34;&#34;
        s = &#34;SELECT instanceid FROM {entete}context AS context&#34; \
            &#34; INNER JOIN {entete}role_assignments AS role_assignments&#34; \
            &#34; ON context.id = role_assignments.contextid&#34; \
            &#34; WHERE role_assignments.userid = %(userid)s AND (role_assignments.roleid = %(roleidowner)s&#34; \
            &#34; OR role_assignments.roleid = %(roleidteacher)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id, &#39;roleidowner&#39;: self.constantes.id_role_proprietaire_cours,
        &#39;roleidteacher&#39;: self.constantes.id_role_enseignant})
        return self.mark.fetchall()

    def get_userids_owner_of_course(self, course_id: int):
        &#34;&#34;&#34;
        Retourne tous les utilisateurs qui sont propriétaires d&#39;un cours
        :param course_id: L&#39;id du cours concerné
        :returns: La liste des utilisateurs propriétaires du cours
        &#34;&#34;&#34;
        s = &#34;SELECT userid FROM {entete}role_assignments AS role_assignments&#34; \
            &#34; INNER JOIN {entete}context AS context&#34; \
            &#34; ON role_assignments.contextid = context.id&#34; \
            &#34; WHERE context.instanceid = %(courseid)s AND role_assignments.roleid = %(roleid)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;courseid&#39;: course_id, &#39;roleid&#39;: self.constantes.id_role_proprietaire_cours})
        return self.mark.fetchall()

    def get_user_data(self, user_id: int):
        &#34;&#34;&#34;
        Retourne les informations détaillées sur un utilisateur (table mdl_user)
        :param user_id: L&#39;id de l&#39;utilisateur dont on veut récupére les infos
        :returns: Un tuple représentant la ligne récupérée depuis la BD
        &#34;&#34;&#34;
        s = &#34;SELECT * FROM {entete}user WHERE id = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        return self.mark.fetchone()

    def user_has_used_moodle(self, user_id: int):
        &#34;&#34;&#34;
        Indique si un utilisateur à déjà utilisé moodle, c&#39;est-à-dire s&#39;il s&#39;est déjà connecté
        :param user_id: L&#39;id de l&#39;utilisateur qu&#39;on veut vérifier
        :returns: Un booléen, qui vaut True si l&#39;utilisateur à déjà utilisé moodle, et False sinon
        &#34;&#34;&#34;
        s = &#34;SELECT lastlogin FROM {entete}user WHERE id = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        return self.mark.fetchone()[0] != 0

    def eleve_has_references(self, user_id: int):
        &#34;&#34;&#34;
        Indique si un élève dipose de références dans des exercices ou des notations moodle
        Les références comprennent :
        - des notes obtenues dans n&#39;importe quelle activité (historique de notes)
        - des réponses à une activité (feedback, test, consultation, sondage)
        - des participations à une activités (forum, chat)
        :param user_id: L&#39;id de l&#39;utilisateur qu&#39;on veut vérifier
        :returns: Un booléen à vrai si l&#39;utilisateur à des références, faux sinon
        &#34;&#34;&#34;

        #Dès qu&#39;on trouve une référence on renvoie True
        s = &#34;SELECT count(*) FROM {entete}forum_posts WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        s = &#34;SELECT count(*) FROM {entete}grade_grades_history WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        s = &#34;SELECT count(*) FROM {entete}feedback_completed WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        s = &#34;SELECT count(*) FROM {entete}chat_messages WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        s = &#34;SELECT count(*) FROM {entete}course_modules_completion WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        s = &#34;SELECT count(*) FROM {entete}quiz_attempts WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        s = &#34;SELECT count(*) FROM {entete}survey_answers WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        s = &#34;SELECT count(*) FROM {entete}choice_answers WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        #Si jamais on n&#39;a trouvé aucune référence, alors on peut renvoyer False
        return False

    def enseignant_has_references(self, user_id: int):
        &#34;&#34;&#34;
        Indique si un enseignant dipose de références dans des exercices ou des notations moodle
        Les références comprennent :
        - des notes qui ont été données à des étudiants dans des cours
        :param user_id: L&#39;id de l&#39;utilisateur qu&#39;on veut vérifier
        :returns: Un booléen à vrai si l&#39;utilisateur à des références, faux sinon
        &#34;&#34;&#34;
        s = &#34;SELECT count(*) FROM {entete}grade_grades_history WHERE loggeduser = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True
        return False

    def get_id_categorie(self, categorie_name):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id correspondant a la
        categorie inter-etablissements.
        :param categorie_name:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}course_categories&#34; \
            &#34; WHERE name = %(categorie_name)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;categorie_name&#39;: categorie_name})
        ligne = self.safe_fetchone()
        return ligne[0] if ligne else None

    def get_id_context_no_depth(self, context_level, instance_id):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un contexte via
        le niveau et l&#39;id de l&#39;instance associee.
        :param context_level:
        :param instance_id:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}context&#34; \
            &#34; WHERE contextlevel = %(context_level)s&#34; \
            &#34; AND instanceid = %(instance_id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;context_level&#39;: context_level, &#39;instance_id&#39;: instance_id})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_context(self, context_level, depth, instance_id):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un contexte via
        le niveau, la profondeur et l&#39;id de l&#39;instance associee.
        :param context_level:
        :param depth:
        :param instance_id:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}context&#34; \
            &#34; WHERE contextlevel = %(context_level)s&#34; \
            &#34; AND depth = %(depth)s&#34; \
            &#34; AND instanceid = %(instance_id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;context_level&#39;: context_level, &#39;depth&#39;: depth, &#39;instance_id&#39;: instance_id})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_context_categorie(self, id_etab_categorie):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;une contexte via
        l&#39;id d&#39;un etablissement.
        :param id_etab_categorie:
        :return:
        &#34;&#34;&#34;
        return self.get_id_context(self.constantes.niveau_ctx_categorie, 2, id_etab_categorie)

    def get_id_context_inter_etabs(self):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id du contexte de la categorie inter-etablissements
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}context&#34; \
            &#34; WHERE contextlevel = %(context_level)s&#34; \
            &#34; AND instanceid = %(instanceid)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;context_level&#39;: self.constantes.niveau_ctx_categorie,
                                     &#39;instanceid&#39;: self.constantes.id_instance_moodle})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_course_by_id_number(self, id_number):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un cours a partir de son idnumber.
        :param id_number:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}course&#34; \
            &#34; WHERE idnumber = %(id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id&#39;: id_number})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_course_category_by_id_number(self, id_number):
        &#34;&#34;&#34;
        Récupère l&#39;id d&#39;une categorie à partir de son idnumber.
        :param id_number:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}course_categories&#34; \
            &#34; WHERE idnumber&#34; \
            &#34; LIKE %(id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id&#39;: &#39;%&#39; + str(id_number) + &#39;%&#39;})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_course_category_by_theme(self, theme):
        &#34;&#34;&#34;
        Récupère l&#39;id d&#39;une categorie à partir de son theme.
        :param theme:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}course_categories&#34; \
            &#34; WHERE theme = %(theme)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;theme&#39;: theme})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_course_module(self, course):
        &#34;&#34;&#34;
        Récupère l&#39;id d&#39;un module de cours.
        :param course:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}course_modules&#34; \
            &#34; WHERE course = %(course)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;course&#39;: course})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_forum(self, course):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id du contexte propre
        a moodle.
        :param course:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}forum&#34; \
            &#34; WHERE course = %(course)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;course&#39;: course})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_user_info_data(self, id_user, id_field):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un info data via
        l&#39;id-user et l&#39;id_field
        :param id_user:
        :param id_field:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}user_info_data &#34; \
            &#34; WHERE userid = %(id_user)s&#34; \
            &#34; AND fieldid = %(id_field)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_user&#39;: id_user, &#39;id_field&#39;: id_field})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_user_info_field_by_shortname(self, short_name):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un info field via
        son shortname.
        :param short_name:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}user_info_field&#34; \
            &#34; WHERE shortname = %(short_name)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;short_name&#39;: short_name})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_ids_and_summaries_not_allowed_roles(self, id_user, allowed_forums_shortnames):
        &#34;&#34;&#34;
        Fonction permettant de recuperer les ids des roles non
        autorises sur les forums, ainsi que les non des forums
        sur lesquels portent ces roles.
        :param id_user:
        :param allowed_forums_shortnames:
        :return:
        &#34;&#34;&#34;
        # Construction de la liste des shortnames
        ids_list, ids_list_params = array_to_safe_sql_list(allowed_forums_shortnames, &#39;ids_list&#39;)
        s = &#34;SELECT mra.id, mco.summary&#34; \
            &#34; FROM {entete}course mco, {entete}role_assignments mra, {entete}context mc&#34; \
            &#34; WHERE mco.shortname LIKE &#39;ZONE-PRIVEE-%%&#39;&#34; \
            &#34; AND mco.shortname NOT IN ({ids_list})&#34; \
            &#34; AND mco.id = mc.instanceid&#34; \
            &#34; AND mc.contextlevel = 50&#34; \
            &#34; AND mc.id = mra.contextid&#34; \
            &#34; AND mra.userid = %(id_user)s&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={&#39;id_user&#39;: id_user, **ids_list_params})
        result_set = self.mark.fetchall()
        if not result_set:
            return [], []
        # Recuperation des ids et themes non autorises
        ids = [result[0] for result in result_set]
        summaries = [result[1] for result in result_set]
        return ids, summaries

    def get_ids_and_themes_not_allowed_roles(self, id_user, allowed_themes):
        &#34;&#34;&#34;
        Fonction permettant de recuperer les ids des roles qui ne sont pas autorises pour l&#39;utilisateur.
        :param id_user:
        :param allowed_themes:
        :return:
        &#34;&#34;&#34;
        # Construction de la liste des themes
        ids_list, ids_list_params = array_to_safe_sql_list(allowed_themes, &#39;ids_list&#39;)
        # Recuperation des roles sur les etablissements qui ne devraient plus exister
        # (quand le prof n&#39;est plus rattache aux etablissements)
        s = &#34;SELECT mra.id, mcc.theme&#34; \
            &#34; FROM {entete}course_categories mcc, {entete}context mc, {entete}role_assignments mra&#34; \
            &#34; WHERE mcc.theme NOT IN ({ids_list})&#34; \
            &#34; AND mcc.theme IS NOT NULL&#34; \
            &#34; AND mcc.id = mc.instanceid &#34; \
            &#34; AND mc.contextlevel = %(NIVEAU_CTX_CATEGORIE)s AND mc.depth = %(PROFONDEUR_CTX_ETAB)s&#34; \
            &#34; AND mc.id = mra.contextid&#34; \
            &#34; AND mra.userid = %(id_user)s&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={**ids_list_params, &#39;NIVEAU_CTX_CATEGORIE&#39;: self.constantes.niveau_ctx_categorie,
                                     &#39;PROFONDEUR_CTX_ETAB&#39;: PROFONDEUR_CTX_ETAB, &#39;id_user&#39;: id_user})
        result_set = self.mark.fetchall()
        if not result_set:
            return [], []
        # Recuperation des ids et themes non autorises
        ids = [result[0] for result in result_set]
        themes = [result[1] for result in result_set]
        return ids, themes

    def get_timestamp_now(self):
        &#34;&#34;&#34;
        Fonction permettant de recuperer le timestamp actuel.
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT UNIX_TIMESTAMP( now( ) ) - 3600*2&#34;
        self.mark.execute(s)
        now = self.mark.fetchone()[0]
        return now

    def get_users_ids(self, usernames):
        &#34;&#34;&#34;
        Fonction permettant de recuperer les ids des
        utilisateurs moodle via leurs usernames.
        :param usernames:
        :return:
        &#34;&#34;&#34;
        users_ids = []
        for username in usernames:
            user_id = self.get_user_id(username)
            users_ids.append(user_id)
        return users_ids

    def user_has_role(self, userid, roles_list):
        &#34;&#34;&#34;
        Vérifie si un utilisateur a au moins un role parmis une liste
        :param userid:
        :param roles_list:
        :return:
        &#34;&#34;&#34;
        ids_list, ids_list_params = array_to_safe_sql_list(roles_list, &#39;ids_list&#39;)
        self.mark.execute(&#34;SELECT COUNT(role.id)&#34;
                          &#34; FROM {entete}role AS role&#34;
                          &#34; INNER JOIN {entete}role_assignments AS role_assignments&#34;
                          &#34; ON role.id = role_assignments.roleid&#34;
                          &#34; WHERE role_assignments.userid = %(userid)s&#34;
                          &#34; AND role.id IN ({ids_list})&#34;.format(entete=self.entete, ids_list=ids_list),
                          params={
                              &#39;userid&#39;: userid,
                              **ids_list_params
                          })
        count = self.mark.fetchone()[0]
        return count &gt; 0

    def get_all_valid_users(self):
        &#34;&#34;&#34;
        Retourne tous les utilisateurs de la base de données qui ne sont pas marqués comme &#34;supprimés&#34;
        :return:
        &#34;&#34;&#34;
        self.mark.execute(&#34;SELECT&#34;
                          &#34; id AS id,&#34;
                          &#34; username AS username,&#34;
                          &#34; lastlogin AS lastlogin&#34;
                          &#34; FROM {entete}user WHERE deleted = 0&#34;.format(entete=self.entete))
        return self.mark.fetchall()

    def anonymize_users(self, user_ids):
        &#34;&#34;&#34;
        Anonymise des utilisateurs de la BDD
        :param user_ids: La liste des id à anonymiser
        :return:
        &#34;&#34;&#34;

        ids_list, ids_list_params = array_to_safe_sql_list(user_ids, &#39;ids_list&#39;)
        self.mark.execute(&#34;UPDATE {entete}user&#34;
                          &#34; SET firstname = %(anonymous_name)s,&#34;
                          &#34; lastname = %(anonymous_name)s,&#34;
                          &#34; firstnamephonetic = %(anonymous_name)s,&#34;
                          &#34; lastnamephonetic = %(anonymous_name)s,&#34;
                          &#34; middlename = %(anonymous_name)s,&#34;
                          &#34; alternatename = %(anonymous_name)s,&#34;
                          &#34; city = %(anonymous_name)s,&#34;
                          &#34; address = %(anonymous_name)s,&#34;
                          &#34; department = %(anonymous_name)s,&#34;
                          &#34; phone1 = %(anonymous_phone)s,&#34;
                          &#34; phone2 = %(anonymous_phone)s,&#34;
                          &#34; skype = %(anonymous_name)s,&#34;
                          &#34; yahoo = %(anonymous_name)s,&#34;
                          &#34; aim = %(anonymous_name)s,&#34;
                          &#34; msn = %(anonymous_name)s,&#34;
                          &#34; email = %(anonymous_mail)s,&#34;
                          &#34; description = NULL&#34;
                          &#34; WHERE id IN ({ids_list})&#34;
                          .format(entete=self.entete, ids_list=ids_list),
                          params={
                              &#39;anonymous_name&#39;: self.constantes.anonymous_name,
                              &#39;anonymous_mail&#39;: self.constantes.anonymous_mail,
                              &#39;anonymous_phone&#39;: self.constantes.anonymous_phone,
                              **ids_list_params
                          })

    def insert_moodle_block(self, block_name, parent_context_id, show_in_subcontexts, page_type_pattern,
                            sub_page_pattern, default_region, default_weight):
        &#34;&#34;&#34;
        Insère un bloc.
        :param block_name:
        :param parent_context_id:
        :param show_in_subcontexts:
        :param page_type_pattern:
        :param sub_page_pattern:
        :param default_region:
        :param default_weight:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}block_instances &#34; \
            &#34;( blockname, parentcontextid, showinsubcontexts, pagetypepattern, subpagepattern, defaultregion, &#34; \
            &#34;defaultweight, timecreated, timemodified ) &#34; \
            &#34; VALUES ( %(block_name)s, %(parent_context_id)s, %(show_in_subcontexts)s, %(page_type_pattern)s, &#34; \
            &#34;%(sub_page_pattern)s, %(default_region)s, %(default_weight)s, UNIX_TIMESTAMP( now( ) ) - 3600*2,&#34; \
            &#34;UNIX_TIMESTAMP( now( ) ) - 3600*2 )&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;block_name&#39;: block_name,
                                     &#39;parent_context_id&#39;: parent_context_id,
                                     &#39;show_in_subcontexts&#39;: show_in_subcontexts,
                                     &#39;page_type_pattern&#39;: page_type_pattern,
                                     &#39;sub_page_pattern&#39;: sub_page_pattern,
                                     &#39;default_region&#39;: default_region,
                                     &#39;default_weight&#39;: default_weight})

    def insert_moodle_context(self, context_level, depth, instance_id):
        &#34;&#34;&#34;
        Insère un contexte.
        :param context_level:
        :param depth:
        :param instance_id:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}context (contextlevel, instanceid, depth)&#34; \
            &#34; VALUES (%(context_level)s, %(instance_id)s,  %(depth)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;context_level&#39;: context_level, &#39;instance_id&#39;: instance_id, &#39;depth&#39;: depth})

    def insert_moodle_course(self, id_category, full_name, id_number, short_name, summary, format_, visible,
                             start_date, time_created, time_modified):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer un cours.
        :param id_category:
        :param full_name:
        :param id_number:
        :param short_name:
        :param summary:
        :param format_:
        :param visible:
        :param start_date:
        :param time_created:
        :param time_modified:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}course &#34; \
            &#34;(category, fullname, idnumber, shortname, summary, &#34; \
            &#34;format, visible, startdate, timecreated, timemodified) &#34; \
            &#34; VALUES (%(id_category)s, %(full_name)s, %(id_number)s, %(short_name)s, %(summary)s, &#34; \
            &#34;%(format)s, %(visible)s, %(start_date)s, %(time_created)s, %(time_modified)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_category&#39;: id_category,
                                     &#39;full_name&#39;: full_name,
                                     &#39;id_number&#39;: id_number,
                                     &#39;short_name&#39;: short_name,
                                     &#39;summary&#39;: summary,
                                     &#39;format&#39;: format_,
                                     &#39;visible&#39;: visible,
                                     &#39;start_date&#39;: start_date,
                                     &#39;time_created&#39;: time_created,
                                     &#39;time_modified&#39;: time_modified})

    def insert_moodle_course_category(self, name, id_number, description, theme):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer une categorie.
        :param name:
        :param id_number:
        :param description:
        :param theme:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}course_categories&#34; \
            &#34; (name, idnumber, description, parent, sortorder, coursecount, visible, depth,theme)&#34; \
            &#34; VALUES(%(name)s, %(id_number)s, %(description)s, 0, 999,0, 1, 1, %(theme)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;name&#39;: name, &#39;id_number&#39;: id_number, &#39;description&#39;: description, &#39;theme&#39;: theme})

    def insert_moodle_course_module(self, course, module, instance, added):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer un module de cours.
        :param course:
        :param module:
        :param instance:
        :param added:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}course_modules (course, module, instance, added)&#34; \
            &#34; VALUES (%(course)s , %(module)s, %(instance)s , %(added)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;course&#39;: course, &#39;module&#39;: module, &#39;instance&#39;: instance, &#39;added&#39;: added})

    def insert_moodle_enrol_capability(self, enrol, status, course_id, role_id):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer une methode d&#39;inscription
        a un cours.
        :param enrol:
        :param status:
        :param course_id:
        :param role_id:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}enrol(enrol, status, courseid, roleid)&#34; \
            &#34; VALUES(%(enrol)s, %(status)s, %(course_id)s, %(role_id)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;enrol&#39;: enrol, &#39;status&#39;: status, &#39;course_id&#39;: course_id, &#39;role_id&#39;: role_id})

    def insert_moodle_forum(self, course, name, intro, intro_format, max_bytes, max_attachements, time_modified):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer un forum.
        :param course:
        :param name:
        :param intro:
        :param intro_format:
        :param max_bytes:
        :param max_attachements:
        :param time_modified:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}forum (course, name, intro, introformat, maxbytes, maxattachments, timemodified) &#34; \
            &#34;VALUES (%(course)s, %(name)s, %(intro)s, %(intro_format)s, %(max_bytes)s, %(max_attachements)s, &#34; \
            &#34;%(time_modified)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;course&#39;: course,
                                     &#39;name&#39;: name,
                                     &#39;intro&#39;: intro,
                                     &#39;intro_format&#39;: intro_format,
                                     &#39;max_bytes&#39;: max_bytes,
                                     &#39;max_attachements&#39;: max_attachements,
                                     &#39;time_modified&#39;: time_modified})

    def is_moodle_local_admin(self, id_context_categorie, id_user):
        &#34;&#34;&#34;
        Fonction permettant de vérifier si un utilisateur est
        admin local pour un contexte donne.
        :param id_context_categorie:
        :param id_user:
        :return:
        &#34;&#34;&#34;
        id_role_admin_local = self.get_id_role_admin_local()
        sql = &#34;SELECT COUNT(id) FROM {entete}role_assignments&#34; \
              &#34; WHERE roleid = %(id_role_admin_local)s&#34; \
              &#34; AND contextid = %(id_context_categorie)s&#34; \
              &#34; AND userid = %(id_user)s&#34; \
            .format(entete=self.entete)
        params = {&#39;id_role_admin_local&#39;: id_role_admin_local, &#39;id_context_categorie&#39;: id_context_categorie,
                  &#39;id_user&#39;: id_user}
        self.mark.execute(sql, params=params)
        result = self.safe_fetchone()
        is_local_admin = result[0] &gt; 0
        return is_local_admin

    def insert_moodle_local_admin(self, id_context_categorie, id_user):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer un admin local pour un
        contexte donne.
        Retour True si insertion réalisée, False le cas échéant
        :param id_context_categorie:
        :param id_user:
        :return:
        &#34;&#34;&#34;
        if self.is_moodle_local_admin(id_context_categorie, id_user):
            return False
        id_role_admin_local = self.get_id_role_admin_local()
        s = &#34;INSERT ignore INTO {entete}role_assignments(roleid, contextid, userid)&#34; \
            &#34; VALUES (%(id_role_admin_local)s, %(id_context_categorie)s, %(id_user)s)&#34; \
            .format(entete=self.entete)
        params = {&#39;id_role_admin_local&#39;: id_role_admin_local, &#39;id_context_categorie&#39;: id_context_categorie,
                  &#39;id_user&#39;: id_user}
        self.mark.execute(s, params=params)
        return True

    def insert_moodle_user(self, username, first_name, last_name, email, mail_display, theme):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer un utilisateur dans Moodle.
        :param username:
        :param first_name:
        :param last_name:
        :param email:
        :param mail_display:
        :param theme:
        :return:
        &#34;&#34;&#34;
        user_id = self.get_user_id(username)
        username = username.lower()
        if user_id is None:
            s = &#34;INSERT INTO {entete}user&#34; \
                &#34; (auth, confirmed, username, firstname, lastname, email, maildisplay, city, country, lang,&#34; \
                &#34; mnethostid, theme )&#34; \
                &#34; VALUES (%(auth)s, %(confirmed)s, %(username)s, %(firstname)s, %(lastname)s, %(email)s,&#34; \
                &#34; %(maildisplay)s, %(city)s, %(country)s, %(lang)s, %(mnethostid)s, %(theme)s)&#34; \
                .format(entete=self.entete)

            self.mark.execute(s, params={&#39;auth&#39;: USER_AUTH,
                                         &#39;confirmed&#39;: 1,
                                         &#39;username&#39;: username,
                                         &#39;firstname&#39;: first_name,
                                         &#39;lastname&#39;: last_name,
                                         &#39;email&#39;: email,
                                         &#39;maildisplay&#39;: mail_display,
                                         &#39;city&#39;: USER_CITY,
                                         &#39;country&#39;: USER_COUNTRY,
                                         &#39;lang&#39;: USER_LANG,
                                         &#39;mnethostid&#39;: USER_MNET_HOST_ID,
                                         &#39;theme&#39;: theme})

    def insert_moodle_user_info_data(self, id_user, id_field, data):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer un user info data.
        :param id_user:
        :param id_field:
        :param data:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}user_info_data (userid, fieldid, data)&#34; \
            &#34; VALUES (%(id_user)s, %(id_field)s, %(data)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_user&#39;: id_user, &#39;id_field&#39;: id_field, &#39;data&#39;: data})

    def insert_moodle_user_info_field(self, short_name, name, data_type, id_category, param1, param2, locked, visible):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer un user info field.
        :param short_name:
        :param name:
        :param data_type:
        :param id_category:
        :param param1:
        :param param2:
        :param locked:
        :param visible:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}user_info_field&#34; \
            &#34; (shortname, name, datatype, categoryid, param1, param2, locked, visible)&#34; \
            &#34; VALUES (%(short_name)s, %(name)s, %(data_type)s, %(id_category)s, %(param1)s, %(param2)s, %(locked)s,&#34; \
            &#34; %(visible)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;short_name&#39;: short_name,
                                     &#39;name&#39;: name,
                                     &#39;data_type&#39;: data_type,
                                     &#39;id_category&#39;: id_category,
                                     &#39;param1&#39;: param1,
                                     &#39;param2&#39;: param2,
                                     &#39;locked&#39;: locked,
                                     &#39;visible&#39;: visible})

    def insert_zone_privee(self, id_categorie_etablissement, siren, ou, time):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer le cours correspondant
        a la zone privee.
        :param id_categorie_etablissement:
        :param siren:
        :param ou:
        :param time:
        :return:
        &#34;&#34;&#34;
        full_name = COURSE_FULLNAME_ZONE_PRIVEE
        id_number = short_name = COURSE_SHORTNAME_ZONE_PRIVEE % siren
        summary = COURSE_SUMMARY_ZONE_PRIVEE % ou.encode(&#34;utf-8&#34;)
        format_ = COURSE_FORMAT_ZONE_PRIVEE
        visible = COURSE_VISIBLE_ZONE_PRIVEE
        start_date = time_created = time_modified = time
        id_zone_privee = self.get_id_course_by_id_number(id_number)
        if id_zone_privee is not None:
            return id_zone_privee
        self.insert_moodle_course(id_categorie_etablissement, full_name, id_number, short_name, summary, format_,
                                  visible, start_date, time_created, time_modified)
        id_zone_privee = self.get_id_course_by_id_number(id_number)
        return id_zone_privee

    def insert_zone_privee_context(self, id_zone_privee):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer le contexte correspondant
        a la zone privee.
        :param id_zone_privee:
        :return:
        &#34;&#34;&#34;
        id_contexte_zone_privee = self.get_id_context(self.constantes.niveau_ctx_cours, PROFONDEUR_CTX_ZONE_PRIVEE,
                                                      id_zone_privee)
        if id_contexte_zone_privee:
            return id_contexte_zone_privee

        id_contexte_zone_privee = self.get_id_context_no_depth(self.constantes.niveau_ctx_cours, id_zone_privee)
        if id_contexte_zone_privee:
            return id_contexte_zone_privee

        self.insert_moodle_context(self.constantes.niveau_ctx_cours, PROFONDEUR_CTX_ZONE_PRIVEE, id_zone_privee)
        id_contexte_zone_privee = self.get_id_context(self.constantes.niveau_ctx_cours, PROFONDEUR_CTX_ZONE_PRIVEE,
                                                      id_zone_privee)
        return id_contexte_zone_privee

    def purge_cohorts(self, users_ids_by_cohorts_ids):
        &#34;&#34;&#34;
        Fonction permettant de purger des cohortes.
        Le dictionnaire fourni en parametre indique la liste
        des ids utilisateurs appartenant a une cohorte.
        Ce dictionnaire est indexe par id de cohortes.
        :param users_ids_by_cohorts_ids:
        :return:
        &#34;&#34;&#34;
        for cohort_id, users_ids in users_ids_by_cohorts_ids.items():
            ids_list, ids_list_params = array_to_safe_sql_list(users_ids, &#39;ids_list&#39;)
            s = &#34;DELETE FROM {entete}cohort_members&#34; \
                &#34; WHERE cohortid = %(cohort_id)s&#34; \
                &#34; AND userid NOT IN ({ids_list})&#34; \
                .format(entete=self.entete, ids_list=ids_list)
            self.mark.execute(s, params={&#39;cohort_id&#39;: cohort_id, **ids_list_params})

    def get_user_filtered_cohorts(self, contextid, cohortname_pattern):
        &#34;&#34;&#34;
        Obtient les cohortes de classes d&#39;élèves
        :param contextid:
        :param cohortname_pattern:
        :return:
        &#34;&#34;&#34;
        self.mark.execute(&#34;SELECT id, contextid, name FROM {entete}cohort&#34;
                          &#34; WHERE contextid = %(contextid)s AND name LIKE %(like)s&#34;
                          .format(entete=self.entete),
                          params={
                              &#39;contextid&#39;: contextid,
                              &#39;like&#39;: cohortname_pattern
                          })
        return [Cohort(cohortid=result[0], contextid=result[1], name=result[2]) for result in self.mark.fetchall()]

    def get_cohort_members(self, cohortid) -&gt; list:
        &#34;&#34;&#34;
        Obtient les noms d&#39;utilisateurs membres de la cohorte.
        :param cohortid:
        :return: list de username
        &#34;&#34;&#34;
        self.mark.execute(&#34;SELECT {entete}user.username FROM {entete}cohort_members&#34;
                          &#34; INNER JOIN {entete}user ON {entete}cohort_members.userid = {entete}user.id&#34;
                          &#34; WHERE cohortid = %(cohortid)s&#34;
                          .format(entete=self.entete),
                          params={
                              &#39;cohortid&#39;: cohortid
                          })
        return map(lambda r: r[0], self.mark.fetchall())

    def update_context_path(self, id_context, new_path):
        &#34;&#34;&#34;
        Fonction permettant de mettre a jour le path d&#39;un contexte.
        :param id_context:
        :param new_path:
        :return:
        &#34;&#34;&#34;
        s = &#34;UPDATE {entete}context&#34; \
            &#34; SET path = %(new_path)s&#34; \
            &#34; WHERE id = %(id_context)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;new_path&#39;: new_path, &#39;id_context&#39;: id_context})

    def update_course_category_description(self, id_category, new_description):
        &#34;&#34;&#34;
        Fonction permettant de mettre a jour la description
        d&#39;une categorie.
        :param id_category:
        :param new_description:
        :return:
        &#34;&#34;&#34;
        s = &#34;UPDATE {entete}course_categories&#34; \
            &#34; SET description = %(new_description)s&#34; \
            &#34; WHERE id = %(id_category)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;new_description&#39;: new_description, &#39;id_category&#39;: id_category})

    def update_course_category_name(self, id_category, new_name):
        &#34;&#34;&#34;
        Fonction permettant de mettre a jour le nom
        d&#39;une categorie.
        :param id_category:
        :param new_name:
        :return:
        &#34;&#34;&#34;
        s = &#34;UPDATE {entete}course_categories&#34; \
            &#34; SET name = %(new_name)s&#34; \
            &#34; WHERE id = %(id_category)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;new_name&#39;: new_name, &#39;id_category&#39;: id_category})

    def update_course_category_path(self, id_category, new_path):
        &#34;&#34;&#34;
        Fonction permettant de mettre a jour le path d&#39;une
        categorie.
        :param id_category:
        :param new_path:
        :return:
        &#34;&#34;&#34;
        s = &#34;UPDATE {entete}course_categories&#34; \
            &#34; SET path = %(new_path)s&#34; \
            &#34; WHERE id = %(id_category)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;new_path&#39;: new_path, &#39;id_category&#39;: id_category})

    def update_moodle_user(self, id_user, first_name, last_name, email, mail_display, theme):
        &#34;&#34;&#34;
        Fonction permettant de mettre a jour un utilisateur
        :param id_user:
        :param first_name:
        :param last_name:
        :param email:
        :param mail_display:
        :param theme:
        :return:
        &#34;&#34;&#34;
        s = &#34;UPDATE {entete}user&#34; \
            &#34; SET auth = %(USER_AUTH)s, firstname = %(first_name)s, lastname = %(last_name)s, email = %(email)s,&#34; \
            &#34; maildisplay = %(mail_display)s, city = %(USER_CITY)s, country = %(USER_COUNTRY)s, lang = %(USER_LANG)s,&#34; \
            &#34; mnethostid = %(USER_MNET_HOST_ID)s, theme = %(theme)s&#34; \
            &#34; WHERE id = %(id_user)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;USER_AUTH&#39;: USER_AUTH,
                                     &#39;first_name&#39;: first_name,
                                     &#39;last_name&#39;: last_name,
                                     &#39;email&#39;: email,
                                     &#39;mail_display&#39;: mail_display,
                                     &#39;USER_CITY&#39;: USER_CITY,
                                     &#39;USER_COUNTRY&#39;: USER_COUNTRY,
                                     &#39;USER_LANG&#39;: USER_LANG,
                                     &#39;USER_MNET_HOST_ID&#39;: USER_MNET_HOST_ID,
                                     &#39;theme&#39;: theme,
                                     &#39;id_user&#39;: id_user})

    def update_user_info_data(self, id_user, id_field, new_data):
        &#34;&#34;&#34;
        Fonction permettant de mettre a jour le data d&#39;un user
        info data.
        :param id_user:
        :param id_field:
        :param new_data:
        :return:
        &#34;&#34;&#34;
        s = &#34;UPDATE {entete}user_info_data&#34; \
            &#34; SET data = %(new_data)s &#34; \
            &#34; WHERE userid = %(id_user)s&#34; \
            &#34; AND fieldid = %(id_field)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;new_data&#39;: new_data, &#39;id_user&#39;: id_user, &#39;id_field&#39;: id_field})

    def get_field_domaine(self):
        &#34;&#34;&#34;
        Fonction pour récupére l&#39;id du champ Domaine
        :return:
        &#34;&#34;&#34;
        id_field_domaine = []
        sql = &#34;SELECT id&#34; \
              &#34; FROM {entete}user_info_field&#34; \
              &#34; WHERE shortname = &#39;Domaine&#39;&#34; \
              &#34; AND name =&#39;Domaine&#39;&#34; \
            .format(entete=self.entete)
        self.mark.execute(sql)
        row = self.mark.fetchall()

        # Si le champ n&#39;existe pas, on le crée et on récupère l&#39;id
        if not bool(row):
            id_field_domaine = 0
        else:
            id_field_domaine = row[0][0]

        return id_field_domaine

    def is_enseignant_avance(self, id_user, id_role_enseignant_avance):
        &#34;&#34;&#34;
        :param id_user:
        :param id_role_enseignant_avance:
        :return:
        &#34;&#34;&#34;
        sql = &#34;SELECT COUNT(id)&#34; \
              &#34; FROM {entete}role_assignments&#34; \
              &#34; WHERE userid = %(id_user)s&#34; \
              &#34; AND roleid = %(id_role_enseignant_avance)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(sql, params={&#39;id_user&#39;: id_user, &#39;id_role_enseignant_avance&#39;: id_role_enseignant_avance})
        result = self.safe_fetchone()
        return result[0] &gt; 0

    def set_user_domain(self, id_user, id_field_domaine, user_domain):
        &#34;&#34;&#34;
        Fonction pour saisir le Domaine d&#39;un utilisateur Moodle
        :param id_user:
        :param id_field_domaine:
        :param user_domain:
        :return:
        &#34;&#34;&#34;
        # pour un utilisateur qui est déjà dans la table &#34;user_info_data&#34; mais sur un autre domaine que
        # le domaine &#34;user_domain&#34;,
        # le script va essayer de créer une nouvelle ligne (INSERT) avec le nouveau domaine =&gt; erreur !
        # la requête doit donc être modifiée :
        # sql = &#34;SELECT id FROM %suser_info_data WHERE userid = %s AND fieldid = %s AND data = &#39;%s&#39;&#34;
        sql = &#34;SELECT id&#34; \
              &#34; FROM {entete}user_info_data&#34; \
              &#34; WHERE userid = %(id_user)s&#34; \
              &#34; AND fieldid = %(id_field_domaine)s&#34; \
              &#34; LIMIT 1&#34; \
            .format(entete=self.entete)
        self.mark.execute(sql, params={&#39;id_user&#39;: id_user, &#39;id_field_domaine&#39;: id_field_domaine})

        result = self.safe_fetchone()
        if result:
            sql = &#34;REPLACE INTO {entete}user_info_data &#34; \
                  &#34;(id, userid, fieldid, data)&#34; \
                  &#34; VALUES (%(id)s, %(id_user)s, %(id_field_domaine)s, %(user_domain)s)&#34; \
                .format(entete=self.entete)
            self.mark.execute(sql, params={&#39;id&#39;: result[0],
                                           &#39;id_user&#39;: id_user,
                                           &#39;id_field_domaine&#39;: id_field_domaine,
                                           &#39;user_domain&#39;: user_domain})
        else:
            sql = &#34;INSERT INTO {entete}user_info_data &#34; \
                  &#34;(userid, fieldid, data)&#34; \
                  &#34; VALUES (%(id_user)s, %(id_field_domaine)s, %(user_domain)s)&#34; \
                .format(entete=self.entete)
            self.mark.execute(sql, params={&#39;id_user&#39;: id_user,
                                           &#39;id_field_domaine&#39;: id_field_domaine,
                                           &#39;user_domain&#39;: user_domain})</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="synchromoodle.dbutils.array_to_safe_sql_list"><code class="name flex">
<span>def <span class="ident">array_to_safe_sql_list</span></span>(<span>elements, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>:param elements:
:param name:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def array_to_safe_sql_list(elements, name=None):
    &#34;&#34;&#34;
    :param elements:
    :param name:
    :return:
    &#34;&#34;&#34;
    if name:
        format_strings = []
        params = {}
        for i, element in enumerate(elements):
            format_strings.append(&#39;%({name}_{i})s&#39;.format(name=name, i=i))
            params[&#39;{name}_{i}&#39;.format(name=name, i=i)] = element
        return &#39;,&#39;.join(format_strings), params
    format_strings = [&#39;%s&#39;] * len(elements)
    params = tuple(elements)
    return &#39;,&#39;.join(format_strings), params</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="synchromoodle.dbutils.Cohort"><code class="flex name class">
<span>class <span class="ident">Cohort</span></span>
<span>(</span><span>cohortid=None, contextid=None, name=None, idnumber=None, description=None, descriptionformat=None, visible=None, component=None, timecreated=None, timemodified=None, theme=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Données associées à une cohorte.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cohort:
    &#34;&#34;&#34;
    Données associées à une cohorte.
    &#34;&#34;&#34;

    def __init__(self, cohortid=None, contextid=None,
                 name=None, idnumber=None,
                 description=None, descriptionformat=None,
                 visible=None, component=None,
                 timecreated=None, timemodified=None,
                 theme=None):
        self.id = cohortid
        self.contextid = contextid
        self.name = name
        self.idnumber = idnumber
        self.description = description
        self.descriptionformat = descriptionformat
        self.visible = visible
        self.component = component
        self.timecreated = timecreated
        self.timemodified = timemodified
        self.theme = theme</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database"><code class="flex name class">
<span>class <span class="ident">Database</span></span>
<span>(</span><span>config: <a title="synchromoodle.config.DatabaseConfig" href="config.html#synchromoodle.config.DatabaseConfig">DatabaseConfig</a>, constantes: <a title="synchromoodle.config.ConstantesConfig" href="config.html#synchromoodle.config.ConstantesConfig">ConstantesConfig</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Couche d'accès à la base de données Moodle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Database:
    &#34;&#34;&#34;
    Couche d&#39;accès à la base de données Moodle.
    &#34;&#34;&#34;
    config = None  # type: DatabaseConfig
    constantes = None  # type: ConstantesConfig
    connection = None  # type: MySQLConnection
    mark = None  # type: MySQLCursor
    entete = None  # type: str

    def __init__(self, config: DatabaseConfig, constantes: ConstantesConfig):
        self.config = config
        self.constantes = constantes
        self.entete = config.entete

    def connect(self):
        &#34;&#34;&#34;
        Etablit la connexion à la base de données Moodle
        :return:
        &#34;&#34;&#34;
        self.connection = mysql.connector.connect(host=self.config.host,
                                                  user=self.config.user,
                                                  passwd=self.config.password,
                                                  db=self.config.database,
                                                  charset=self.config.charset,
                                                  port=self.config.port)
        self.mark = self.connection.cursor()

    def disconnect(self):
        &#34;&#34;&#34;
        Ferme la connexion à la base de données Moodle
        :return:
        &#34;&#34;&#34;
        if self.mark:
            self.mark.close()
            self.mark = None
        if self.connection:
            self.connection.close()
            self.connection = None

    def safe_fetchone(self):
        &#34;&#34;&#34;
        Retourne uniquement 1 résultat et lève une exception si la requête invoquée récupère plusieurs resultats
        :return:
        &#34;&#34;&#34;
        rows = self.mark.fetchall()
        count = len(rows)
        if count &gt; 1:
            raise mysql.connector.DatabaseError(&#34;Résultat de requête SQL invalide: 1 résultat attendu, %d reçus:\n%s&#34;
                                                % (count, self.mark.statement))
        return rows[0] if count == 1 else None

    def add_role_to_user(self, role_id, id_context, id_user):
        &#34;&#34;&#34;
        Fonction permettant d&#39;ajouter un role a un utilisateur
        pour un contexte donne
        :param role_id: int
        :param id_context: int
        :param id_user: int
        :return:
        &#34;&#34;&#34;
        id_role_assignment = self.get_id_role_assignment(role_id, id_context, id_user)
        if not id_role_assignment:
            # Ajout du role dans le contexte
            s = &#34;INSERT INTO {entete}role_assignments( roleid, contextid, userid )&#34; \
                &#34; VALUES ( %(role_id)s, %(id_context)s, %(id_user)s )&#34;.format(entete=self.entete)
            self.mark.execute(s, params={&#39;role_id&#39;: role_id, &#39;id_context&#39;: id_context, &#39;id_user&#39;: id_user})

    def remove_role_to_user(self, role_id, id_context, id_user):
        &#34;&#34;&#34;
        Fonction permettant de supprimer un role a un utilisateur
        pour un contexte donne
        :param role_id: int
        :param id_context: int
        :param id_user: int
        :return:
        &#34;&#34;&#34;
        id_role_assignment = self.get_id_role_assignment(role_id, id_context, id_user)
        if id_role_assignment:
            # Ajout du role dans le contexte
            s = &#34;DELETE FROM {entete}role_assignments&#34; \
                &#34; WHERE roleid = %(role_id)s&#34; \
                &#34; AND contextid = %(id_context)s&#34; \
                &#34; AND userid = %(id_user)s&#34;.format(entete=self.entete)
            self.mark.execute(s, params={&#39;role_id&#39;: role_id, &#39;id_context&#39;: id_context, &#39;id_user&#39;: id_user})

    def get_id_role_assignment(self, role_id, id_context, id_user):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un role
        assignement au sein de la BD moodle.
        :param role_id: int
        :param id_context: int
        :param id_user: int
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id FROM {entete}role_assignments&#34; \
            &#34; WHERE roleid = %(role_id)s AND contextid = %(id_context)s AND userid = %(id_user)s&#34; \
            &#34; LIMIT 1&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;role_id&#39;: role_id, &#39;id_context&#39;: id_context, &#39;id_user&#39;: id_user})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def add_role_to_user_for_contexts(self, role_id, ids_contexts_by_courses, id_user):
        &#34;&#34;&#34;
        Fonction permettant d&#39;ajouter un role a un utilisateur
        pour plusieurs contextes donnes
        :param role_id:
        :param ids_contexts_by_courses:
        :param id_user:
        :return:
        &#34;&#34;&#34;
        for id_course, id_context in ids_contexts_by_courses.iteritems():
            self.add_role_to_user(role_id, id_context, id_user)
            self.enroll_user_in_course(role_id, id_course, id_user)

    def enroll_user_in_course(self, role_id, id_course, id_user):
        &#34;&#34;&#34;
        Fonction permettant d&#39;enroler un utilisateur dans un cours
        :param role_id: L&#39;id du rôle à donner à l&#39;utilisateur dans le cours
        :param id_course: L&#39;id du cours dans lequel on veut inscrire l&#39;utilisateur
        :param id_user: L&#39;id de l&#39;utilisateur à inscrire
        :return:
        &#34;&#34;&#34;
        id_enrol = self.get_id_enrol(ENROL_METHOD_MANUAL, role_id, id_course)
        if not id_enrol:
            # Ajout de la methode d&#39;enrolment dans le cours
            s = &#34;INSERT INTO {entete}enrol(enrol, courseid, roleid)&#34; \
                &#34; VALUES (%(ENROL_METHOD_MANUAL)s, %(id_course)s, %(role_id)s)&#34; \
                .format(entete=self.entete)
            self.mark.execute(s, params={&#39;ENROL_METHOD_MANUAL&#39;: ENROL_METHOD_MANUAL, &#39;id_course&#39;: id_course,
                                         &#39;role_id&#39;: role_id})
            id_enrol = self.get_id_enrol_max()
        if id_enrol:
            # Enrolement de l&#39;utilisateur dans le cours
            s = &#34;INSERT IGNORE INTO {entete}user_enrolments(enrolid, userid)&#34; \
                &#34; VALUES (%(id_enrol)s, %(id_user)s)&#34; \
                .format(entete=self.entete)
            self.mark.execute(s, params={&#39;id_enrol&#39;: id_enrol, &#39;id_user&#39;: id_user})

    def get_id_enrol_max(self):
        &#34;&#34;&#34;
        Récupère l&#39;id maximum present dans la table permettant les enrolments
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id FROM {entete}enrol&#34; \
            &#34; ORDER BY id DESC LIMIT 1&#34; \
            .format(entete=self.entete)
        self.mark.execute(s)
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def create_cohort(self, id_context, name, id_number, description, time_created):
        &#34;&#34;&#34;
        Fonction permettant de creer une nouvelle cohorte pour
        un contexte donne.
        :param id_context:
        :param name:
        :param id_number:
        :param description:
        :param time_created:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}cohort(contextid, name, idnumber, description, descriptionformat, timecreated,&#34; \
            &#34; timemodified)&#34; \
            &#34; VALUES (%(id_context)s, %(name)s, %(id_number)s, %(description)s, 0, %(time_created)s,&#34; \
            &#34; %(time_created)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_context&#39;: id_context, &#39;name&#39;: name, &#39;id_number&#39;: id_number,
                                     &#39;description&#39;: description, &#39;time_created&#39;: time_created})

    def disenroll_user_from_username_and_cohortname(self, username, cohortname):
        &#34;&#34;&#34;
        Désenrole un utilisateur d&#39;une cohorte.
        :param username:
        :param cohortname:
        :return:
        &#34;&#34;&#34;
        self.mark.execute(&#34;DELETE {entete}cohort_members FROM {entete}cohort_members&#34;
                          &#34; INNER JOIN {entete}cohort&#34;
                          &#34; ON {entete}cohort_members.cohortid = {entete}cohort.id&#34;
                          &#34; INNER JOIN {entete}user&#34;
                          &#34; ON {entete}cohort_members.userid = {entete}user.id&#34;
                          &#34; WHERE {entete}user.username = %(username)s&#34;
                          &#34; AND {entete}cohort.name = %(cohortname)s&#34;.format(entete=self.entete),
                          params={
                              &#39;username&#39;: username,
                              &#39;cohortname&#39;: cohortname
                          })

    def disenroll_user_from_username_and_cohortid(self, username: str, cohortid):
        &#34;&#34;&#34;
        Désenrole un utilisateur d&#39;une cohorte.
        :param username:
        :param cohortid:
        :return:
        &#34;&#34;&#34;
        self.mark.execute(&#34;DELETE {entete}cohort_members FROM {entete}cohort_members&#34;
                          &#34; INNER JOIN {entete}cohort&#34;
                          &#34; ON {entete}cohort_members.cohortid = {entete}cohort.id&#34;
                          &#34; INNER JOIN {entete}user&#34;
                          &#34; ON {entete}cohort_members.userid = {entete}user.id&#34;
                          &#34; WHERE {entete}user.username = %(username)s&#34;
                          &#34; AND {entete}cohort.id = %(cohortid)s&#34;.format(entete=self.entete),
                          params={
                              &#39;username&#39;: username,
                              &#39;cohortid&#39;: cohortid
                          })

    def get_empty_cohorts(self):
        &#34;&#34;&#34;
        Retourne la liste des ids de toutes les cohortes qui n&#39;ont aucun membre
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id FROM {entete}cohort WHERE id NOT IN (SELECT cohortid FROM {entete}cohort_members)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s)
        result_set = self.mark.fetchall()
        if not result_set:
            return []
        cohort_ids = [result[0] for result in result_set]
        return cohort_ids

    def get_id_cohort(self, id_context, cohort_name):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;une cohorte
        par son nom et son contexte de rattachement.
        :param id_context:
        :param cohort_name:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}cohort&#34; \
            &#34; WHERE contextid = %(id_context)s&#34; \
            &#34; AND name = %(cohort_name)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_context&#39;: id_context, &#39;cohort_name&#39;: cohort_name})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_user_id(self, username):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un
        utilisateur moodle via son username.
        :param username: str
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id FROM {entete}user &#34; \
            &#34;WHERE username = %(username)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;username&#39;: username.lower()})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def enroll_user_in_cohort(self, id_cohort, id_user, time_added):
        &#34;&#34;&#34;
        Fonction permettant d&#39;ajouter un utilisateur a une
        cohorte.
        :param id_cohort:
        :param id_user:
        :param time_added:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT IGNORE&#34; \
            &#34; INTO {entete}cohort_members(cohortid, userid, timeadded)&#34; \
            &#34; VALUES (%(id_cohort)s, %(id_user)s, %(time_added)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_cohort&#39;: id_cohort, &#39;id_user&#39;: id_user, &#39;time_added&#39;: time_added})

    def purge_cohort_profs(self, id_cohort, list_profs):
        &#34;&#34;&#34;
        fonction permettant la purge d&#39;une cohort de profs
        :param id_cohort:
        :param list_profs:
        :return:
        &#34;&#34;&#34;
        ids_list, ids_list_params = array_to_safe_sql_list(list_profs, &#39;ids_list&#39;)
        s = &#34;DELETE FROM {entete}cohort_members&#34; \
            &#34; WHERE cohortid = %(id_cohort)s&#34; \
            &#34; AND userid NOT IN ({ids_list})&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={&#39;id_cohort&#39;: id_cohort, **ids_list_params})

    def delete_moodle_local_admins(self, id_context_categorie, ids_not_admin):
        &#34;&#34;&#34;
        Fonction permettant de supprimer les admins locaux
        d&#39;un contexte en gardant uniquement les admins specifies.
        :param id_context_categorie:
        :param ids_not_admin:
        :return:
        &#34;&#34;&#34;
        if not ids_not_admin:
            return
        # Construction de la liste des ids admins a conserver
        ids_list, ids_list_params = array_to_safe_sql_list(ids_not_admin, &#39;ids_list&#39;)
        # Recuperation de l&#39;id pour le role d&#39;admin local
        id_role_admin_local = self.get_id_role_admin_local()
        # Suppression des admins non presents dans la liste
        s = &#34;DELETE FROM {entete}role_assignments&#34; \
            &#34; WHERE roleid = %(id_role_admin_local)s&#34; \
            &#34; AND contextid = %(id_context_categorie)s&#34; \
            &#34; AND userid IN ({ids_list})&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={&#39;id_role_admin_local&#39;: id_role_admin_local,
                                     &#39;id_context_categorie&#39;: id_context_categorie, **ids_list_params})

    def get_id_role_admin_local(self):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id du role admin local
        au sein de la BD moodle.
        :return:
        &#34;&#34;&#34;
        return self.get_id_role_by_shortname(SHORTNAME_ADMIN_LOCAL)

    def get_id_role_by_shortname(self, short_name):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un role via son shortname
        :param short_name:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id FROM {entete}role&#34; \
            &#34; WHERE shortname = %(short_name)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;short_name&#39;: short_name})
        ligne = self.safe_fetchone()
        if ligne is None:
            raise ValueError(&#34;Le rôle %s n&#39;existe pas.&#34; % short_name)
        return ligne[0]

    def delete_moodle_local_admin(self, id_context_categorie, userid):
        &#34;&#34;&#34;
        Fonction permettant de supprimer les admins locaux
        d&#39;un contexte en gardant uniquement les admins specifies.
        :param id_context_categorie:
        :param userid:
        :return:
        &#34;&#34;&#34;
        id_role_admin_local = self.get_id_role_admin_local()
        self.delete_moodle_assignment(id_context_categorie, userid, id_role_admin_local)

    def delete_moodle_assignment(self, id_context_category, userid, roleid):
        &#34;&#34;&#34;
        Fonction permettant de supprimer un role à un utilisateur
        dans un contexte
        :param id_context_category:
        :param userid:
        :param roleid:
        :return:
        &#34;&#34;&#34;
        s = &#34;DELETE FROM {entete}role_assignments&#34; \
            &#34; WHERE contextid = %(id_context_category)s&#34; \
            &#34; AND roleid = %(roleid)s&#34; \
            &#34; AND userid = %(userid)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_context_category&#39;: id_context_category, &#39;roleid&#39;: roleid, &#39;userid&#39;: userid})

    def delete_role_for_contexts(self, role_id, ids_contexts_by_courses, id_user):
        &#34;&#34;&#34;
        Fonction permettant de supprimer un role sur differents
        contextes pour l&#39;utilisateur specifie.
        :param role_id:
        :param ids_contexts_by_courses:
        :param id_user:
        :return:
        &#34;&#34;&#34;
        # Suppression des enrolments dans les cours
        for id_course in ids_contexts_by_courses:
            # Recuperation de la methode d&#39;enrolment
            id_enrol = self.get_id_enrol(ENROL_METHOD_MANUAL, role_id, id_course)
            if not id_enrol:
                continue
            # Suppression de l&#39;enrolment associe
            id_user_enrolment = self.get_id_user_enrolment(id_enrol, id_user)
            if id_user_enrolment:
                s = &#34;DELETE FROM {entete}user_enrolments &#34; \
                    &#34;WHERE id = %(id_user_enrolment)s&#34; \
                    .format(entete=self.entete)
                self.mark.execute(s, params={&#39;id_user_enrolment&#39;: id_user_enrolment})

        # Suppression des roles dans les contextes
        ids_list, ids_list_params = array_to_safe_sql_list(ids_contexts_by_courses.values(), &#39;ids_list&#39;)
        s = &#34;DELETE FROM {entete}role_assignments&#34; \
            &#34; WHERE roleid = %(role_id)s&#34; \
            &#34; AND contextid IN ({ids_list})&#34; \
            &#34; AND userid = %(id_user)s&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={&#39;role_id&#39;: role_id, &#39;id_user&#39;: id_user, **ids_list_params})

    def get_id_enrol(self, enrol_method, role_id, id_course):
        &#34;&#34;&#34;
        Fonction permettant de recuperer un id
        dans la table permettant les enrolments
        :param enrol_method:
        :param role_id:
        :param id_course:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT e.id FROM {entete}enrol AS e&#34; \
            &#34; WHERE e.enrol = %(enrol_method)s&#34; \
            &#34; AND e.courseid = %(id_course)s&#34; \
            &#34; AND e.roleid = %(role_id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;enrol_method&#39;: enrol_method, &#39;id_course&#39;: id_course, &#39;role_id&#39;: role_id})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_user_enrolment(self, id_enrol, id_user):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un user enrolment
        :param id_enrol:
        :param id_user:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}user_enrolments &#34; \
            &#34; WHERE userid = %(id_user)s&#34; \
            &#34; AND enrolid = %(id_enrol)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_user&#39;: id_user, &#39;id_enrol&#39;: id_enrol})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def delete_roles(self, ids_roles):
        &#34;&#34;&#34;
        Fonction permettant de supprimer des roles.
        :param ids_roles:
        :return:
        &#34;&#34;&#34;
        # Construction de la liste des ids des roles concernes
        ids_list, ids_list_params = array_to_safe_sql_list(ids_roles, &#39;ids_list&#39;)
        s = &#34;DELETE FROM {entete}role_assignments&#34; \
            &#34; WHERE id IN ({ids_list})&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={**ids_list_params})

    def disenroll_user_from_cohorts(self, ids_cohorts_to_keep, id_user):
        &#34;&#34;&#34;
        Fonction permettant d&#39;enlever un utilisateur d&#39;une
        ou plusieurs cohortes.
        Seules les inscriptions dans les cohortes passees en
        parametres sont conservees.
        :param ids_cohorts_to_keep:
        :param id_user:
        :return:
        &#34;&#34;&#34;
        # Construction de la liste des ids des cohortes concernes
        ids_list, ids_list_params = array_to_safe_sql_list(ids_cohorts_to_keep, &#39;ids_list&#39;)
        s = &#34;DELETE FROM {entete}cohort_members&#34; \
            &#34; WHERE userid = %(id_user)s&#34; \
            &#34; AND cohortid NOT IN ({ids_list})&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={&#39;id_user&#39;: id_user, **ids_list_params})

    def disenroll_user_from_cohort(self, id_cohort, id_user):
        &#34;&#34;&#34;
        Fonction permettant d&#39;enlever un utilisateur d&#39;une
        cohorte.
        :param id_cohort:
        :param id_user:
        :return:
        &#34;&#34;&#34;
        s = &#34;DELETE FROM {entete}cohort_members&#34; \
            &#34; WHERE cohortid = %(id_cohort)s&#34; \
            &#34; AND userid = %(id_user)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_cohort&#39;: id_cohort, &#39;id_user&#39;: id_user})

    def get_cohort_name(self, id_cohort):
        &#34;&#34;&#34;
        Fonction permettant de recuperer le nom d&#39;une cohorte.
        :param id_cohort:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT name FROM {entete}cohort&#34; \
            &#34; WHERE id = %(id_cohort)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_cohort&#39;: id_cohort})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_description_course_category(self, id_category):
        &#34;&#34;&#34;
        Fonction permettant de recuperer la description d&#39;une
        categorie.
        :param id_category:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT description&#34; \
            &#34; FROM {entete}course_categories&#34; \
            &#34; WHERE id = %(id_category)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_category&#39;: id_category})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_descriptions_course_categories_by_themes(self, themes):
        &#34;&#34;&#34;
        Fonction permettant de recuperer les descriptions de categories.
        :param themes:
        :return:
        &#34;&#34;&#34;
        ids_list, ids_list_params = array_to_safe_sql_list(themes, &#39;ids_list&#39;)
        s = &#34;SELECT description&#34; \
            &#34; FROM {entete}course_categories&#34; \
            &#34; WHERE theme IN ({ids_list})&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={**ids_list_params})
        result_set = self.mark.fetchall()
        if not result_set:
            return []
        descriptions = [result[0] for result in result_set]
        return descriptions

    def get_id_block(self, parent_context_id):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un bloc.
        :param parent_context_id:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}block_instances&#34; \
            &#34; WHERE parentcontextid = %(parent_context_id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;parent_context_id&#39;: parent_context_id})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_course_timemodified(self, course_id: int):
        s = &#34;SELECT timemodified FROM {entete}course&#34; \
            &#34; WHERE id = %(course_id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;course_id&#39;: course_id})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def delete_course(self, course_id: int):
        s = &#34;DELETE FROM {entete}course WHERE id = %(course_id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={
            &#39;course_id&#39;: course_id
        })

    def get_courses_ids_owned_by(self, user_id: int):
        &#34;&#34;&#34;
        Recherche tous les cours dont l&#39;utilisateur est propriétaire
        :param user_id: L&#39;id de l&#39;utilisateur concerné
        :returns: La liste des cours dont l&#39;utilisateur est propriétaire
        &#34;&#34;&#34;
        s = &#34;SELECT instanceid FROM {entete}context AS context&#34; \
            &#34; INNER JOIN {entete}role_assignments AS role_assignments&#34; \
            &#34; ON context.id = role_assignments.contextid&#34; \
            &#34; WHERE role_assignments.userid = %(userid)s AND role_assignments.roleid = %(roleid)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id, &#39;roleid&#39;: self.constantes.id_role_proprietaire_cours})
        return self.mark.fetchall()

    def get_courses_ids_owned_or_teach(self, user_id: int):
        &#34;&#34;&#34;
        Retourne tous les cours auxquels participe un utilisateur
        en tant qu&#39;enseignant (role enseignant ou propriétaire de cours)
        :param user_id: L&#39;id de l&#39;utilisateur concerné
        :returns: La liste des cours dans lequel enseigne l&#39;utilisateur
        &#34;&#34;&#34;
        s = &#34;SELECT instanceid FROM {entete}context AS context&#34; \
            &#34; INNER JOIN {entete}role_assignments AS role_assignments&#34; \
            &#34; ON context.id = role_assignments.contextid&#34; \
            &#34; WHERE role_assignments.userid = %(userid)s AND (role_assignments.roleid = %(roleidowner)s&#34; \
            &#34; OR role_assignments.roleid = %(roleidteacher)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id, &#39;roleidowner&#39;: self.constantes.id_role_proprietaire_cours,
        &#39;roleidteacher&#39;: self.constantes.id_role_enseignant})
        return self.mark.fetchall()

    def get_userids_owner_of_course(self, course_id: int):
        &#34;&#34;&#34;
        Retourne tous les utilisateurs qui sont propriétaires d&#39;un cours
        :param course_id: L&#39;id du cours concerné
        :returns: La liste des utilisateurs propriétaires du cours
        &#34;&#34;&#34;
        s = &#34;SELECT userid FROM {entete}role_assignments AS role_assignments&#34; \
            &#34; INNER JOIN {entete}context AS context&#34; \
            &#34; ON role_assignments.contextid = context.id&#34; \
            &#34; WHERE context.instanceid = %(courseid)s AND role_assignments.roleid = %(roleid)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;courseid&#39;: course_id, &#39;roleid&#39;: self.constantes.id_role_proprietaire_cours})
        return self.mark.fetchall()

    def get_user_data(self, user_id: int):
        &#34;&#34;&#34;
        Retourne les informations détaillées sur un utilisateur (table mdl_user)
        :param user_id: L&#39;id de l&#39;utilisateur dont on veut récupére les infos
        :returns: Un tuple représentant la ligne récupérée depuis la BD
        &#34;&#34;&#34;
        s = &#34;SELECT * FROM {entete}user WHERE id = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        return self.mark.fetchone()

    def user_has_used_moodle(self, user_id: int):
        &#34;&#34;&#34;
        Indique si un utilisateur à déjà utilisé moodle, c&#39;est-à-dire s&#39;il s&#39;est déjà connecté
        :param user_id: L&#39;id de l&#39;utilisateur qu&#39;on veut vérifier
        :returns: Un booléen, qui vaut True si l&#39;utilisateur à déjà utilisé moodle, et False sinon
        &#34;&#34;&#34;
        s = &#34;SELECT lastlogin FROM {entete}user WHERE id = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        return self.mark.fetchone()[0] != 0

    def eleve_has_references(self, user_id: int):
        &#34;&#34;&#34;
        Indique si un élève dipose de références dans des exercices ou des notations moodle
        Les références comprennent :
        - des notes obtenues dans n&#39;importe quelle activité (historique de notes)
        - des réponses à une activité (feedback, test, consultation, sondage)
        - des participations à une activités (forum, chat)
        :param user_id: L&#39;id de l&#39;utilisateur qu&#39;on veut vérifier
        :returns: Un booléen à vrai si l&#39;utilisateur à des références, faux sinon
        &#34;&#34;&#34;

        #Dès qu&#39;on trouve une référence on renvoie True
        s = &#34;SELECT count(*) FROM {entete}forum_posts WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        s = &#34;SELECT count(*) FROM {entete}grade_grades_history WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        s = &#34;SELECT count(*) FROM {entete}feedback_completed WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        s = &#34;SELECT count(*) FROM {entete}chat_messages WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        s = &#34;SELECT count(*) FROM {entete}course_modules_completion WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        s = &#34;SELECT count(*) FROM {entete}quiz_attempts WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        s = &#34;SELECT count(*) FROM {entete}survey_answers WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        s = &#34;SELECT count(*) FROM {entete}choice_answers WHERE userid = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True

        #Si jamais on n&#39;a trouvé aucune référence, alors on peut renvoyer False
        return False

    def enseignant_has_references(self, user_id: int):
        &#34;&#34;&#34;
        Indique si un enseignant dipose de références dans des exercices ou des notations moodle
        Les références comprennent :
        - des notes qui ont été données à des étudiants dans des cours
        :param user_id: L&#39;id de l&#39;utilisateur qu&#39;on veut vérifier
        :returns: Un booléen à vrai si l&#39;utilisateur à des références, faux sinon
        &#34;&#34;&#34;
        s = &#34;SELECT count(*) FROM {entete}grade_grades_history WHERE loggeduser = %(userid)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;userid&#39;: user_id})
        if self.mark.fetchone()[0] &gt; 0:
            return True
        return False

    def get_id_categorie(self, categorie_name):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id correspondant a la
        categorie inter-etablissements.
        :param categorie_name:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}course_categories&#34; \
            &#34; WHERE name = %(categorie_name)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;categorie_name&#39;: categorie_name})
        ligne = self.safe_fetchone()
        return ligne[0] if ligne else None

    def get_id_context_no_depth(self, context_level, instance_id):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un contexte via
        le niveau et l&#39;id de l&#39;instance associee.
        :param context_level:
        :param instance_id:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}context&#34; \
            &#34; WHERE contextlevel = %(context_level)s&#34; \
            &#34; AND instanceid = %(instance_id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;context_level&#39;: context_level, &#39;instance_id&#39;: instance_id})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_context(self, context_level, depth, instance_id):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un contexte via
        le niveau, la profondeur et l&#39;id de l&#39;instance associee.
        :param context_level:
        :param depth:
        :param instance_id:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}context&#34; \
            &#34; WHERE contextlevel = %(context_level)s&#34; \
            &#34; AND depth = %(depth)s&#34; \
            &#34; AND instanceid = %(instance_id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;context_level&#39;: context_level, &#39;depth&#39;: depth, &#39;instance_id&#39;: instance_id})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_context_categorie(self, id_etab_categorie):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;une contexte via
        l&#39;id d&#39;un etablissement.
        :param id_etab_categorie:
        :return:
        &#34;&#34;&#34;
        return self.get_id_context(self.constantes.niveau_ctx_categorie, 2, id_etab_categorie)

    def get_id_context_inter_etabs(self):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id du contexte de la categorie inter-etablissements
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}context&#34; \
            &#34; WHERE contextlevel = %(context_level)s&#34; \
            &#34; AND instanceid = %(instanceid)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;context_level&#39;: self.constantes.niveau_ctx_categorie,
                                     &#39;instanceid&#39;: self.constantes.id_instance_moodle})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_course_by_id_number(self, id_number):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un cours a partir de son idnumber.
        :param id_number:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}course&#34; \
            &#34; WHERE idnumber = %(id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id&#39;: id_number})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_course_category_by_id_number(self, id_number):
        &#34;&#34;&#34;
        Récupère l&#39;id d&#39;une categorie à partir de son idnumber.
        :param id_number:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}course_categories&#34; \
            &#34; WHERE idnumber&#34; \
            &#34; LIKE %(id)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id&#39;: &#39;%&#39; + str(id_number) + &#39;%&#39;})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_course_category_by_theme(self, theme):
        &#34;&#34;&#34;
        Récupère l&#39;id d&#39;une categorie à partir de son theme.
        :param theme:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}course_categories&#34; \
            &#34; WHERE theme = %(theme)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;theme&#39;: theme})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_course_module(self, course):
        &#34;&#34;&#34;
        Récupère l&#39;id d&#39;un module de cours.
        :param course:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}course_modules&#34; \
            &#34; WHERE course = %(course)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;course&#39;: course})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_forum(self, course):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id du contexte propre
        a moodle.
        :param course:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}forum&#34; \
            &#34; WHERE course = %(course)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;course&#39;: course})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_user_info_data(self, id_user, id_field):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un info data via
        l&#39;id-user et l&#39;id_field
        :param id_user:
        :param id_field:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}user_info_data &#34; \
            &#34; WHERE userid = %(id_user)s&#34; \
            &#34; AND fieldid = %(id_field)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_user&#39;: id_user, &#39;id_field&#39;: id_field})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_id_user_info_field_by_shortname(self, short_name):
        &#34;&#34;&#34;
        Fonction permettant de recuperer l&#39;id d&#39;un info field via
        son shortname.
        :param short_name:
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT id&#34; \
            &#34; FROM {entete}user_info_field&#34; \
            &#34; WHERE shortname = %(short_name)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;short_name&#39;: short_name})
        ligne = self.safe_fetchone()
        if ligne is None:
            return None
        return ligne[0]

    def get_ids_and_summaries_not_allowed_roles(self, id_user, allowed_forums_shortnames):
        &#34;&#34;&#34;
        Fonction permettant de recuperer les ids des roles non
        autorises sur les forums, ainsi que les non des forums
        sur lesquels portent ces roles.
        :param id_user:
        :param allowed_forums_shortnames:
        :return:
        &#34;&#34;&#34;
        # Construction de la liste des shortnames
        ids_list, ids_list_params = array_to_safe_sql_list(allowed_forums_shortnames, &#39;ids_list&#39;)
        s = &#34;SELECT mra.id, mco.summary&#34; \
            &#34; FROM {entete}course mco, {entete}role_assignments mra, {entete}context mc&#34; \
            &#34; WHERE mco.shortname LIKE &#39;ZONE-PRIVEE-%%&#39;&#34; \
            &#34; AND mco.shortname NOT IN ({ids_list})&#34; \
            &#34; AND mco.id = mc.instanceid&#34; \
            &#34; AND mc.contextlevel = 50&#34; \
            &#34; AND mc.id = mra.contextid&#34; \
            &#34; AND mra.userid = %(id_user)s&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={&#39;id_user&#39;: id_user, **ids_list_params})
        result_set = self.mark.fetchall()
        if not result_set:
            return [], []
        # Recuperation des ids et themes non autorises
        ids = [result[0] for result in result_set]
        summaries = [result[1] for result in result_set]
        return ids, summaries

    def get_ids_and_themes_not_allowed_roles(self, id_user, allowed_themes):
        &#34;&#34;&#34;
        Fonction permettant de recuperer les ids des roles qui ne sont pas autorises pour l&#39;utilisateur.
        :param id_user:
        :param allowed_themes:
        :return:
        &#34;&#34;&#34;
        # Construction de la liste des themes
        ids_list, ids_list_params = array_to_safe_sql_list(allowed_themes, &#39;ids_list&#39;)
        # Recuperation des roles sur les etablissements qui ne devraient plus exister
        # (quand le prof n&#39;est plus rattache aux etablissements)
        s = &#34;SELECT mra.id, mcc.theme&#34; \
            &#34; FROM {entete}course_categories mcc, {entete}context mc, {entete}role_assignments mra&#34; \
            &#34; WHERE mcc.theme NOT IN ({ids_list})&#34; \
            &#34; AND mcc.theme IS NOT NULL&#34; \
            &#34; AND mcc.id = mc.instanceid &#34; \
            &#34; AND mc.contextlevel = %(NIVEAU_CTX_CATEGORIE)s AND mc.depth = %(PROFONDEUR_CTX_ETAB)s&#34; \
            &#34; AND mc.id = mra.contextid&#34; \
            &#34; AND mra.userid = %(id_user)s&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={**ids_list_params, &#39;NIVEAU_CTX_CATEGORIE&#39;: self.constantes.niveau_ctx_categorie,
                                     &#39;PROFONDEUR_CTX_ETAB&#39;: PROFONDEUR_CTX_ETAB, &#39;id_user&#39;: id_user})
        result_set = self.mark.fetchall()
        if not result_set:
            return [], []
        # Recuperation des ids et themes non autorises
        ids = [result[0] for result in result_set]
        themes = [result[1] for result in result_set]
        return ids, themes

    def get_timestamp_now(self):
        &#34;&#34;&#34;
        Fonction permettant de recuperer le timestamp actuel.
        :return:
        &#34;&#34;&#34;
        s = &#34;SELECT UNIX_TIMESTAMP( now( ) ) - 3600*2&#34;
        self.mark.execute(s)
        now = self.mark.fetchone()[0]
        return now

    def get_users_ids(self, usernames):
        &#34;&#34;&#34;
        Fonction permettant de recuperer les ids des
        utilisateurs moodle via leurs usernames.
        :param usernames:
        :return:
        &#34;&#34;&#34;
        users_ids = []
        for username in usernames:
            user_id = self.get_user_id(username)
            users_ids.append(user_id)
        return users_ids

    def user_has_role(self, userid, roles_list):
        &#34;&#34;&#34;
        Vérifie si un utilisateur a au moins un role parmis une liste
        :param userid:
        :param roles_list:
        :return:
        &#34;&#34;&#34;
        ids_list, ids_list_params = array_to_safe_sql_list(roles_list, &#39;ids_list&#39;)
        self.mark.execute(&#34;SELECT COUNT(role.id)&#34;
                          &#34; FROM {entete}role AS role&#34;
                          &#34; INNER JOIN {entete}role_assignments AS role_assignments&#34;
                          &#34; ON role.id = role_assignments.roleid&#34;
                          &#34; WHERE role_assignments.userid = %(userid)s&#34;
                          &#34; AND role.id IN ({ids_list})&#34;.format(entete=self.entete, ids_list=ids_list),
                          params={
                              &#39;userid&#39;: userid,
                              **ids_list_params
                          })
        count = self.mark.fetchone()[0]
        return count &gt; 0

    def get_all_valid_users(self):
        &#34;&#34;&#34;
        Retourne tous les utilisateurs de la base de données qui ne sont pas marqués comme &#34;supprimés&#34;
        :return:
        &#34;&#34;&#34;
        self.mark.execute(&#34;SELECT&#34;
                          &#34; id AS id,&#34;
                          &#34; username AS username,&#34;
                          &#34; lastlogin AS lastlogin&#34;
                          &#34; FROM {entete}user WHERE deleted = 0&#34;.format(entete=self.entete))
        return self.mark.fetchall()

    def anonymize_users(self, user_ids):
        &#34;&#34;&#34;
        Anonymise des utilisateurs de la BDD
        :param user_ids: La liste des id à anonymiser
        :return:
        &#34;&#34;&#34;

        ids_list, ids_list_params = array_to_safe_sql_list(user_ids, &#39;ids_list&#39;)
        self.mark.execute(&#34;UPDATE {entete}user&#34;
                          &#34; SET firstname = %(anonymous_name)s,&#34;
                          &#34; lastname = %(anonymous_name)s,&#34;
                          &#34; firstnamephonetic = %(anonymous_name)s,&#34;
                          &#34; lastnamephonetic = %(anonymous_name)s,&#34;
                          &#34; middlename = %(anonymous_name)s,&#34;
                          &#34; alternatename = %(anonymous_name)s,&#34;
                          &#34; city = %(anonymous_name)s,&#34;
                          &#34; address = %(anonymous_name)s,&#34;
                          &#34; department = %(anonymous_name)s,&#34;
                          &#34; phone1 = %(anonymous_phone)s,&#34;
                          &#34; phone2 = %(anonymous_phone)s,&#34;
                          &#34; skype = %(anonymous_name)s,&#34;
                          &#34; yahoo = %(anonymous_name)s,&#34;
                          &#34; aim = %(anonymous_name)s,&#34;
                          &#34; msn = %(anonymous_name)s,&#34;
                          &#34; email = %(anonymous_mail)s,&#34;
                          &#34; description = NULL&#34;
                          &#34; WHERE id IN ({ids_list})&#34;
                          .format(entete=self.entete, ids_list=ids_list),
                          params={
                              &#39;anonymous_name&#39;: self.constantes.anonymous_name,
                              &#39;anonymous_mail&#39;: self.constantes.anonymous_mail,
                              &#39;anonymous_phone&#39;: self.constantes.anonymous_phone,
                              **ids_list_params
                          })

    def insert_moodle_block(self, block_name, parent_context_id, show_in_subcontexts, page_type_pattern,
                            sub_page_pattern, default_region, default_weight):
        &#34;&#34;&#34;
        Insère un bloc.
        :param block_name:
        :param parent_context_id:
        :param show_in_subcontexts:
        :param page_type_pattern:
        :param sub_page_pattern:
        :param default_region:
        :param default_weight:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}block_instances &#34; \
            &#34;( blockname, parentcontextid, showinsubcontexts, pagetypepattern, subpagepattern, defaultregion, &#34; \
            &#34;defaultweight, timecreated, timemodified ) &#34; \
            &#34; VALUES ( %(block_name)s, %(parent_context_id)s, %(show_in_subcontexts)s, %(page_type_pattern)s, &#34; \
            &#34;%(sub_page_pattern)s, %(default_region)s, %(default_weight)s, UNIX_TIMESTAMP( now( ) ) - 3600*2,&#34; \
            &#34;UNIX_TIMESTAMP( now( ) ) - 3600*2 )&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;block_name&#39;: block_name,
                                     &#39;parent_context_id&#39;: parent_context_id,
                                     &#39;show_in_subcontexts&#39;: show_in_subcontexts,
                                     &#39;page_type_pattern&#39;: page_type_pattern,
                                     &#39;sub_page_pattern&#39;: sub_page_pattern,
                                     &#39;default_region&#39;: default_region,
                                     &#39;default_weight&#39;: default_weight})

    def insert_moodle_context(self, context_level, depth, instance_id):
        &#34;&#34;&#34;
        Insère un contexte.
        :param context_level:
        :param depth:
        :param instance_id:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}context (contextlevel, instanceid, depth)&#34; \
            &#34; VALUES (%(context_level)s, %(instance_id)s,  %(depth)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;context_level&#39;: context_level, &#39;instance_id&#39;: instance_id, &#39;depth&#39;: depth})

    def insert_moodle_course(self, id_category, full_name, id_number, short_name, summary, format_, visible,
                             start_date, time_created, time_modified):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer un cours.
        :param id_category:
        :param full_name:
        :param id_number:
        :param short_name:
        :param summary:
        :param format_:
        :param visible:
        :param start_date:
        :param time_created:
        :param time_modified:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}course &#34; \
            &#34;(category, fullname, idnumber, shortname, summary, &#34; \
            &#34;format, visible, startdate, timecreated, timemodified) &#34; \
            &#34; VALUES (%(id_category)s, %(full_name)s, %(id_number)s, %(short_name)s, %(summary)s, &#34; \
            &#34;%(format)s, %(visible)s, %(start_date)s, %(time_created)s, %(time_modified)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_category&#39;: id_category,
                                     &#39;full_name&#39;: full_name,
                                     &#39;id_number&#39;: id_number,
                                     &#39;short_name&#39;: short_name,
                                     &#39;summary&#39;: summary,
                                     &#39;format&#39;: format_,
                                     &#39;visible&#39;: visible,
                                     &#39;start_date&#39;: start_date,
                                     &#39;time_created&#39;: time_created,
                                     &#39;time_modified&#39;: time_modified})

    def insert_moodle_course_category(self, name, id_number, description, theme):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer une categorie.
        :param name:
        :param id_number:
        :param description:
        :param theme:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}course_categories&#34; \
            &#34; (name, idnumber, description, parent, sortorder, coursecount, visible, depth,theme)&#34; \
            &#34; VALUES(%(name)s, %(id_number)s, %(description)s, 0, 999,0, 1, 1, %(theme)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;name&#39;: name, &#39;id_number&#39;: id_number, &#39;description&#39;: description, &#39;theme&#39;: theme})

    def insert_moodle_course_module(self, course, module, instance, added):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer un module de cours.
        :param course:
        :param module:
        :param instance:
        :param added:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}course_modules (course, module, instance, added)&#34; \
            &#34; VALUES (%(course)s , %(module)s, %(instance)s , %(added)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;course&#39;: course, &#39;module&#39;: module, &#39;instance&#39;: instance, &#39;added&#39;: added})

    def insert_moodle_enrol_capability(self, enrol, status, course_id, role_id):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer une methode d&#39;inscription
        a un cours.
        :param enrol:
        :param status:
        :param course_id:
        :param role_id:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}enrol(enrol, status, courseid, roleid)&#34; \
            &#34; VALUES(%(enrol)s, %(status)s, %(course_id)s, %(role_id)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;enrol&#39;: enrol, &#39;status&#39;: status, &#39;course_id&#39;: course_id, &#39;role_id&#39;: role_id})

    def insert_moodle_forum(self, course, name, intro, intro_format, max_bytes, max_attachements, time_modified):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer un forum.
        :param course:
        :param name:
        :param intro:
        :param intro_format:
        :param max_bytes:
        :param max_attachements:
        :param time_modified:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}forum (course, name, intro, introformat, maxbytes, maxattachments, timemodified) &#34; \
            &#34;VALUES (%(course)s, %(name)s, %(intro)s, %(intro_format)s, %(max_bytes)s, %(max_attachements)s, &#34; \
            &#34;%(time_modified)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;course&#39;: course,
                                     &#39;name&#39;: name,
                                     &#39;intro&#39;: intro,
                                     &#39;intro_format&#39;: intro_format,
                                     &#39;max_bytes&#39;: max_bytes,
                                     &#39;max_attachements&#39;: max_attachements,
                                     &#39;time_modified&#39;: time_modified})

    def is_moodle_local_admin(self, id_context_categorie, id_user):
        &#34;&#34;&#34;
        Fonction permettant de vérifier si un utilisateur est
        admin local pour un contexte donne.
        :param id_context_categorie:
        :param id_user:
        :return:
        &#34;&#34;&#34;
        id_role_admin_local = self.get_id_role_admin_local()
        sql = &#34;SELECT COUNT(id) FROM {entete}role_assignments&#34; \
              &#34; WHERE roleid = %(id_role_admin_local)s&#34; \
              &#34; AND contextid = %(id_context_categorie)s&#34; \
              &#34; AND userid = %(id_user)s&#34; \
            .format(entete=self.entete)
        params = {&#39;id_role_admin_local&#39;: id_role_admin_local, &#39;id_context_categorie&#39;: id_context_categorie,
                  &#39;id_user&#39;: id_user}
        self.mark.execute(sql, params=params)
        result = self.safe_fetchone()
        is_local_admin = result[0] &gt; 0
        return is_local_admin

    def insert_moodle_local_admin(self, id_context_categorie, id_user):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer un admin local pour un
        contexte donne.
        Retour True si insertion réalisée, False le cas échéant
        :param id_context_categorie:
        :param id_user:
        :return:
        &#34;&#34;&#34;
        if self.is_moodle_local_admin(id_context_categorie, id_user):
            return False
        id_role_admin_local = self.get_id_role_admin_local()
        s = &#34;INSERT ignore INTO {entete}role_assignments(roleid, contextid, userid)&#34; \
            &#34; VALUES (%(id_role_admin_local)s, %(id_context_categorie)s, %(id_user)s)&#34; \
            .format(entete=self.entete)
        params = {&#39;id_role_admin_local&#39;: id_role_admin_local, &#39;id_context_categorie&#39;: id_context_categorie,
                  &#39;id_user&#39;: id_user}
        self.mark.execute(s, params=params)
        return True

    def insert_moodle_user(self, username, first_name, last_name, email, mail_display, theme):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer un utilisateur dans Moodle.
        :param username:
        :param first_name:
        :param last_name:
        :param email:
        :param mail_display:
        :param theme:
        :return:
        &#34;&#34;&#34;
        user_id = self.get_user_id(username)
        username = username.lower()
        if user_id is None:
            s = &#34;INSERT INTO {entete}user&#34; \
                &#34; (auth, confirmed, username, firstname, lastname, email, maildisplay, city, country, lang,&#34; \
                &#34; mnethostid, theme )&#34; \
                &#34; VALUES (%(auth)s, %(confirmed)s, %(username)s, %(firstname)s, %(lastname)s, %(email)s,&#34; \
                &#34; %(maildisplay)s, %(city)s, %(country)s, %(lang)s, %(mnethostid)s, %(theme)s)&#34; \
                .format(entete=self.entete)

            self.mark.execute(s, params={&#39;auth&#39;: USER_AUTH,
                                         &#39;confirmed&#39;: 1,
                                         &#39;username&#39;: username,
                                         &#39;firstname&#39;: first_name,
                                         &#39;lastname&#39;: last_name,
                                         &#39;email&#39;: email,
                                         &#39;maildisplay&#39;: mail_display,
                                         &#39;city&#39;: USER_CITY,
                                         &#39;country&#39;: USER_COUNTRY,
                                         &#39;lang&#39;: USER_LANG,
                                         &#39;mnethostid&#39;: USER_MNET_HOST_ID,
                                         &#39;theme&#39;: theme})

    def insert_moodle_user_info_data(self, id_user, id_field, data):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer un user info data.
        :param id_user:
        :param id_field:
        :param data:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}user_info_data (userid, fieldid, data)&#34; \
            &#34; VALUES (%(id_user)s, %(id_field)s, %(data)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_user&#39;: id_user, &#39;id_field&#39;: id_field, &#39;data&#39;: data})

    def insert_moodle_user_info_field(self, short_name, name, data_type, id_category, param1, param2, locked, visible):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer un user info field.
        :param short_name:
        :param name:
        :param data_type:
        :param id_category:
        :param param1:
        :param param2:
        :param locked:
        :param visible:
        :return:
        &#34;&#34;&#34;
        s = &#34;INSERT INTO {entete}user_info_field&#34; \
            &#34; (shortname, name, datatype, categoryid, param1, param2, locked, visible)&#34; \
            &#34; VALUES (%(short_name)s, %(name)s, %(data_type)s, %(id_category)s, %(param1)s, %(param2)s, %(locked)s,&#34; \
            &#34; %(visible)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;short_name&#39;: short_name,
                                     &#39;name&#39;: name,
                                     &#39;data_type&#39;: data_type,
                                     &#39;id_category&#39;: id_category,
                                     &#39;param1&#39;: param1,
                                     &#39;param2&#39;: param2,
                                     &#39;locked&#39;: locked,
                                     &#39;visible&#39;: visible})

    def insert_zone_privee(self, id_categorie_etablissement, siren, ou, time):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer le cours correspondant
        a la zone privee.
        :param id_categorie_etablissement:
        :param siren:
        :param ou:
        :param time:
        :return:
        &#34;&#34;&#34;
        full_name = COURSE_FULLNAME_ZONE_PRIVEE
        id_number = short_name = COURSE_SHORTNAME_ZONE_PRIVEE % siren
        summary = COURSE_SUMMARY_ZONE_PRIVEE % ou.encode(&#34;utf-8&#34;)
        format_ = COURSE_FORMAT_ZONE_PRIVEE
        visible = COURSE_VISIBLE_ZONE_PRIVEE
        start_date = time_created = time_modified = time
        id_zone_privee = self.get_id_course_by_id_number(id_number)
        if id_zone_privee is not None:
            return id_zone_privee
        self.insert_moodle_course(id_categorie_etablissement, full_name, id_number, short_name, summary, format_,
                                  visible, start_date, time_created, time_modified)
        id_zone_privee = self.get_id_course_by_id_number(id_number)
        return id_zone_privee

    def insert_zone_privee_context(self, id_zone_privee):
        &#34;&#34;&#34;
        Fonction permettant d&#39;inserer le contexte correspondant
        a la zone privee.
        :param id_zone_privee:
        :return:
        &#34;&#34;&#34;
        id_contexte_zone_privee = self.get_id_context(self.constantes.niveau_ctx_cours, PROFONDEUR_CTX_ZONE_PRIVEE,
                                                      id_zone_privee)
        if id_contexte_zone_privee:
            return id_contexte_zone_privee

        id_contexte_zone_privee = self.get_id_context_no_depth(self.constantes.niveau_ctx_cours, id_zone_privee)
        if id_contexte_zone_privee:
            return id_contexte_zone_privee

        self.insert_moodle_context(self.constantes.niveau_ctx_cours, PROFONDEUR_CTX_ZONE_PRIVEE, id_zone_privee)
        id_contexte_zone_privee = self.get_id_context(self.constantes.niveau_ctx_cours, PROFONDEUR_CTX_ZONE_PRIVEE,
                                                      id_zone_privee)
        return id_contexte_zone_privee

    def purge_cohorts(self, users_ids_by_cohorts_ids):
        &#34;&#34;&#34;
        Fonction permettant de purger des cohortes.
        Le dictionnaire fourni en parametre indique la liste
        des ids utilisateurs appartenant a une cohorte.
        Ce dictionnaire est indexe par id de cohortes.
        :param users_ids_by_cohorts_ids:
        :return:
        &#34;&#34;&#34;
        for cohort_id, users_ids in users_ids_by_cohorts_ids.items():
            ids_list, ids_list_params = array_to_safe_sql_list(users_ids, &#39;ids_list&#39;)
            s = &#34;DELETE FROM {entete}cohort_members&#34; \
                &#34; WHERE cohortid = %(cohort_id)s&#34; \
                &#34; AND userid NOT IN ({ids_list})&#34; \
                .format(entete=self.entete, ids_list=ids_list)
            self.mark.execute(s, params={&#39;cohort_id&#39;: cohort_id, **ids_list_params})

    def get_user_filtered_cohorts(self, contextid, cohortname_pattern):
        &#34;&#34;&#34;
        Obtient les cohortes de classes d&#39;élèves
        :param contextid:
        :param cohortname_pattern:
        :return:
        &#34;&#34;&#34;
        self.mark.execute(&#34;SELECT id, contextid, name FROM {entete}cohort&#34;
                          &#34; WHERE contextid = %(contextid)s AND name LIKE %(like)s&#34;
                          .format(entete=self.entete),
                          params={
                              &#39;contextid&#39;: contextid,
                              &#39;like&#39;: cohortname_pattern
                          })
        return [Cohort(cohortid=result[0], contextid=result[1], name=result[2]) for result in self.mark.fetchall()]

    def get_cohort_members(self, cohortid) -&gt; list:
        &#34;&#34;&#34;
        Obtient les noms d&#39;utilisateurs membres de la cohorte.
        :param cohortid:
        :return: list de username
        &#34;&#34;&#34;
        self.mark.execute(&#34;SELECT {entete}user.username FROM {entete}cohort_members&#34;
                          &#34; INNER JOIN {entete}user ON {entete}cohort_members.userid = {entete}user.id&#34;
                          &#34; WHERE cohortid = %(cohortid)s&#34;
                          .format(entete=self.entete),
                          params={
                              &#39;cohortid&#39;: cohortid
                          })
        return map(lambda r: r[0], self.mark.fetchall())

    def update_context_path(self, id_context, new_path):
        &#34;&#34;&#34;
        Fonction permettant de mettre a jour le path d&#39;un contexte.
        :param id_context:
        :param new_path:
        :return:
        &#34;&#34;&#34;
        s = &#34;UPDATE {entete}context&#34; \
            &#34; SET path = %(new_path)s&#34; \
            &#34; WHERE id = %(id_context)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;new_path&#39;: new_path, &#39;id_context&#39;: id_context})

    def update_course_category_description(self, id_category, new_description):
        &#34;&#34;&#34;
        Fonction permettant de mettre a jour la description
        d&#39;une categorie.
        :param id_category:
        :param new_description:
        :return:
        &#34;&#34;&#34;
        s = &#34;UPDATE {entete}course_categories&#34; \
            &#34; SET description = %(new_description)s&#34; \
            &#34; WHERE id = %(id_category)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;new_description&#39;: new_description, &#39;id_category&#39;: id_category})

    def update_course_category_name(self, id_category, new_name):
        &#34;&#34;&#34;
        Fonction permettant de mettre a jour le nom
        d&#39;une categorie.
        :param id_category:
        :param new_name:
        :return:
        &#34;&#34;&#34;
        s = &#34;UPDATE {entete}course_categories&#34; \
            &#34; SET name = %(new_name)s&#34; \
            &#34; WHERE id = %(id_category)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;new_name&#39;: new_name, &#39;id_category&#39;: id_category})

    def update_course_category_path(self, id_category, new_path):
        &#34;&#34;&#34;
        Fonction permettant de mettre a jour le path d&#39;une
        categorie.
        :param id_category:
        :param new_path:
        :return:
        &#34;&#34;&#34;
        s = &#34;UPDATE {entete}course_categories&#34; \
            &#34; SET path = %(new_path)s&#34; \
            &#34; WHERE id = %(id_category)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;new_path&#39;: new_path, &#39;id_category&#39;: id_category})

    def update_moodle_user(self, id_user, first_name, last_name, email, mail_display, theme):
        &#34;&#34;&#34;
        Fonction permettant de mettre a jour un utilisateur
        :param id_user:
        :param first_name:
        :param last_name:
        :param email:
        :param mail_display:
        :param theme:
        :return:
        &#34;&#34;&#34;
        s = &#34;UPDATE {entete}user&#34; \
            &#34; SET auth = %(USER_AUTH)s, firstname = %(first_name)s, lastname = %(last_name)s, email = %(email)s,&#34; \
            &#34; maildisplay = %(mail_display)s, city = %(USER_CITY)s, country = %(USER_COUNTRY)s, lang = %(USER_LANG)s,&#34; \
            &#34; mnethostid = %(USER_MNET_HOST_ID)s, theme = %(theme)s&#34; \
            &#34; WHERE id = %(id_user)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;USER_AUTH&#39;: USER_AUTH,
                                     &#39;first_name&#39;: first_name,
                                     &#39;last_name&#39;: last_name,
                                     &#39;email&#39;: email,
                                     &#39;mail_display&#39;: mail_display,
                                     &#39;USER_CITY&#39;: USER_CITY,
                                     &#39;USER_COUNTRY&#39;: USER_COUNTRY,
                                     &#39;USER_LANG&#39;: USER_LANG,
                                     &#39;USER_MNET_HOST_ID&#39;: USER_MNET_HOST_ID,
                                     &#39;theme&#39;: theme,
                                     &#39;id_user&#39;: id_user})

    def update_user_info_data(self, id_user, id_field, new_data):
        &#34;&#34;&#34;
        Fonction permettant de mettre a jour le data d&#39;un user
        info data.
        :param id_user:
        :param id_field:
        :param new_data:
        :return:
        &#34;&#34;&#34;
        s = &#34;UPDATE {entete}user_info_data&#34; \
            &#34; SET data = %(new_data)s &#34; \
            &#34; WHERE userid = %(id_user)s&#34; \
            &#34; AND fieldid = %(id_field)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;new_data&#39;: new_data, &#39;id_user&#39;: id_user, &#39;id_field&#39;: id_field})

    def get_field_domaine(self):
        &#34;&#34;&#34;
        Fonction pour récupére l&#39;id du champ Domaine
        :return:
        &#34;&#34;&#34;
        id_field_domaine = []
        sql = &#34;SELECT id&#34; \
              &#34; FROM {entete}user_info_field&#34; \
              &#34; WHERE shortname = &#39;Domaine&#39;&#34; \
              &#34; AND name =&#39;Domaine&#39;&#34; \
            .format(entete=self.entete)
        self.mark.execute(sql)
        row = self.mark.fetchall()

        # Si le champ n&#39;existe pas, on le crée et on récupère l&#39;id
        if not bool(row):
            id_field_domaine = 0
        else:
            id_field_domaine = row[0][0]

        return id_field_domaine

    def is_enseignant_avance(self, id_user, id_role_enseignant_avance):
        &#34;&#34;&#34;
        :param id_user:
        :param id_role_enseignant_avance:
        :return:
        &#34;&#34;&#34;
        sql = &#34;SELECT COUNT(id)&#34; \
              &#34; FROM {entete}role_assignments&#34; \
              &#34; WHERE userid = %(id_user)s&#34; \
              &#34; AND roleid = %(id_role_enseignant_avance)s&#34; \
            .format(entete=self.entete)
        self.mark.execute(sql, params={&#39;id_user&#39;: id_user, &#39;id_role_enseignant_avance&#39;: id_role_enseignant_avance})
        result = self.safe_fetchone()
        return result[0] &gt; 0

    def set_user_domain(self, id_user, id_field_domaine, user_domain):
        &#34;&#34;&#34;
        Fonction pour saisir le Domaine d&#39;un utilisateur Moodle
        :param id_user:
        :param id_field_domaine:
        :param user_domain:
        :return:
        &#34;&#34;&#34;
        # pour un utilisateur qui est déjà dans la table &#34;user_info_data&#34; mais sur un autre domaine que
        # le domaine &#34;user_domain&#34;,
        # le script va essayer de créer une nouvelle ligne (INSERT) avec le nouveau domaine =&gt; erreur !
        # la requête doit donc être modifiée :
        # sql = &#34;SELECT id FROM %suser_info_data WHERE userid = %s AND fieldid = %s AND data = &#39;%s&#39;&#34;
        sql = &#34;SELECT id&#34; \
              &#34; FROM {entete}user_info_data&#34; \
              &#34; WHERE userid = %(id_user)s&#34; \
              &#34; AND fieldid = %(id_field_domaine)s&#34; \
              &#34; LIMIT 1&#34; \
            .format(entete=self.entete)
        self.mark.execute(sql, params={&#39;id_user&#39;: id_user, &#39;id_field_domaine&#39;: id_field_domaine})

        result = self.safe_fetchone()
        if result:
            sql = &#34;REPLACE INTO {entete}user_info_data &#34; \
                  &#34;(id, userid, fieldid, data)&#34; \
                  &#34; VALUES (%(id)s, %(id_user)s, %(id_field_domaine)s, %(user_domain)s)&#34; \
                .format(entete=self.entete)
            self.mark.execute(sql, params={&#39;id&#39;: result[0],
                                           &#39;id_user&#39;: id_user,
                                           &#39;id_field_domaine&#39;: id_field_domaine,
                                           &#39;user_domain&#39;: user_domain})
        else:
            sql = &#34;INSERT INTO {entete}user_info_data &#34; \
                  &#34;(userid, fieldid, data)&#34; \
                  &#34; VALUES (%(id_user)s, %(id_field_domaine)s, %(user_domain)s)&#34; \
                .format(entete=self.entete)
            self.mark.execute(sql, params={&#39;id_user&#39;: id_user,
                                           &#39;id_field_domaine&#39;: id_field_domaine,
                                           &#39;user_domain&#39;: user_domain})</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="synchromoodle.dbutils.Database.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="synchromoodle.dbutils.Database.connection"><code class="name">var <span class="ident">connection</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="synchromoodle.dbutils.Database.constantes"><code class="name">var <span class="ident">constantes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="synchromoodle.dbutils.Database.entete"><code class="name">var <span class="ident">entete</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="synchromoodle.dbutils.Database.mark"><code class="name">var <span class="ident">mark</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="synchromoodle.dbutils.Database.add_role_to_user"><code class="name flex">
<span>def <span class="ident">add_role_to_user</span></span>(<span>self, role_id, id_context, id_user)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'ajouter un role a un utilisateur
pour un contexte donne
:param role_id: int
:param id_context: int
:param id_user: int
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_role_to_user(self, role_id, id_context, id_user):
    &#34;&#34;&#34;
    Fonction permettant d&#39;ajouter un role a un utilisateur
    pour un contexte donne
    :param role_id: int
    :param id_context: int
    :param id_user: int
    :return:
    &#34;&#34;&#34;
    id_role_assignment = self.get_id_role_assignment(role_id, id_context, id_user)
    if not id_role_assignment:
        # Ajout du role dans le contexte
        s = &#34;INSERT INTO {entete}role_assignments( roleid, contextid, userid )&#34; \
            &#34; VALUES ( %(role_id)s, %(id_context)s, %(id_user)s )&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;role_id&#39;: role_id, &#39;id_context&#39;: id_context, &#39;id_user&#39;: id_user})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.add_role_to_user_for_contexts"><code class="name flex">
<span>def <span class="ident">add_role_to_user_for_contexts</span></span>(<span>self, role_id, ids_contexts_by_courses, id_user)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'ajouter un role a un utilisateur
pour plusieurs contextes donnes
:param role_id:
:param ids_contexts_by_courses:
:param id_user:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_role_to_user_for_contexts(self, role_id, ids_contexts_by_courses, id_user):
    &#34;&#34;&#34;
    Fonction permettant d&#39;ajouter un role a un utilisateur
    pour plusieurs contextes donnes
    :param role_id:
    :param ids_contexts_by_courses:
    :param id_user:
    :return:
    &#34;&#34;&#34;
    for id_course, id_context in ids_contexts_by_courses.iteritems():
        self.add_role_to_user(role_id, id_context, id_user)
        self.enroll_user_in_course(role_id, id_course, id_user)</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.anonymize_users"><code class="name flex">
<span>def <span class="ident">anonymize_users</span></span>(<span>self, user_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Anonymise des utilisateurs de la BDD
:param user_ids: La liste des id à anonymiser
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def anonymize_users(self, user_ids):
    &#34;&#34;&#34;
    Anonymise des utilisateurs de la BDD
    :param user_ids: La liste des id à anonymiser
    :return:
    &#34;&#34;&#34;

    ids_list, ids_list_params = array_to_safe_sql_list(user_ids, &#39;ids_list&#39;)
    self.mark.execute(&#34;UPDATE {entete}user&#34;
                      &#34; SET firstname = %(anonymous_name)s,&#34;
                      &#34; lastname = %(anonymous_name)s,&#34;
                      &#34; firstnamephonetic = %(anonymous_name)s,&#34;
                      &#34; lastnamephonetic = %(anonymous_name)s,&#34;
                      &#34; middlename = %(anonymous_name)s,&#34;
                      &#34; alternatename = %(anonymous_name)s,&#34;
                      &#34; city = %(anonymous_name)s,&#34;
                      &#34; address = %(anonymous_name)s,&#34;
                      &#34; department = %(anonymous_name)s,&#34;
                      &#34; phone1 = %(anonymous_phone)s,&#34;
                      &#34; phone2 = %(anonymous_phone)s,&#34;
                      &#34; skype = %(anonymous_name)s,&#34;
                      &#34; yahoo = %(anonymous_name)s,&#34;
                      &#34; aim = %(anonymous_name)s,&#34;
                      &#34; msn = %(anonymous_name)s,&#34;
                      &#34; email = %(anonymous_mail)s,&#34;
                      &#34; description = NULL&#34;
                      &#34; WHERE id IN ({ids_list})&#34;
                      .format(entete=self.entete, ids_list=ids_list),
                      params={
                          &#39;anonymous_name&#39;: self.constantes.anonymous_name,
                          &#39;anonymous_mail&#39;: self.constantes.anonymous_mail,
                          &#39;anonymous_phone&#39;: self.constantes.anonymous_phone,
                          **ids_list_params
                      })</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Etablit la connexion à la base de données Moodle
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self):
    &#34;&#34;&#34;
    Etablit la connexion à la base de données Moodle
    :return:
    &#34;&#34;&#34;
    self.connection = mysql.connector.connect(host=self.config.host,
                                              user=self.config.user,
                                              passwd=self.config.password,
                                              db=self.config.database,
                                              charset=self.config.charset,
                                              port=self.config.port)
    self.mark = self.connection.cursor()</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.create_cohort"><code class="name flex">
<span>def <span class="ident">create_cohort</span></span>(<span>self, id_context, name, id_number, description, time_created)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de creer une nouvelle cohorte pour
un contexte donne.
:param id_context:
:param name:
:param id_number:
:param description:
:param time_created:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_cohort(self, id_context, name, id_number, description, time_created):
    &#34;&#34;&#34;
    Fonction permettant de creer une nouvelle cohorte pour
    un contexte donne.
    :param id_context:
    :param name:
    :param id_number:
    :param description:
    :param time_created:
    :return:
    &#34;&#34;&#34;
    s = &#34;INSERT INTO {entete}cohort(contextid, name, idnumber, description, descriptionformat, timecreated,&#34; \
        &#34; timemodified)&#34; \
        &#34; VALUES (%(id_context)s, %(name)s, %(id_number)s, %(description)s, 0, %(time_created)s,&#34; \
        &#34; %(time_created)s)&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;id_context&#39;: id_context, &#39;name&#39;: name, &#39;id_number&#39;: id_number,
                                 &#39;description&#39;: description, &#39;time_created&#39;: time_created})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.delete_course"><code class="name flex">
<span>def <span class="ident">delete_course</span></span>(<span>self, course_id: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_course(self, course_id: int):
    s = &#34;DELETE FROM {entete}course WHERE id = %(course_id)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={
        &#39;course_id&#39;: course_id
    })</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.delete_moodle_assignment"><code class="name flex">
<span>def <span class="ident">delete_moodle_assignment</span></span>(<span>self, id_context_category, userid, roleid)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de supprimer un role à un utilisateur
dans un contexte
:param id_context_category:
:param userid:
:param roleid:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_moodle_assignment(self, id_context_category, userid, roleid):
    &#34;&#34;&#34;
    Fonction permettant de supprimer un role à un utilisateur
    dans un contexte
    :param id_context_category:
    :param userid:
    :param roleid:
    :return:
    &#34;&#34;&#34;
    s = &#34;DELETE FROM {entete}role_assignments&#34; \
        &#34; WHERE contextid = %(id_context_category)s&#34; \
        &#34; AND roleid = %(roleid)s&#34; \
        &#34; AND userid = %(userid)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;id_context_category&#39;: id_context_category, &#39;roleid&#39;: roleid, &#39;userid&#39;: userid})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.delete_moodle_local_admin"><code class="name flex">
<span>def <span class="ident">delete_moodle_local_admin</span></span>(<span>self, id_context_categorie, userid)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de supprimer les admins locaux
d'un contexte en gardant uniquement les admins specifies.
:param id_context_categorie:
:param userid:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_moodle_local_admin(self, id_context_categorie, userid):
    &#34;&#34;&#34;
    Fonction permettant de supprimer les admins locaux
    d&#39;un contexte en gardant uniquement les admins specifies.
    :param id_context_categorie:
    :param userid:
    :return:
    &#34;&#34;&#34;
    id_role_admin_local = self.get_id_role_admin_local()
    self.delete_moodle_assignment(id_context_categorie, userid, id_role_admin_local)</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.delete_moodle_local_admins"><code class="name flex">
<span>def <span class="ident">delete_moodle_local_admins</span></span>(<span>self, id_context_categorie, ids_not_admin)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de supprimer les admins locaux
d'un contexte en gardant uniquement les admins specifies.
:param id_context_categorie:
:param ids_not_admin:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_moodle_local_admins(self, id_context_categorie, ids_not_admin):
    &#34;&#34;&#34;
    Fonction permettant de supprimer les admins locaux
    d&#39;un contexte en gardant uniquement les admins specifies.
    :param id_context_categorie:
    :param ids_not_admin:
    :return:
    &#34;&#34;&#34;
    if not ids_not_admin:
        return
    # Construction de la liste des ids admins a conserver
    ids_list, ids_list_params = array_to_safe_sql_list(ids_not_admin, &#39;ids_list&#39;)
    # Recuperation de l&#39;id pour le role d&#39;admin local
    id_role_admin_local = self.get_id_role_admin_local()
    # Suppression des admins non presents dans la liste
    s = &#34;DELETE FROM {entete}role_assignments&#34; \
        &#34; WHERE roleid = %(id_role_admin_local)s&#34; \
        &#34; AND contextid = %(id_context_categorie)s&#34; \
        &#34; AND userid IN ({ids_list})&#34; \
        .format(entete=self.entete, ids_list=ids_list)
    self.mark.execute(s, params={&#39;id_role_admin_local&#39;: id_role_admin_local,
                                 &#39;id_context_categorie&#39;: id_context_categorie, **ids_list_params})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.delete_role_for_contexts"><code class="name flex">
<span>def <span class="ident">delete_role_for_contexts</span></span>(<span>self, role_id, ids_contexts_by_courses, id_user)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de supprimer un role sur differents
contextes pour l'utilisateur specifie.
:param role_id:
:param ids_contexts_by_courses:
:param id_user:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_role_for_contexts(self, role_id, ids_contexts_by_courses, id_user):
    &#34;&#34;&#34;
    Fonction permettant de supprimer un role sur differents
    contextes pour l&#39;utilisateur specifie.
    :param role_id:
    :param ids_contexts_by_courses:
    :param id_user:
    :return:
    &#34;&#34;&#34;
    # Suppression des enrolments dans les cours
    for id_course in ids_contexts_by_courses:
        # Recuperation de la methode d&#39;enrolment
        id_enrol = self.get_id_enrol(ENROL_METHOD_MANUAL, role_id, id_course)
        if not id_enrol:
            continue
        # Suppression de l&#39;enrolment associe
        id_user_enrolment = self.get_id_user_enrolment(id_enrol, id_user)
        if id_user_enrolment:
            s = &#34;DELETE FROM {entete}user_enrolments &#34; \
                &#34;WHERE id = %(id_user_enrolment)s&#34; \
                .format(entete=self.entete)
            self.mark.execute(s, params={&#39;id_user_enrolment&#39;: id_user_enrolment})

    # Suppression des roles dans les contextes
    ids_list, ids_list_params = array_to_safe_sql_list(ids_contexts_by_courses.values(), &#39;ids_list&#39;)
    s = &#34;DELETE FROM {entete}role_assignments&#34; \
        &#34; WHERE roleid = %(role_id)s&#34; \
        &#34; AND contextid IN ({ids_list})&#34; \
        &#34; AND userid = %(id_user)s&#34; \
        .format(entete=self.entete, ids_list=ids_list)
    self.mark.execute(s, params={&#39;role_id&#39;: role_id, &#39;id_user&#39;: id_user, **ids_list_params})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.delete_roles"><code class="name flex">
<span>def <span class="ident">delete_roles</span></span>(<span>self, ids_roles)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de supprimer des roles.
:param ids_roles:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_roles(self, ids_roles):
    &#34;&#34;&#34;
    Fonction permettant de supprimer des roles.
    :param ids_roles:
    :return:
    &#34;&#34;&#34;
    # Construction de la liste des ids des roles concernes
    ids_list, ids_list_params = array_to_safe_sql_list(ids_roles, &#39;ids_list&#39;)
    s = &#34;DELETE FROM {entete}role_assignments&#34; \
        &#34; WHERE id IN ({ids_list})&#34; \
        .format(entete=self.entete, ids_list=ids_list)
    self.mark.execute(s, params={**ids_list_params})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ferme la connexion à la base de données Moodle
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    &#34;&#34;&#34;
    Ferme la connexion à la base de données Moodle
    :return:
    &#34;&#34;&#34;
    if self.mark:
        self.mark.close()
        self.mark = None
    if self.connection:
        self.connection.close()
        self.connection = None</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.disenroll_user_from_cohort"><code class="name flex">
<span>def <span class="ident">disenroll_user_from_cohort</span></span>(<span>self, id_cohort, id_user)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'enlever un utilisateur d'une
cohorte.
:param id_cohort:
:param id_user:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disenroll_user_from_cohort(self, id_cohort, id_user):
    &#34;&#34;&#34;
    Fonction permettant d&#39;enlever un utilisateur d&#39;une
    cohorte.
    :param id_cohort:
    :param id_user:
    :return:
    &#34;&#34;&#34;
    s = &#34;DELETE FROM {entete}cohort_members&#34; \
        &#34; WHERE cohortid = %(id_cohort)s&#34; \
        &#34; AND userid = %(id_user)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;id_cohort&#39;: id_cohort, &#39;id_user&#39;: id_user})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.disenroll_user_from_cohorts"><code class="name flex">
<span>def <span class="ident">disenroll_user_from_cohorts</span></span>(<span>self, ids_cohorts_to_keep, id_user)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'enlever un utilisateur d'une
ou plusieurs cohortes.
Seules les inscriptions dans les cohortes passees en
parametres sont conservees.
:param ids_cohorts_to_keep:
:param id_user:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disenroll_user_from_cohorts(self, ids_cohorts_to_keep, id_user):
    &#34;&#34;&#34;
    Fonction permettant d&#39;enlever un utilisateur d&#39;une
    ou plusieurs cohortes.
    Seules les inscriptions dans les cohortes passees en
    parametres sont conservees.
    :param ids_cohorts_to_keep:
    :param id_user:
    :return:
    &#34;&#34;&#34;
    # Construction de la liste des ids des cohortes concernes
    ids_list, ids_list_params = array_to_safe_sql_list(ids_cohorts_to_keep, &#39;ids_list&#39;)
    s = &#34;DELETE FROM {entete}cohort_members&#34; \
        &#34; WHERE userid = %(id_user)s&#34; \
        &#34; AND cohortid NOT IN ({ids_list})&#34; \
        .format(entete=self.entete, ids_list=ids_list)
    self.mark.execute(s, params={&#39;id_user&#39;: id_user, **ids_list_params})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.disenroll_user_from_username_and_cohortid"><code class="name flex">
<span>def <span class="ident">disenroll_user_from_username_and_cohortid</span></span>(<span>self, username: str, cohortid)</span>
</code></dt>
<dd>
<div class="desc"><p>Désenrole un utilisateur d'une cohorte.
:param username:
:param cohortid:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disenroll_user_from_username_and_cohortid(self, username: str, cohortid):
    &#34;&#34;&#34;
    Désenrole un utilisateur d&#39;une cohorte.
    :param username:
    :param cohortid:
    :return:
    &#34;&#34;&#34;
    self.mark.execute(&#34;DELETE {entete}cohort_members FROM {entete}cohort_members&#34;
                      &#34; INNER JOIN {entete}cohort&#34;
                      &#34; ON {entete}cohort_members.cohortid = {entete}cohort.id&#34;
                      &#34; INNER JOIN {entete}user&#34;
                      &#34; ON {entete}cohort_members.userid = {entete}user.id&#34;
                      &#34; WHERE {entete}user.username = %(username)s&#34;
                      &#34; AND {entete}cohort.id = %(cohortid)s&#34;.format(entete=self.entete),
                      params={
                          &#39;username&#39;: username,
                          &#39;cohortid&#39;: cohortid
                      })</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.disenroll_user_from_username_and_cohortname"><code class="name flex">
<span>def <span class="ident">disenroll_user_from_username_and_cohortname</span></span>(<span>self, username, cohortname)</span>
</code></dt>
<dd>
<div class="desc"><p>Désenrole un utilisateur d'une cohorte.
:param username:
:param cohortname:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disenroll_user_from_username_and_cohortname(self, username, cohortname):
    &#34;&#34;&#34;
    Désenrole un utilisateur d&#39;une cohorte.
    :param username:
    :param cohortname:
    :return:
    &#34;&#34;&#34;
    self.mark.execute(&#34;DELETE {entete}cohort_members FROM {entete}cohort_members&#34;
                      &#34; INNER JOIN {entete}cohort&#34;
                      &#34; ON {entete}cohort_members.cohortid = {entete}cohort.id&#34;
                      &#34; INNER JOIN {entete}user&#34;
                      &#34; ON {entete}cohort_members.userid = {entete}user.id&#34;
                      &#34; WHERE {entete}user.username = %(username)s&#34;
                      &#34; AND {entete}cohort.name = %(cohortname)s&#34;.format(entete=self.entete),
                      params={
                          &#39;username&#39;: username,
                          &#39;cohortname&#39;: cohortname
                      })</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.eleve_has_references"><code class="name flex">
<span>def <span class="ident">eleve_has_references</span></span>(<span>self, user_id: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Indique si un élève dipose de références dans des exercices ou des notations moodle
Les références comprennent :
- des notes obtenues dans n'importe quelle activité (historique de notes)
- des réponses à une activité (feedback, test, consultation, sondage)
- des participations à une activités (forum, chat)
:param user_id: L'id de l'utilisateur qu'on veut vérifier
:returns: Un booléen à vrai si l'utilisateur à des références, faux sinon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eleve_has_references(self, user_id: int):
    &#34;&#34;&#34;
    Indique si un élève dipose de références dans des exercices ou des notations moodle
    Les références comprennent :
    - des notes obtenues dans n&#39;importe quelle activité (historique de notes)
    - des réponses à une activité (feedback, test, consultation, sondage)
    - des participations à une activités (forum, chat)
    :param user_id: L&#39;id de l&#39;utilisateur qu&#39;on veut vérifier
    :returns: Un booléen à vrai si l&#39;utilisateur à des références, faux sinon
    &#34;&#34;&#34;

    #Dès qu&#39;on trouve une référence on renvoie True
    s = &#34;SELECT count(*) FROM {entete}forum_posts WHERE userid = %(userid)s&#34;.format(entete=self.entete)
    self.mark.execute(s, params={&#39;userid&#39;: user_id})
    if self.mark.fetchone()[0] &gt; 0:
        return True

    s = &#34;SELECT count(*) FROM {entete}grade_grades_history WHERE userid = %(userid)s&#34;.format(entete=self.entete)
    self.mark.execute(s, params={&#39;userid&#39;: user_id})
    if self.mark.fetchone()[0] &gt; 0:
        return True

    s = &#34;SELECT count(*) FROM {entete}feedback_completed WHERE userid = %(userid)s&#34;.format(entete=self.entete)
    self.mark.execute(s, params={&#39;userid&#39;: user_id})
    if self.mark.fetchone()[0] &gt; 0:
        return True

    s = &#34;SELECT count(*) FROM {entete}chat_messages WHERE userid = %(userid)s&#34;.format(entete=self.entete)
    self.mark.execute(s, params={&#39;userid&#39;: user_id})
    if self.mark.fetchone()[0] &gt; 0:
        return True

    s = &#34;SELECT count(*) FROM {entete}course_modules_completion WHERE userid = %(userid)s&#34;.format(entete=self.entete)
    self.mark.execute(s, params={&#39;userid&#39;: user_id})
    if self.mark.fetchone()[0] &gt; 0:
        return True

    s = &#34;SELECT count(*) FROM {entete}quiz_attempts WHERE userid = %(userid)s&#34;.format(entete=self.entete)
    self.mark.execute(s, params={&#39;userid&#39;: user_id})
    if self.mark.fetchone()[0] &gt; 0:
        return True

    s = &#34;SELECT count(*) FROM {entete}survey_answers WHERE userid = %(userid)s&#34;.format(entete=self.entete)
    self.mark.execute(s, params={&#39;userid&#39;: user_id})
    if self.mark.fetchone()[0] &gt; 0:
        return True

    s = &#34;SELECT count(*) FROM {entete}choice_answers WHERE userid = %(userid)s&#34;.format(entete=self.entete)
    self.mark.execute(s, params={&#39;userid&#39;: user_id})
    if self.mark.fetchone()[0] &gt; 0:
        return True

    #Si jamais on n&#39;a trouvé aucune référence, alors on peut renvoyer False
    return False</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.enroll_user_in_cohort"><code class="name flex">
<span>def <span class="ident">enroll_user_in_cohort</span></span>(<span>self, id_cohort, id_user, time_added)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'ajouter un utilisateur a une
cohorte.
:param id_cohort:
:param id_user:
:param time_added:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enroll_user_in_cohort(self, id_cohort, id_user, time_added):
    &#34;&#34;&#34;
    Fonction permettant d&#39;ajouter un utilisateur a une
    cohorte.
    :param id_cohort:
    :param id_user:
    :param time_added:
    :return:
    &#34;&#34;&#34;
    s = &#34;INSERT IGNORE&#34; \
        &#34; INTO {entete}cohort_members(cohortid, userid, timeadded)&#34; \
        &#34; VALUES (%(id_cohort)s, %(id_user)s, %(time_added)s)&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;id_cohort&#39;: id_cohort, &#39;id_user&#39;: id_user, &#39;time_added&#39;: time_added})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.enroll_user_in_course"><code class="name flex">
<span>def <span class="ident">enroll_user_in_course</span></span>(<span>self, role_id, id_course, id_user)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'enroler un utilisateur dans un cours
:param role_id: L'id du rôle à donner à l'utilisateur dans le cours
:param id_course: L'id du cours dans lequel on veut inscrire l'utilisateur
:param id_user: L'id de l'utilisateur à inscrire
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enroll_user_in_course(self, role_id, id_course, id_user):
    &#34;&#34;&#34;
    Fonction permettant d&#39;enroler un utilisateur dans un cours
    :param role_id: L&#39;id du rôle à donner à l&#39;utilisateur dans le cours
    :param id_course: L&#39;id du cours dans lequel on veut inscrire l&#39;utilisateur
    :param id_user: L&#39;id de l&#39;utilisateur à inscrire
    :return:
    &#34;&#34;&#34;
    id_enrol = self.get_id_enrol(ENROL_METHOD_MANUAL, role_id, id_course)
    if not id_enrol:
        # Ajout de la methode d&#39;enrolment dans le cours
        s = &#34;INSERT INTO {entete}enrol(enrol, courseid, roleid)&#34; \
            &#34; VALUES (%(ENROL_METHOD_MANUAL)s, %(id_course)s, %(role_id)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;ENROL_METHOD_MANUAL&#39;: ENROL_METHOD_MANUAL, &#39;id_course&#39;: id_course,
                                     &#39;role_id&#39;: role_id})
        id_enrol = self.get_id_enrol_max()
    if id_enrol:
        # Enrolement de l&#39;utilisateur dans le cours
        s = &#34;INSERT IGNORE INTO {entete}user_enrolments(enrolid, userid)&#34; \
            &#34; VALUES (%(id_enrol)s, %(id_user)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(s, params={&#39;id_enrol&#39;: id_enrol, &#39;id_user&#39;: id_user})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.enseignant_has_references"><code class="name flex">
<span>def <span class="ident">enseignant_has_references</span></span>(<span>self, user_id: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Indique si un enseignant dipose de références dans des exercices ou des notations moodle
Les références comprennent :
- des notes qui ont été données à des étudiants dans des cours
:param user_id: L'id de l'utilisateur qu'on veut vérifier
:returns: Un booléen à vrai si l'utilisateur à des références, faux sinon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enseignant_has_references(self, user_id: int):
    &#34;&#34;&#34;
    Indique si un enseignant dipose de références dans des exercices ou des notations moodle
    Les références comprennent :
    - des notes qui ont été données à des étudiants dans des cours
    :param user_id: L&#39;id de l&#39;utilisateur qu&#39;on veut vérifier
    :returns: Un booléen à vrai si l&#39;utilisateur à des références, faux sinon
    &#34;&#34;&#34;
    s = &#34;SELECT count(*) FROM {entete}grade_grades_history WHERE loggeduser = %(userid)s&#34;.format(entete=self.entete)
    self.mark.execute(s, params={&#39;userid&#39;: user_id})
    if self.mark.fetchone()[0] &gt; 0:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_all_valid_users"><code class="name flex">
<span>def <span class="ident">get_all_valid_users</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne tous les utilisateurs de la base de données qui ne sont pas marqués comme "supprimés"
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_valid_users(self):
    &#34;&#34;&#34;
    Retourne tous les utilisateurs de la base de données qui ne sont pas marqués comme &#34;supprimés&#34;
    :return:
    &#34;&#34;&#34;
    self.mark.execute(&#34;SELECT&#34;
                      &#34; id AS id,&#34;
                      &#34; username AS username,&#34;
                      &#34; lastlogin AS lastlogin&#34;
                      &#34; FROM {entete}user WHERE deleted = 0&#34;.format(entete=self.entete))
    return self.mark.fetchall()</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_cohort_members"><code class="name flex">
<span>def <span class="ident">get_cohort_members</span></span>(<span>self, cohortid) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Obtient les noms d'utilisateurs membres de la cohorte.
:param cohortid:
:return: list de username</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cohort_members(self, cohortid) -&gt; list:
    &#34;&#34;&#34;
    Obtient les noms d&#39;utilisateurs membres de la cohorte.
    :param cohortid:
    :return: list de username
    &#34;&#34;&#34;
    self.mark.execute(&#34;SELECT {entete}user.username FROM {entete}cohort_members&#34;
                      &#34; INNER JOIN {entete}user ON {entete}cohort_members.userid = {entete}user.id&#34;
                      &#34; WHERE cohortid = %(cohortid)s&#34;
                      .format(entete=self.entete),
                      params={
                          &#39;cohortid&#39;: cohortid
                      })
    return map(lambda r: r[0], self.mark.fetchall())</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_cohort_name"><code class="name flex">
<span>def <span class="ident">get_cohort_name</span></span>(<span>self, id_cohort)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer le nom d'une cohorte.
:param id_cohort:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cohort_name(self, id_cohort):
    &#34;&#34;&#34;
    Fonction permettant de recuperer le nom d&#39;une cohorte.
    :param id_cohort:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT name FROM {entete}cohort&#34; \
        &#34; WHERE id = %(id_cohort)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;id_cohort&#39;: id_cohort})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_course_timemodified"><code class="name flex">
<span>def <span class="ident">get_course_timemodified</span></span>(<span>self, course_id: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_course_timemodified(self, course_id: int):
    s = &#34;SELECT timemodified FROM {entete}course&#34; \
        &#34; WHERE id = %(course_id)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;course_id&#39;: course_id})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_courses_ids_owned_by"><code class="name flex">
<span>def <span class="ident">get_courses_ids_owned_by</span></span>(<span>self, user_id: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Recherche tous les cours dont l'utilisateur est propriétaire
:param user_id: L'id de l'utilisateur concerné
:returns: La liste des cours dont l'utilisateur est propriétaire</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_courses_ids_owned_by(self, user_id: int):
    &#34;&#34;&#34;
    Recherche tous les cours dont l&#39;utilisateur est propriétaire
    :param user_id: L&#39;id de l&#39;utilisateur concerné
    :returns: La liste des cours dont l&#39;utilisateur est propriétaire
    &#34;&#34;&#34;
    s = &#34;SELECT instanceid FROM {entete}context AS context&#34; \
        &#34; INNER JOIN {entete}role_assignments AS role_assignments&#34; \
        &#34; ON context.id = role_assignments.contextid&#34; \
        &#34; WHERE role_assignments.userid = %(userid)s AND role_assignments.roleid = %(roleid)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;userid&#39;: user_id, &#39;roleid&#39;: self.constantes.id_role_proprietaire_cours})
    return self.mark.fetchall()</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_courses_ids_owned_or_teach"><code class="name flex">
<span>def <span class="ident">get_courses_ids_owned_or_teach</span></span>(<span>self, user_id: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne tous les cours auxquels participe un utilisateur
en tant qu'enseignant (role enseignant ou propriétaire de cours)
:param user_id: L'id de l'utilisateur concerné
:returns: La liste des cours dans lequel enseigne l'utilisateur</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_courses_ids_owned_or_teach(self, user_id: int):
    &#34;&#34;&#34;
    Retourne tous les cours auxquels participe un utilisateur
    en tant qu&#39;enseignant (role enseignant ou propriétaire de cours)
    :param user_id: L&#39;id de l&#39;utilisateur concerné
    :returns: La liste des cours dans lequel enseigne l&#39;utilisateur
    &#34;&#34;&#34;
    s = &#34;SELECT instanceid FROM {entete}context AS context&#34; \
        &#34; INNER JOIN {entete}role_assignments AS role_assignments&#34; \
        &#34; ON context.id = role_assignments.contextid&#34; \
        &#34; WHERE role_assignments.userid = %(userid)s AND (role_assignments.roleid = %(roleidowner)s&#34; \
        &#34; OR role_assignments.roleid = %(roleidteacher)s)&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;userid&#39;: user_id, &#39;roleidowner&#39;: self.constantes.id_role_proprietaire_cours,
    &#39;roleidteacher&#39;: self.constantes.id_role_enseignant})
    return self.mark.fetchall()</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_description_course_category"><code class="name flex">
<span>def <span class="ident">get_description_course_category</span></span>(<span>self, id_category)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer la description d'une
categorie.
:param id_category:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_description_course_category(self, id_category):
    &#34;&#34;&#34;
    Fonction permettant de recuperer la description d&#39;une
    categorie.
    :param id_category:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT description&#34; \
        &#34; FROM {entete}course_categories&#34; \
        &#34; WHERE id = %(id_category)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;id_category&#39;: id_category})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_descriptions_course_categories_by_themes"><code class="name flex">
<span>def <span class="ident">get_descriptions_course_categories_by_themes</span></span>(<span>self, themes)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer les descriptions de categories.
:param themes:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_descriptions_course_categories_by_themes(self, themes):
    &#34;&#34;&#34;
    Fonction permettant de recuperer les descriptions de categories.
    :param themes:
    :return:
    &#34;&#34;&#34;
    ids_list, ids_list_params = array_to_safe_sql_list(themes, &#39;ids_list&#39;)
    s = &#34;SELECT description&#34; \
        &#34; FROM {entete}course_categories&#34; \
        &#34; WHERE theme IN ({ids_list})&#34; \
        .format(entete=self.entete, ids_list=ids_list)
    self.mark.execute(s, params={**ids_list_params})
    result_set = self.mark.fetchall()
    if not result_set:
        return []
    descriptions = [result[0] for result in result_set]
    return descriptions</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_empty_cohorts"><code class="name flex">
<span>def <span class="ident">get_empty_cohorts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne la liste des ids de toutes les cohortes qui n'ont aucun membre
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_empty_cohorts(self):
    &#34;&#34;&#34;
    Retourne la liste des ids de toutes les cohortes qui n&#39;ont aucun membre
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id FROM {entete}cohort WHERE id NOT IN (SELECT cohortid FROM {entete}cohort_members)&#34; \
        .format(entete=self.entete)
    self.mark.execute(s)
    result_set = self.mark.fetchall()
    if not result_set:
        return []
    cohort_ids = [result[0] for result in result_set]
    return cohort_ids</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_field_domaine"><code class="name flex">
<span>def <span class="ident">get_field_domaine</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction pour récupére l'id du champ Domaine
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_field_domaine(self):
    &#34;&#34;&#34;
    Fonction pour récupére l&#39;id du champ Domaine
    :return:
    &#34;&#34;&#34;
    id_field_domaine = []
    sql = &#34;SELECT id&#34; \
          &#34; FROM {entete}user_info_field&#34; \
          &#34; WHERE shortname = &#39;Domaine&#39;&#34; \
          &#34; AND name =&#39;Domaine&#39;&#34; \
        .format(entete=self.entete)
    self.mark.execute(sql)
    row = self.mark.fetchall()

    # Si le champ n&#39;existe pas, on le crée et on récupère l&#39;id
    if not bool(row):
        id_field_domaine = 0
    else:
        id_field_domaine = row[0][0]

    return id_field_domaine</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_block"><code class="name flex">
<span>def <span class="ident">get_id_block</span></span>(<span>self, parent_context_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id d'un bloc.
:param parent_context_id:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_block(self, parent_context_id):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id d&#39;un bloc.
    :param parent_context_id:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id&#34; \
        &#34; FROM {entete}block_instances&#34; \
        &#34; WHERE parentcontextid = %(parent_context_id)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;parent_context_id&#39;: parent_context_id})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_categorie"><code class="name flex">
<span>def <span class="ident">get_id_categorie</span></span>(<span>self, categorie_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id correspondant a la
categorie inter-etablissements.
:param categorie_name:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_categorie(self, categorie_name):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id correspondant a la
    categorie inter-etablissements.
    :param categorie_name:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id&#34; \
        &#34; FROM {entete}course_categories&#34; \
        &#34; WHERE name = %(categorie_name)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;categorie_name&#39;: categorie_name})
    ligne = self.safe_fetchone()
    return ligne[0] if ligne else None</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_cohort"><code class="name flex">
<span>def <span class="ident">get_id_cohort</span></span>(<span>self, id_context, cohort_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id d'une cohorte
par son nom et son contexte de rattachement.
:param id_context:
:param cohort_name:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_cohort(self, id_context, cohort_name):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id d&#39;une cohorte
    par son nom et son contexte de rattachement.
    :param id_context:
    :param cohort_name:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id&#34; \
        &#34; FROM {entete}cohort&#34; \
        &#34; WHERE contextid = %(id_context)s&#34; \
        &#34; AND name = %(cohort_name)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;id_context&#39;: id_context, &#39;cohort_name&#39;: cohort_name})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_context"><code class="name flex">
<span>def <span class="ident">get_id_context</span></span>(<span>self, context_level, depth, instance_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id d'un contexte via
le niveau, la profondeur et l'id de l'instance associee.
:param context_level:
:param depth:
:param instance_id:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_context(self, context_level, depth, instance_id):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id d&#39;un contexte via
    le niveau, la profondeur et l&#39;id de l&#39;instance associee.
    :param context_level:
    :param depth:
    :param instance_id:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id&#34; \
        &#34; FROM {entete}context&#34; \
        &#34; WHERE contextlevel = %(context_level)s&#34; \
        &#34; AND depth = %(depth)s&#34; \
        &#34; AND instanceid = %(instance_id)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;context_level&#39;: context_level, &#39;depth&#39;: depth, &#39;instance_id&#39;: instance_id})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_context_categorie"><code class="name flex">
<span>def <span class="ident">get_id_context_categorie</span></span>(<span>self, id_etab_categorie)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id d'une contexte via
l'id d'un etablissement.
:param id_etab_categorie:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_context_categorie(self, id_etab_categorie):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id d&#39;une contexte via
    l&#39;id d&#39;un etablissement.
    :param id_etab_categorie:
    :return:
    &#34;&#34;&#34;
    return self.get_id_context(self.constantes.niveau_ctx_categorie, 2, id_etab_categorie)</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_context_inter_etabs"><code class="name flex">
<span>def <span class="ident">get_id_context_inter_etabs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id du contexte de la categorie inter-etablissements
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_context_inter_etabs(self):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id du contexte de la categorie inter-etablissements
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id&#34; \
        &#34; FROM {entete}context&#34; \
        &#34; WHERE contextlevel = %(context_level)s&#34; \
        &#34; AND instanceid = %(instanceid)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;context_level&#39;: self.constantes.niveau_ctx_categorie,
                                 &#39;instanceid&#39;: self.constantes.id_instance_moodle})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_context_no_depth"><code class="name flex">
<span>def <span class="ident">get_id_context_no_depth</span></span>(<span>self, context_level, instance_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id d'un contexte via
le niveau et l'id de l'instance associee.
:param context_level:
:param instance_id:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_context_no_depth(self, context_level, instance_id):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id d&#39;un contexte via
    le niveau et l&#39;id de l&#39;instance associee.
    :param context_level:
    :param instance_id:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id&#34; \
        &#34; FROM {entete}context&#34; \
        &#34; WHERE contextlevel = %(context_level)s&#34; \
        &#34; AND instanceid = %(instance_id)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;context_level&#39;: context_level, &#39;instance_id&#39;: instance_id})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_course_by_id_number"><code class="name flex">
<span>def <span class="ident">get_id_course_by_id_number</span></span>(<span>self, id_number)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id d'un cours a partir de son idnumber.
:param id_number:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_course_by_id_number(self, id_number):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id d&#39;un cours a partir de son idnumber.
    :param id_number:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id&#34; \
        &#34; FROM {entete}course&#34; \
        &#34; WHERE idnumber = %(id)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;id&#39;: id_number})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_course_category_by_id_number"><code class="name flex">
<span>def <span class="ident">get_id_course_category_by_id_number</span></span>(<span>self, id_number)</span>
</code></dt>
<dd>
<div class="desc"><p>Récupère l'id d'une categorie à partir de son idnumber.
:param id_number:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_course_category_by_id_number(self, id_number):
    &#34;&#34;&#34;
    Récupère l&#39;id d&#39;une categorie à partir de son idnumber.
    :param id_number:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id&#34; \
        &#34; FROM {entete}course_categories&#34; \
        &#34; WHERE idnumber&#34; \
        &#34; LIKE %(id)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;id&#39;: &#39;%&#39; + str(id_number) + &#39;%&#39;})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_course_category_by_theme"><code class="name flex">
<span>def <span class="ident">get_id_course_category_by_theme</span></span>(<span>self, theme)</span>
</code></dt>
<dd>
<div class="desc"><p>Récupère l'id d'une categorie à partir de son theme.
:param theme:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_course_category_by_theme(self, theme):
    &#34;&#34;&#34;
    Récupère l&#39;id d&#39;une categorie à partir de son theme.
    :param theme:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id&#34; \
        &#34; FROM {entete}course_categories&#34; \
        &#34; WHERE theme = %(theme)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;theme&#39;: theme})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_course_module"><code class="name flex">
<span>def <span class="ident">get_id_course_module</span></span>(<span>self, course)</span>
</code></dt>
<dd>
<div class="desc"><p>Récupère l'id d'un module de cours.
:param course:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_course_module(self, course):
    &#34;&#34;&#34;
    Récupère l&#39;id d&#39;un module de cours.
    :param course:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id&#34; \
        &#34; FROM {entete}course_modules&#34; \
        &#34; WHERE course = %(course)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;course&#39;: course})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_enrol"><code class="name flex">
<span>def <span class="ident">get_id_enrol</span></span>(<span>self, enrol_method, role_id, id_course)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer un id
dans la table permettant les enrolments
:param enrol_method:
:param role_id:
:param id_course:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_enrol(self, enrol_method, role_id, id_course):
    &#34;&#34;&#34;
    Fonction permettant de recuperer un id
    dans la table permettant les enrolments
    :param enrol_method:
    :param role_id:
    :param id_course:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT e.id FROM {entete}enrol AS e&#34; \
        &#34; WHERE e.enrol = %(enrol_method)s&#34; \
        &#34; AND e.courseid = %(id_course)s&#34; \
        &#34; AND e.roleid = %(role_id)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;enrol_method&#39;: enrol_method, &#39;id_course&#39;: id_course, &#39;role_id&#39;: role_id})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_enrol_max"><code class="name flex">
<span>def <span class="ident">get_id_enrol_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Récupère l'id maximum present dans la table permettant les enrolments
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_enrol_max(self):
    &#34;&#34;&#34;
    Récupère l&#39;id maximum present dans la table permettant les enrolments
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id FROM {entete}enrol&#34; \
        &#34; ORDER BY id DESC LIMIT 1&#34; \
        .format(entete=self.entete)
    self.mark.execute(s)
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_forum"><code class="name flex">
<span>def <span class="ident">get_id_forum</span></span>(<span>self, course)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id du contexte propre
a moodle.
:param course:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_forum(self, course):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id du contexte propre
    a moodle.
    :param course:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id&#34; \
        &#34; FROM {entete}forum&#34; \
        &#34; WHERE course = %(course)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;course&#39;: course})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_role_admin_local"><code class="name flex">
<span>def <span class="ident">get_id_role_admin_local</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id du role admin local
au sein de la BD moodle.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_role_admin_local(self):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id du role admin local
    au sein de la BD moodle.
    :return:
    &#34;&#34;&#34;
    return self.get_id_role_by_shortname(SHORTNAME_ADMIN_LOCAL)</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_role_assignment"><code class="name flex">
<span>def <span class="ident">get_id_role_assignment</span></span>(<span>self, role_id, id_context, id_user)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id d'un role
assignement au sein de la BD moodle.
:param role_id: int
:param id_context: int
:param id_user: int
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_role_assignment(self, role_id, id_context, id_user):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id d&#39;un role
    assignement au sein de la BD moodle.
    :param role_id: int
    :param id_context: int
    :param id_user: int
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id FROM {entete}role_assignments&#34; \
        &#34; WHERE roleid = %(role_id)s AND contextid = %(id_context)s AND userid = %(id_user)s&#34; \
        &#34; LIMIT 1&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;role_id&#39;: role_id, &#39;id_context&#39;: id_context, &#39;id_user&#39;: id_user})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_role_by_shortname"><code class="name flex">
<span>def <span class="ident">get_id_role_by_shortname</span></span>(<span>self, short_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id d'un role via son shortname
:param short_name:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_role_by_shortname(self, short_name):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id d&#39;un role via son shortname
    :param short_name:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id FROM {entete}role&#34; \
        &#34; WHERE shortname = %(short_name)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;short_name&#39;: short_name})
    ligne = self.safe_fetchone()
    if ligne is None:
        raise ValueError(&#34;Le rôle %s n&#39;existe pas.&#34; % short_name)
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_user_enrolment"><code class="name flex">
<span>def <span class="ident">get_id_user_enrolment</span></span>(<span>self, id_enrol, id_user)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id d'un user enrolment
:param id_enrol:
:param id_user:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_user_enrolment(self, id_enrol, id_user):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id d&#39;un user enrolment
    :param id_enrol:
    :param id_user:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id&#34; \
        &#34; FROM {entete}user_enrolments &#34; \
        &#34; WHERE userid = %(id_user)s&#34; \
        &#34; AND enrolid = %(id_enrol)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;id_user&#39;: id_user, &#39;id_enrol&#39;: id_enrol})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_user_info_data"><code class="name flex">
<span>def <span class="ident">get_id_user_info_data</span></span>(<span>self, id_user, id_field)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id d'un info data via
l'id-user et l'id_field
:param id_user:
:param id_field:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_user_info_data(self, id_user, id_field):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id d&#39;un info data via
    l&#39;id-user et l&#39;id_field
    :param id_user:
    :param id_field:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id&#34; \
        &#34; FROM {entete}user_info_data &#34; \
        &#34; WHERE userid = %(id_user)s&#34; \
        &#34; AND fieldid = %(id_field)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;id_user&#39;: id_user, &#39;id_field&#39;: id_field})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_id_user_info_field_by_shortname"><code class="name flex">
<span>def <span class="ident">get_id_user_info_field_by_shortname</span></span>(<span>self, short_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id d'un info field via
son shortname.
:param short_name:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_user_info_field_by_shortname(self, short_name):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id d&#39;un info field via
    son shortname.
    :param short_name:
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id&#34; \
        &#34; FROM {entete}user_info_field&#34; \
        &#34; WHERE shortname = %(short_name)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;short_name&#39;: short_name})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_ids_and_summaries_not_allowed_roles"><code class="name flex">
<span>def <span class="ident">get_ids_and_summaries_not_allowed_roles</span></span>(<span>self, id_user, allowed_forums_shortnames)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer les ids des roles non
autorises sur les forums, ainsi que les non des forums
sur lesquels portent ces roles.
:param id_user:
:param allowed_forums_shortnames:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ids_and_summaries_not_allowed_roles(self, id_user, allowed_forums_shortnames):
    &#34;&#34;&#34;
    Fonction permettant de recuperer les ids des roles non
    autorises sur les forums, ainsi que les non des forums
    sur lesquels portent ces roles.
    :param id_user:
    :param allowed_forums_shortnames:
    :return:
    &#34;&#34;&#34;
    # Construction de la liste des shortnames
    ids_list, ids_list_params = array_to_safe_sql_list(allowed_forums_shortnames, &#39;ids_list&#39;)
    s = &#34;SELECT mra.id, mco.summary&#34; \
        &#34; FROM {entete}course mco, {entete}role_assignments mra, {entete}context mc&#34; \
        &#34; WHERE mco.shortname LIKE &#39;ZONE-PRIVEE-%%&#39;&#34; \
        &#34; AND mco.shortname NOT IN ({ids_list})&#34; \
        &#34; AND mco.id = mc.instanceid&#34; \
        &#34; AND mc.contextlevel = 50&#34; \
        &#34; AND mc.id = mra.contextid&#34; \
        &#34; AND mra.userid = %(id_user)s&#34; \
        .format(entete=self.entete, ids_list=ids_list)
    self.mark.execute(s, params={&#39;id_user&#39;: id_user, **ids_list_params})
    result_set = self.mark.fetchall()
    if not result_set:
        return [], []
    # Recuperation des ids et themes non autorises
    ids = [result[0] for result in result_set]
    summaries = [result[1] for result in result_set]
    return ids, summaries</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_ids_and_themes_not_allowed_roles"><code class="name flex">
<span>def <span class="ident">get_ids_and_themes_not_allowed_roles</span></span>(<span>self, id_user, allowed_themes)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer les ids des roles qui ne sont pas autorises pour l'utilisateur.
:param id_user:
:param allowed_themes:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ids_and_themes_not_allowed_roles(self, id_user, allowed_themes):
    &#34;&#34;&#34;
    Fonction permettant de recuperer les ids des roles qui ne sont pas autorises pour l&#39;utilisateur.
    :param id_user:
    :param allowed_themes:
    :return:
    &#34;&#34;&#34;
    # Construction de la liste des themes
    ids_list, ids_list_params = array_to_safe_sql_list(allowed_themes, &#39;ids_list&#39;)
    # Recuperation des roles sur les etablissements qui ne devraient plus exister
    # (quand le prof n&#39;est plus rattache aux etablissements)
    s = &#34;SELECT mra.id, mcc.theme&#34; \
        &#34; FROM {entete}course_categories mcc, {entete}context mc, {entete}role_assignments mra&#34; \
        &#34; WHERE mcc.theme NOT IN ({ids_list})&#34; \
        &#34; AND mcc.theme IS NOT NULL&#34; \
        &#34; AND mcc.id = mc.instanceid &#34; \
        &#34; AND mc.contextlevel = %(NIVEAU_CTX_CATEGORIE)s AND mc.depth = %(PROFONDEUR_CTX_ETAB)s&#34; \
        &#34; AND mc.id = mra.contextid&#34; \
        &#34; AND mra.userid = %(id_user)s&#34; \
        .format(entete=self.entete, ids_list=ids_list)
    self.mark.execute(s, params={**ids_list_params, &#39;NIVEAU_CTX_CATEGORIE&#39;: self.constantes.niveau_ctx_categorie,
                                 &#39;PROFONDEUR_CTX_ETAB&#39;: PROFONDEUR_CTX_ETAB, &#39;id_user&#39;: id_user})
    result_set = self.mark.fetchall()
    if not result_set:
        return [], []
    # Recuperation des ids et themes non autorises
    ids = [result[0] for result in result_set]
    themes = [result[1] for result in result_set]
    return ids, themes</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_timestamp_now"><code class="name flex">
<span>def <span class="ident">get_timestamp_now</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer le timestamp actuel.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_timestamp_now(self):
    &#34;&#34;&#34;
    Fonction permettant de recuperer le timestamp actuel.
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT UNIX_TIMESTAMP( now( ) ) - 3600*2&#34;
    self.mark.execute(s)
    now = self.mark.fetchone()[0]
    return now</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_user_data"><code class="name flex">
<span>def <span class="ident">get_user_data</span></span>(<span>self, user_id: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne les informations détaillées sur un utilisateur (table mdl_user)
:param user_id: L'id de l'utilisateur dont on veut récupére les infos
:returns: Un tuple représentant la ligne récupérée depuis la BD</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_data(self, user_id: int):
    &#34;&#34;&#34;
    Retourne les informations détaillées sur un utilisateur (table mdl_user)
    :param user_id: L&#39;id de l&#39;utilisateur dont on veut récupére les infos
    :returns: Un tuple représentant la ligne récupérée depuis la BD
    &#34;&#34;&#34;
    s = &#34;SELECT * FROM {entete}user WHERE id = %(userid)s&#34;.format(entete=self.entete)
    self.mark.execute(s, params={&#39;userid&#39;: user_id})
    return self.mark.fetchone()</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_user_filtered_cohorts"><code class="name flex">
<span>def <span class="ident">get_user_filtered_cohorts</span></span>(<span>self, contextid, cohortname_pattern)</span>
</code></dt>
<dd>
<div class="desc"><p>Obtient les cohortes de classes d'élèves
:param contextid:
:param cohortname_pattern:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_filtered_cohorts(self, contextid, cohortname_pattern):
    &#34;&#34;&#34;
    Obtient les cohortes de classes d&#39;élèves
    :param contextid:
    :param cohortname_pattern:
    :return:
    &#34;&#34;&#34;
    self.mark.execute(&#34;SELECT id, contextid, name FROM {entete}cohort&#34;
                      &#34; WHERE contextid = %(contextid)s AND name LIKE %(like)s&#34;
                      .format(entete=self.entete),
                      params={
                          &#39;contextid&#39;: contextid,
                          &#39;like&#39;: cohortname_pattern
                      })
    return [Cohort(cohortid=result[0], contextid=result[1], name=result[2]) for result in self.mark.fetchall()]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_user_id"><code class="name flex">
<span>def <span class="ident">get_user_id</span></span>(<span>self, username)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer l'id d'un
utilisateur moodle via son username.
:param username: str
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_id(self, username):
    &#34;&#34;&#34;
    Fonction permettant de recuperer l&#39;id d&#39;un
    utilisateur moodle via son username.
    :param username: str
    :return:
    &#34;&#34;&#34;
    s = &#34;SELECT id FROM {entete}user &#34; \
        &#34;WHERE username = %(username)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;username&#39;: username.lower()})
    ligne = self.safe_fetchone()
    if ligne is None:
        return None
    return ligne[0]</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_userids_owner_of_course"><code class="name flex">
<span>def <span class="ident">get_userids_owner_of_course</span></span>(<span>self, course_id: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne tous les utilisateurs qui sont propriétaires d'un cours
:param course_id: L'id du cours concerné
:returns: La liste des utilisateurs propriétaires du cours</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_userids_owner_of_course(self, course_id: int):
    &#34;&#34;&#34;
    Retourne tous les utilisateurs qui sont propriétaires d&#39;un cours
    :param course_id: L&#39;id du cours concerné
    :returns: La liste des utilisateurs propriétaires du cours
    &#34;&#34;&#34;
    s = &#34;SELECT userid FROM {entete}role_assignments AS role_assignments&#34; \
        &#34; INNER JOIN {entete}context AS context&#34; \
        &#34; ON role_assignments.contextid = context.id&#34; \
        &#34; WHERE context.instanceid = %(courseid)s AND role_assignments.roleid = %(roleid)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;courseid&#39;: course_id, &#39;roleid&#39;: self.constantes.id_role_proprietaire_cours})
    return self.mark.fetchall()</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.get_users_ids"><code class="name flex">
<span>def <span class="ident">get_users_ids</span></span>(<span>self, usernames)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de recuperer les ids des
utilisateurs moodle via leurs usernames.
:param usernames:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_users_ids(self, usernames):
    &#34;&#34;&#34;
    Fonction permettant de recuperer les ids des
    utilisateurs moodle via leurs usernames.
    :param usernames:
    :return:
    &#34;&#34;&#34;
    users_ids = []
    for username in usernames:
        user_id = self.get_user_id(username)
        users_ids.append(user_id)
    return users_ids</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.insert_moodle_block"><code class="name flex">
<span>def <span class="ident">insert_moodle_block</span></span>(<span>self, block_name, parent_context_id, show_in_subcontexts, page_type_pattern, sub_page_pattern, default_region, default_weight)</span>
</code></dt>
<dd>
<div class="desc"><p>Insère un bloc.
:param block_name:
:param parent_context_id:
:param show_in_subcontexts:
:param page_type_pattern:
:param sub_page_pattern:
:param default_region:
:param default_weight:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_moodle_block(self, block_name, parent_context_id, show_in_subcontexts, page_type_pattern,
                        sub_page_pattern, default_region, default_weight):
    &#34;&#34;&#34;
    Insère un bloc.
    :param block_name:
    :param parent_context_id:
    :param show_in_subcontexts:
    :param page_type_pattern:
    :param sub_page_pattern:
    :param default_region:
    :param default_weight:
    :return:
    &#34;&#34;&#34;
    s = &#34;INSERT INTO {entete}block_instances &#34; \
        &#34;( blockname, parentcontextid, showinsubcontexts, pagetypepattern, subpagepattern, defaultregion, &#34; \
        &#34;defaultweight, timecreated, timemodified ) &#34; \
        &#34; VALUES ( %(block_name)s, %(parent_context_id)s, %(show_in_subcontexts)s, %(page_type_pattern)s, &#34; \
        &#34;%(sub_page_pattern)s, %(default_region)s, %(default_weight)s, UNIX_TIMESTAMP( now( ) ) - 3600*2,&#34; \
        &#34;UNIX_TIMESTAMP( now( ) ) - 3600*2 )&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;block_name&#39;: block_name,
                                 &#39;parent_context_id&#39;: parent_context_id,
                                 &#39;show_in_subcontexts&#39;: show_in_subcontexts,
                                 &#39;page_type_pattern&#39;: page_type_pattern,
                                 &#39;sub_page_pattern&#39;: sub_page_pattern,
                                 &#39;default_region&#39;: default_region,
                                 &#39;default_weight&#39;: default_weight})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.insert_moodle_context"><code class="name flex">
<span>def <span class="ident">insert_moodle_context</span></span>(<span>self, context_level, depth, instance_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Insère un contexte.
:param context_level:
:param depth:
:param instance_id:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_moodle_context(self, context_level, depth, instance_id):
    &#34;&#34;&#34;
    Insère un contexte.
    :param context_level:
    :param depth:
    :param instance_id:
    :return:
    &#34;&#34;&#34;
    s = &#34;INSERT INTO {entete}context (contextlevel, instanceid, depth)&#34; \
        &#34; VALUES (%(context_level)s, %(instance_id)s,  %(depth)s)&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;context_level&#39;: context_level, &#39;instance_id&#39;: instance_id, &#39;depth&#39;: depth})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.insert_moodle_course"><code class="name flex">
<span>def <span class="ident">insert_moodle_course</span></span>(<span>self, id_category, full_name, id_number, short_name, summary, format_, visible, start_date, time_created, time_modified)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'inserer un cours.
:param id_category:
:param full_name:
:param id_number:
:param short_name:
:param summary:
:param format_:
:param visible:
:param start_date:
:param time_created:
:param time_modified:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_moodle_course(self, id_category, full_name, id_number, short_name, summary, format_, visible,
                         start_date, time_created, time_modified):
    &#34;&#34;&#34;
    Fonction permettant d&#39;inserer un cours.
    :param id_category:
    :param full_name:
    :param id_number:
    :param short_name:
    :param summary:
    :param format_:
    :param visible:
    :param start_date:
    :param time_created:
    :param time_modified:
    :return:
    &#34;&#34;&#34;
    s = &#34;INSERT INTO {entete}course &#34; \
        &#34;(category, fullname, idnumber, shortname, summary, &#34; \
        &#34;format, visible, startdate, timecreated, timemodified) &#34; \
        &#34; VALUES (%(id_category)s, %(full_name)s, %(id_number)s, %(short_name)s, %(summary)s, &#34; \
        &#34;%(format)s, %(visible)s, %(start_date)s, %(time_created)s, %(time_modified)s)&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;id_category&#39;: id_category,
                                 &#39;full_name&#39;: full_name,
                                 &#39;id_number&#39;: id_number,
                                 &#39;short_name&#39;: short_name,
                                 &#39;summary&#39;: summary,
                                 &#39;format&#39;: format_,
                                 &#39;visible&#39;: visible,
                                 &#39;start_date&#39;: start_date,
                                 &#39;time_created&#39;: time_created,
                                 &#39;time_modified&#39;: time_modified})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.insert_moodle_course_category"><code class="name flex">
<span>def <span class="ident">insert_moodle_course_category</span></span>(<span>self, name, id_number, description, theme)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'inserer une categorie.
:param name:
:param id_number:
:param description:
:param theme:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_moodle_course_category(self, name, id_number, description, theme):
    &#34;&#34;&#34;
    Fonction permettant d&#39;inserer une categorie.
    :param name:
    :param id_number:
    :param description:
    :param theme:
    :return:
    &#34;&#34;&#34;
    s = &#34;INSERT INTO {entete}course_categories&#34; \
        &#34; (name, idnumber, description, parent, sortorder, coursecount, visible, depth,theme)&#34; \
        &#34; VALUES(%(name)s, %(id_number)s, %(description)s, 0, 999,0, 1, 1, %(theme)s)&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;name&#39;: name, &#39;id_number&#39;: id_number, &#39;description&#39;: description, &#39;theme&#39;: theme})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.insert_moodle_course_module"><code class="name flex">
<span>def <span class="ident">insert_moodle_course_module</span></span>(<span>self, course, module, instance, added)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'inserer un module de cours.
:param course:
:param module:
:param instance:
:param added:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_moodle_course_module(self, course, module, instance, added):
    &#34;&#34;&#34;
    Fonction permettant d&#39;inserer un module de cours.
    :param course:
    :param module:
    :param instance:
    :param added:
    :return:
    &#34;&#34;&#34;
    s = &#34;INSERT INTO {entete}course_modules (course, module, instance, added)&#34; \
        &#34; VALUES (%(course)s , %(module)s, %(instance)s , %(added)s)&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;course&#39;: course, &#39;module&#39;: module, &#39;instance&#39;: instance, &#39;added&#39;: added})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.insert_moodle_enrol_capability"><code class="name flex">
<span>def <span class="ident">insert_moodle_enrol_capability</span></span>(<span>self, enrol, status, course_id, role_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'inserer une methode d'inscription
a un cours.
:param enrol:
:param status:
:param course_id:
:param role_id:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_moodle_enrol_capability(self, enrol, status, course_id, role_id):
    &#34;&#34;&#34;
    Fonction permettant d&#39;inserer une methode d&#39;inscription
    a un cours.
    :param enrol:
    :param status:
    :param course_id:
    :param role_id:
    :return:
    &#34;&#34;&#34;
    s = &#34;INSERT INTO {entete}enrol(enrol, status, courseid, roleid)&#34; \
        &#34; VALUES(%(enrol)s, %(status)s, %(course_id)s, %(role_id)s)&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;enrol&#39;: enrol, &#39;status&#39;: status, &#39;course_id&#39;: course_id, &#39;role_id&#39;: role_id})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.insert_moodle_forum"><code class="name flex">
<span>def <span class="ident">insert_moodle_forum</span></span>(<span>self, course, name, intro, intro_format, max_bytes, max_attachements, time_modified)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'inserer un forum.
:param course:
:param name:
:param intro:
:param intro_format:
:param max_bytes:
:param max_attachements:
:param time_modified:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_moodle_forum(self, course, name, intro, intro_format, max_bytes, max_attachements, time_modified):
    &#34;&#34;&#34;
    Fonction permettant d&#39;inserer un forum.
    :param course:
    :param name:
    :param intro:
    :param intro_format:
    :param max_bytes:
    :param max_attachements:
    :param time_modified:
    :return:
    &#34;&#34;&#34;
    s = &#34;INSERT INTO {entete}forum (course, name, intro, introformat, maxbytes, maxattachments, timemodified) &#34; \
        &#34;VALUES (%(course)s, %(name)s, %(intro)s, %(intro_format)s, %(max_bytes)s, %(max_attachements)s, &#34; \
        &#34;%(time_modified)s)&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;course&#39;: course,
                                 &#39;name&#39;: name,
                                 &#39;intro&#39;: intro,
                                 &#39;intro_format&#39;: intro_format,
                                 &#39;max_bytes&#39;: max_bytes,
                                 &#39;max_attachements&#39;: max_attachements,
                                 &#39;time_modified&#39;: time_modified})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.insert_moodle_local_admin"><code class="name flex">
<span>def <span class="ident">insert_moodle_local_admin</span></span>(<span>self, id_context_categorie, id_user)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'inserer un admin local pour un
contexte donne.
Retour True si insertion réalisée, False le cas échéant
:param id_context_categorie:
:param id_user:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_moodle_local_admin(self, id_context_categorie, id_user):
    &#34;&#34;&#34;
    Fonction permettant d&#39;inserer un admin local pour un
    contexte donne.
    Retour True si insertion réalisée, False le cas échéant
    :param id_context_categorie:
    :param id_user:
    :return:
    &#34;&#34;&#34;
    if self.is_moodle_local_admin(id_context_categorie, id_user):
        return False
    id_role_admin_local = self.get_id_role_admin_local()
    s = &#34;INSERT ignore INTO {entete}role_assignments(roleid, contextid, userid)&#34; \
        &#34; VALUES (%(id_role_admin_local)s, %(id_context_categorie)s, %(id_user)s)&#34; \
        .format(entete=self.entete)
    params = {&#39;id_role_admin_local&#39;: id_role_admin_local, &#39;id_context_categorie&#39;: id_context_categorie,
              &#39;id_user&#39;: id_user}
    self.mark.execute(s, params=params)
    return True</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.insert_moodle_user"><code class="name flex">
<span>def <span class="ident">insert_moodle_user</span></span>(<span>self, username, first_name, last_name, email, mail_display, theme)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'inserer un utilisateur dans Moodle.
:param username:
:param first_name:
:param last_name:
:param email:
:param mail_display:
:param theme:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_moodle_user(self, username, first_name, last_name, email, mail_display, theme):
    &#34;&#34;&#34;
    Fonction permettant d&#39;inserer un utilisateur dans Moodle.
    :param username:
    :param first_name:
    :param last_name:
    :param email:
    :param mail_display:
    :param theme:
    :return:
    &#34;&#34;&#34;
    user_id = self.get_user_id(username)
    username = username.lower()
    if user_id is None:
        s = &#34;INSERT INTO {entete}user&#34; \
            &#34; (auth, confirmed, username, firstname, lastname, email, maildisplay, city, country, lang,&#34; \
            &#34; mnethostid, theme )&#34; \
            &#34; VALUES (%(auth)s, %(confirmed)s, %(username)s, %(firstname)s, %(lastname)s, %(email)s,&#34; \
            &#34; %(maildisplay)s, %(city)s, %(country)s, %(lang)s, %(mnethostid)s, %(theme)s)&#34; \
            .format(entete=self.entete)

        self.mark.execute(s, params={&#39;auth&#39;: USER_AUTH,
                                     &#39;confirmed&#39;: 1,
                                     &#39;username&#39;: username,
                                     &#39;firstname&#39;: first_name,
                                     &#39;lastname&#39;: last_name,
                                     &#39;email&#39;: email,
                                     &#39;maildisplay&#39;: mail_display,
                                     &#39;city&#39;: USER_CITY,
                                     &#39;country&#39;: USER_COUNTRY,
                                     &#39;lang&#39;: USER_LANG,
                                     &#39;mnethostid&#39;: USER_MNET_HOST_ID,
                                     &#39;theme&#39;: theme})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.insert_moodle_user_info_data"><code class="name flex">
<span>def <span class="ident">insert_moodle_user_info_data</span></span>(<span>self, id_user, id_field, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'inserer un user info data.
:param id_user:
:param id_field:
:param data:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_moodle_user_info_data(self, id_user, id_field, data):
    &#34;&#34;&#34;
    Fonction permettant d&#39;inserer un user info data.
    :param id_user:
    :param id_field:
    :param data:
    :return:
    &#34;&#34;&#34;
    s = &#34;INSERT INTO {entete}user_info_data (userid, fieldid, data)&#34; \
        &#34; VALUES (%(id_user)s, %(id_field)s, %(data)s)&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;id_user&#39;: id_user, &#39;id_field&#39;: id_field, &#39;data&#39;: data})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.insert_moodle_user_info_field"><code class="name flex">
<span>def <span class="ident">insert_moodle_user_info_field</span></span>(<span>self, short_name, name, data_type, id_category, param1, param2, locked, visible)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'inserer un user info field.
:param short_name:
:param name:
:param data_type:
:param id_category:
:param param1:
:param param2:
:param locked:
:param visible:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_moodle_user_info_field(self, short_name, name, data_type, id_category, param1, param2, locked, visible):
    &#34;&#34;&#34;
    Fonction permettant d&#39;inserer un user info field.
    :param short_name:
    :param name:
    :param data_type:
    :param id_category:
    :param param1:
    :param param2:
    :param locked:
    :param visible:
    :return:
    &#34;&#34;&#34;
    s = &#34;INSERT INTO {entete}user_info_field&#34; \
        &#34; (shortname, name, datatype, categoryid, param1, param2, locked, visible)&#34; \
        &#34; VALUES (%(short_name)s, %(name)s, %(data_type)s, %(id_category)s, %(param1)s, %(param2)s, %(locked)s,&#34; \
        &#34; %(visible)s)&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;short_name&#39;: short_name,
                                 &#39;name&#39;: name,
                                 &#39;data_type&#39;: data_type,
                                 &#39;id_category&#39;: id_category,
                                 &#39;param1&#39;: param1,
                                 &#39;param2&#39;: param2,
                                 &#39;locked&#39;: locked,
                                 &#39;visible&#39;: visible})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.insert_zone_privee"><code class="name flex">
<span>def <span class="ident">insert_zone_privee</span></span>(<span>self, id_categorie_etablissement, siren, ou, time)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'inserer le cours correspondant
a la zone privee.
:param id_categorie_etablissement:
:param siren:
:param ou:
:param time:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_zone_privee(self, id_categorie_etablissement, siren, ou, time):
    &#34;&#34;&#34;
    Fonction permettant d&#39;inserer le cours correspondant
    a la zone privee.
    :param id_categorie_etablissement:
    :param siren:
    :param ou:
    :param time:
    :return:
    &#34;&#34;&#34;
    full_name = COURSE_FULLNAME_ZONE_PRIVEE
    id_number = short_name = COURSE_SHORTNAME_ZONE_PRIVEE % siren
    summary = COURSE_SUMMARY_ZONE_PRIVEE % ou.encode(&#34;utf-8&#34;)
    format_ = COURSE_FORMAT_ZONE_PRIVEE
    visible = COURSE_VISIBLE_ZONE_PRIVEE
    start_date = time_created = time_modified = time
    id_zone_privee = self.get_id_course_by_id_number(id_number)
    if id_zone_privee is not None:
        return id_zone_privee
    self.insert_moodle_course(id_categorie_etablissement, full_name, id_number, short_name, summary, format_,
                              visible, start_date, time_created, time_modified)
    id_zone_privee = self.get_id_course_by_id_number(id_number)
    return id_zone_privee</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.insert_zone_privee_context"><code class="name flex">
<span>def <span class="ident">insert_zone_privee_context</span></span>(<span>self, id_zone_privee)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant d'inserer le contexte correspondant
a la zone privee.
:param id_zone_privee:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_zone_privee_context(self, id_zone_privee):
    &#34;&#34;&#34;
    Fonction permettant d&#39;inserer le contexte correspondant
    a la zone privee.
    :param id_zone_privee:
    :return:
    &#34;&#34;&#34;
    id_contexte_zone_privee = self.get_id_context(self.constantes.niveau_ctx_cours, PROFONDEUR_CTX_ZONE_PRIVEE,
                                                  id_zone_privee)
    if id_contexte_zone_privee:
        return id_contexte_zone_privee

    id_contexte_zone_privee = self.get_id_context_no_depth(self.constantes.niveau_ctx_cours, id_zone_privee)
    if id_contexte_zone_privee:
        return id_contexte_zone_privee

    self.insert_moodle_context(self.constantes.niveau_ctx_cours, PROFONDEUR_CTX_ZONE_PRIVEE, id_zone_privee)
    id_contexte_zone_privee = self.get_id_context(self.constantes.niveau_ctx_cours, PROFONDEUR_CTX_ZONE_PRIVEE,
                                                  id_zone_privee)
    return id_contexte_zone_privee</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.is_enseignant_avance"><code class="name flex">
<span>def <span class="ident">is_enseignant_avance</span></span>(<span>self, id_user, id_role_enseignant_avance)</span>
</code></dt>
<dd>
<div class="desc"><p>:param id_user:
:param id_role_enseignant_avance:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_enseignant_avance(self, id_user, id_role_enseignant_avance):
    &#34;&#34;&#34;
    :param id_user:
    :param id_role_enseignant_avance:
    :return:
    &#34;&#34;&#34;
    sql = &#34;SELECT COUNT(id)&#34; \
          &#34; FROM {entete}role_assignments&#34; \
          &#34; WHERE userid = %(id_user)s&#34; \
          &#34; AND roleid = %(id_role_enseignant_avance)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(sql, params={&#39;id_user&#39;: id_user, &#39;id_role_enseignant_avance&#39;: id_role_enseignant_avance})
    result = self.safe_fetchone()
    return result[0] &gt; 0</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.is_moodle_local_admin"><code class="name flex">
<span>def <span class="ident">is_moodle_local_admin</span></span>(<span>self, id_context_categorie, id_user)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de vérifier si un utilisateur est
admin local pour un contexte donne.
:param id_context_categorie:
:param id_user:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_moodle_local_admin(self, id_context_categorie, id_user):
    &#34;&#34;&#34;
    Fonction permettant de vérifier si un utilisateur est
    admin local pour un contexte donne.
    :param id_context_categorie:
    :param id_user:
    :return:
    &#34;&#34;&#34;
    id_role_admin_local = self.get_id_role_admin_local()
    sql = &#34;SELECT COUNT(id) FROM {entete}role_assignments&#34; \
          &#34; WHERE roleid = %(id_role_admin_local)s&#34; \
          &#34; AND contextid = %(id_context_categorie)s&#34; \
          &#34; AND userid = %(id_user)s&#34; \
        .format(entete=self.entete)
    params = {&#39;id_role_admin_local&#39;: id_role_admin_local, &#39;id_context_categorie&#39;: id_context_categorie,
              &#39;id_user&#39;: id_user}
    self.mark.execute(sql, params=params)
    result = self.safe_fetchone()
    is_local_admin = result[0] &gt; 0
    return is_local_admin</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.purge_cohort_profs"><code class="name flex">
<span>def <span class="ident">purge_cohort_profs</span></span>(<span>self, id_cohort, list_profs)</span>
</code></dt>
<dd>
<div class="desc"><p>fonction permettant la purge d'une cohort de profs
:param id_cohort:
:param list_profs:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def purge_cohort_profs(self, id_cohort, list_profs):
    &#34;&#34;&#34;
    fonction permettant la purge d&#39;une cohort de profs
    :param id_cohort:
    :param list_profs:
    :return:
    &#34;&#34;&#34;
    ids_list, ids_list_params = array_to_safe_sql_list(list_profs, &#39;ids_list&#39;)
    s = &#34;DELETE FROM {entete}cohort_members&#34; \
        &#34; WHERE cohortid = %(id_cohort)s&#34; \
        &#34; AND userid NOT IN ({ids_list})&#34; \
        .format(entete=self.entete, ids_list=ids_list)
    self.mark.execute(s, params={&#39;id_cohort&#39;: id_cohort, **ids_list_params})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.purge_cohorts"><code class="name flex">
<span>def <span class="ident">purge_cohorts</span></span>(<span>self, users_ids_by_cohorts_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de purger des cohortes.
Le dictionnaire fourni en parametre indique la liste
des ids utilisateurs appartenant a une cohorte.
Ce dictionnaire est indexe par id de cohortes.
:param users_ids_by_cohorts_ids:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def purge_cohorts(self, users_ids_by_cohorts_ids):
    &#34;&#34;&#34;
    Fonction permettant de purger des cohortes.
    Le dictionnaire fourni en parametre indique la liste
    des ids utilisateurs appartenant a une cohorte.
    Ce dictionnaire est indexe par id de cohortes.
    :param users_ids_by_cohorts_ids:
    :return:
    &#34;&#34;&#34;
    for cohort_id, users_ids in users_ids_by_cohorts_ids.items():
        ids_list, ids_list_params = array_to_safe_sql_list(users_ids, &#39;ids_list&#39;)
        s = &#34;DELETE FROM {entete}cohort_members&#34; \
            &#34; WHERE cohortid = %(cohort_id)s&#34; \
            &#34; AND userid NOT IN ({ids_list})&#34; \
            .format(entete=self.entete, ids_list=ids_list)
        self.mark.execute(s, params={&#39;cohort_id&#39;: cohort_id, **ids_list_params})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.remove_role_to_user"><code class="name flex">
<span>def <span class="ident">remove_role_to_user</span></span>(<span>self, role_id, id_context, id_user)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de supprimer un role a un utilisateur
pour un contexte donne
:param role_id: int
:param id_context: int
:param id_user: int
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_role_to_user(self, role_id, id_context, id_user):
    &#34;&#34;&#34;
    Fonction permettant de supprimer un role a un utilisateur
    pour un contexte donne
    :param role_id: int
    :param id_context: int
    :param id_user: int
    :return:
    &#34;&#34;&#34;
    id_role_assignment = self.get_id_role_assignment(role_id, id_context, id_user)
    if id_role_assignment:
        # Ajout du role dans le contexte
        s = &#34;DELETE FROM {entete}role_assignments&#34; \
            &#34; WHERE roleid = %(role_id)s&#34; \
            &#34; AND contextid = %(id_context)s&#34; \
            &#34; AND userid = %(id_user)s&#34;.format(entete=self.entete)
        self.mark.execute(s, params={&#39;role_id&#39;: role_id, &#39;id_context&#39;: id_context, &#39;id_user&#39;: id_user})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.safe_fetchone"><code class="name flex">
<span>def <span class="ident">safe_fetchone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne uniquement 1 résultat et lève une exception si la requête invoquée récupère plusieurs resultats
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def safe_fetchone(self):
    &#34;&#34;&#34;
    Retourne uniquement 1 résultat et lève une exception si la requête invoquée récupère plusieurs resultats
    :return:
    &#34;&#34;&#34;
    rows = self.mark.fetchall()
    count = len(rows)
    if count &gt; 1:
        raise mysql.connector.DatabaseError(&#34;Résultat de requête SQL invalide: 1 résultat attendu, %d reçus:\n%s&#34;
                                            % (count, self.mark.statement))
    return rows[0] if count == 1 else None</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.set_user_domain"><code class="name flex">
<span>def <span class="ident">set_user_domain</span></span>(<span>self, id_user, id_field_domaine, user_domain)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction pour saisir le Domaine d'un utilisateur Moodle
:param id_user:
:param id_field_domaine:
:param user_domain:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_user_domain(self, id_user, id_field_domaine, user_domain):
    &#34;&#34;&#34;
    Fonction pour saisir le Domaine d&#39;un utilisateur Moodle
    :param id_user:
    :param id_field_domaine:
    :param user_domain:
    :return:
    &#34;&#34;&#34;
    # pour un utilisateur qui est déjà dans la table &#34;user_info_data&#34; mais sur un autre domaine que
    # le domaine &#34;user_domain&#34;,
    # le script va essayer de créer une nouvelle ligne (INSERT) avec le nouveau domaine =&gt; erreur !
    # la requête doit donc être modifiée :
    # sql = &#34;SELECT id FROM %suser_info_data WHERE userid = %s AND fieldid = %s AND data = &#39;%s&#39;&#34;
    sql = &#34;SELECT id&#34; \
          &#34; FROM {entete}user_info_data&#34; \
          &#34; WHERE userid = %(id_user)s&#34; \
          &#34; AND fieldid = %(id_field_domaine)s&#34; \
          &#34; LIMIT 1&#34; \
        .format(entete=self.entete)
    self.mark.execute(sql, params={&#39;id_user&#39;: id_user, &#39;id_field_domaine&#39;: id_field_domaine})

    result = self.safe_fetchone()
    if result:
        sql = &#34;REPLACE INTO {entete}user_info_data &#34; \
              &#34;(id, userid, fieldid, data)&#34; \
              &#34; VALUES (%(id)s, %(id_user)s, %(id_field_domaine)s, %(user_domain)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(sql, params={&#39;id&#39;: result[0],
                                       &#39;id_user&#39;: id_user,
                                       &#39;id_field_domaine&#39;: id_field_domaine,
                                       &#39;user_domain&#39;: user_domain})
    else:
        sql = &#34;INSERT INTO {entete}user_info_data &#34; \
              &#34;(userid, fieldid, data)&#34; \
              &#34; VALUES (%(id_user)s, %(id_field_domaine)s, %(user_domain)s)&#34; \
            .format(entete=self.entete)
        self.mark.execute(sql, params={&#39;id_user&#39;: id_user,
                                       &#39;id_field_domaine&#39;: id_field_domaine,
                                       &#39;user_domain&#39;: user_domain})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.update_context_path"><code class="name flex">
<span>def <span class="ident">update_context_path</span></span>(<span>self, id_context, new_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de mettre a jour le path d'un contexte.
:param id_context:
:param new_path:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_context_path(self, id_context, new_path):
    &#34;&#34;&#34;
    Fonction permettant de mettre a jour le path d&#39;un contexte.
    :param id_context:
    :param new_path:
    :return:
    &#34;&#34;&#34;
    s = &#34;UPDATE {entete}context&#34; \
        &#34; SET path = %(new_path)s&#34; \
        &#34; WHERE id = %(id_context)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;new_path&#39;: new_path, &#39;id_context&#39;: id_context})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.update_course_category_description"><code class="name flex">
<span>def <span class="ident">update_course_category_description</span></span>(<span>self, id_category, new_description)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de mettre a jour la description
d'une categorie.
:param id_category:
:param new_description:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_course_category_description(self, id_category, new_description):
    &#34;&#34;&#34;
    Fonction permettant de mettre a jour la description
    d&#39;une categorie.
    :param id_category:
    :param new_description:
    :return:
    &#34;&#34;&#34;
    s = &#34;UPDATE {entete}course_categories&#34; \
        &#34; SET description = %(new_description)s&#34; \
        &#34; WHERE id = %(id_category)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;new_description&#39;: new_description, &#39;id_category&#39;: id_category})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.update_course_category_name"><code class="name flex">
<span>def <span class="ident">update_course_category_name</span></span>(<span>self, id_category, new_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de mettre a jour le nom
d'une categorie.
:param id_category:
:param new_name:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_course_category_name(self, id_category, new_name):
    &#34;&#34;&#34;
    Fonction permettant de mettre a jour le nom
    d&#39;une categorie.
    :param id_category:
    :param new_name:
    :return:
    &#34;&#34;&#34;
    s = &#34;UPDATE {entete}course_categories&#34; \
        &#34; SET name = %(new_name)s&#34; \
        &#34; WHERE id = %(id_category)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;new_name&#39;: new_name, &#39;id_category&#39;: id_category})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.update_course_category_path"><code class="name flex">
<span>def <span class="ident">update_course_category_path</span></span>(<span>self, id_category, new_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de mettre a jour le path d'une
categorie.
:param id_category:
:param new_path:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_course_category_path(self, id_category, new_path):
    &#34;&#34;&#34;
    Fonction permettant de mettre a jour le path d&#39;une
    categorie.
    :param id_category:
    :param new_path:
    :return:
    &#34;&#34;&#34;
    s = &#34;UPDATE {entete}course_categories&#34; \
        &#34; SET path = %(new_path)s&#34; \
        &#34; WHERE id = %(id_category)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;new_path&#39;: new_path, &#39;id_category&#39;: id_category})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.update_moodle_user"><code class="name flex">
<span>def <span class="ident">update_moodle_user</span></span>(<span>self, id_user, first_name, last_name, email, mail_display, theme)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de mettre a jour un utilisateur
:param id_user:
:param first_name:
:param last_name:
:param email:
:param mail_display:
:param theme:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_moodle_user(self, id_user, first_name, last_name, email, mail_display, theme):
    &#34;&#34;&#34;
    Fonction permettant de mettre a jour un utilisateur
    :param id_user:
    :param first_name:
    :param last_name:
    :param email:
    :param mail_display:
    :param theme:
    :return:
    &#34;&#34;&#34;
    s = &#34;UPDATE {entete}user&#34; \
        &#34; SET auth = %(USER_AUTH)s, firstname = %(first_name)s, lastname = %(last_name)s, email = %(email)s,&#34; \
        &#34; maildisplay = %(mail_display)s, city = %(USER_CITY)s, country = %(USER_COUNTRY)s, lang = %(USER_LANG)s,&#34; \
        &#34; mnethostid = %(USER_MNET_HOST_ID)s, theme = %(theme)s&#34; \
        &#34; WHERE id = %(id_user)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;USER_AUTH&#39;: USER_AUTH,
                                 &#39;first_name&#39;: first_name,
                                 &#39;last_name&#39;: last_name,
                                 &#39;email&#39;: email,
                                 &#39;mail_display&#39;: mail_display,
                                 &#39;USER_CITY&#39;: USER_CITY,
                                 &#39;USER_COUNTRY&#39;: USER_COUNTRY,
                                 &#39;USER_LANG&#39;: USER_LANG,
                                 &#39;USER_MNET_HOST_ID&#39;: USER_MNET_HOST_ID,
                                 &#39;theme&#39;: theme,
                                 &#39;id_user&#39;: id_user})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.update_user_info_data"><code class="name flex">
<span>def <span class="ident">update_user_info_data</span></span>(<span>self, id_user, id_field, new_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction permettant de mettre a jour le data d'un user
info data.
:param id_user:
:param id_field:
:param new_data:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_user_info_data(self, id_user, id_field, new_data):
    &#34;&#34;&#34;
    Fonction permettant de mettre a jour le data d&#39;un user
    info data.
    :param id_user:
    :param id_field:
    :param new_data:
    :return:
    &#34;&#34;&#34;
    s = &#34;UPDATE {entete}user_info_data&#34; \
        &#34; SET data = %(new_data)s &#34; \
        &#34; WHERE userid = %(id_user)s&#34; \
        &#34; AND fieldid = %(id_field)s&#34; \
        .format(entete=self.entete)
    self.mark.execute(s, params={&#39;new_data&#39;: new_data, &#39;id_user&#39;: id_user, &#39;id_field&#39;: id_field})</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.user_has_role"><code class="name flex">
<span>def <span class="ident">user_has_role</span></span>(<span>self, userid, roles_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Vérifie si un utilisateur a au moins un role parmis une liste
:param userid:
:param roles_list:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def user_has_role(self, userid, roles_list):
    &#34;&#34;&#34;
    Vérifie si un utilisateur a au moins un role parmis une liste
    :param userid:
    :param roles_list:
    :return:
    &#34;&#34;&#34;
    ids_list, ids_list_params = array_to_safe_sql_list(roles_list, &#39;ids_list&#39;)
    self.mark.execute(&#34;SELECT COUNT(role.id)&#34;
                      &#34; FROM {entete}role AS role&#34;
                      &#34; INNER JOIN {entete}role_assignments AS role_assignments&#34;
                      &#34; ON role.id = role_assignments.roleid&#34;
                      &#34; WHERE role_assignments.userid = %(userid)s&#34;
                      &#34; AND role.id IN ({ids_list})&#34;.format(entete=self.entete, ids_list=ids_list),
                      params={
                          &#39;userid&#39;: userid,
                          **ids_list_params
                      })
    count = self.mark.fetchone()[0]
    return count &gt; 0</code></pre>
</details>
</dd>
<dt id="synchromoodle.dbutils.Database.user_has_used_moodle"><code class="name flex">
<span>def <span class="ident">user_has_used_moodle</span></span>(<span>self, user_id: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Indique si un utilisateur à déjà utilisé moodle, c'est-à-dire s'il s'est déjà connecté
:param user_id: L'id de l'utilisateur qu'on veut vérifier
:returns: Un booléen, qui vaut True si l'utilisateur à déjà utilisé moodle, et False sinon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def user_has_used_moodle(self, user_id: int):
    &#34;&#34;&#34;
    Indique si un utilisateur à déjà utilisé moodle, c&#39;est-à-dire s&#39;il s&#39;est déjà connecté
    :param user_id: L&#39;id de l&#39;utilisateur qu&#39;on veut vérifier
    :returns: Un booléen, qui vaut True si l&#39;utilisateur à déjà utilisé moodle, et False sinon
    &#34;&#34;&#34;
    s = &#34;SELECT lastlogin FROM {entete}user WHERE id = %(userid)s&#34;.format(entete=self.entete)
    self.mark.execute(s, params={&#39;userid&#39;: user_id})
    return self.mark.fetchone()[0] != 0</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="synchromoodle" href="index.html">synchromoodle</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="synchromoodle.dbutils.array_to_safe_sql_list" href="#synchromoodle.dbutils.array_to_safe_sql_list">array_to_safe_sql_list</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="synchromoodle.dbutils.Cohort" href="#synchromoodle.dbutils.Cohort">Cohort</a></code></h4>
</li>
<li>
<h4><code><a title="synchromoodle.dbutils.Database" href="#synchromoodle.dbutils.Database">Database</a></code></h4>
<ul class="">
<li><code><a title="synchromoodle.dbutils.Database.add_role_to_user" href="#synchromoodle.dbutils.Database.add_role_to_user">add_role_to_user</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.add_role_to_user_for_contexts" href="#synchromoodle.dbutils.Database.add_role_to_user_for_contexts">add_role_to_user_for_contexts</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.anonymize_users" href="#synchromoodle.dbutils.Database.anonymize_users">anonymize_users</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.config" href="#synchromoodle.dbutils.Database.config">config</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.connect" href="#synchromoodle.dbutils.Database.connect">connect</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.connection" href="#synchromoodle.dbutils.Database.connection">connection</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.constantes" href="#synchromoodle.dbutils.Database.constantes">constantes</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.create_cohort" href="#synchromoodle.dbutils.Database.create_cohort">create_cohort</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.delete_course" href="#synchromoodle.dbutils.Database.delete_course">delete_course</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.delete_moodle_assignment" href="#synchromoodle.dbutils.Database.delete_moodle_assignment">delete_moodle_assignment</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.delete_moodle_local_admin" href="#synchromoodle.dbutils.Database.delete_moodle_local_admin">delete_moodle_local_admin</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.delete_moodle_local_admins" href="#synchromoodle.dbutils.Database.delete_moodle_local_admins">delete_moodle_local_admins</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.delete_role_for_contexts" href="#synchromoodle.dbutils.Database.delete_role_for_contexts">delete_role_for_contexts</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.delete_roles" href="#synchromoodle.dbutils.Database.delete_roles">delete_roles</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.disconnect" href="#synchromoodle.dbutils.Database.disconnect">disconnect</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.disenroll_user_from_cohort" href="#synchromoodle.dbutils.Database.disenroll_user_from_cohort">disenroll_user_from_cohort</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.disenroll_user_from_cohorts" href="#synchromoodle.dbutils.Database.disenroll_user_from_cohorts">disenroll_user_from_cohorts</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.disenroll_user_from_username_and_cohortid" href="#synchromoodle.dbutils.Database.disenroll_user_from_username_and_cohortid">disenroll_user_from_username_and_cohortid</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.disenroll_user_from_username_and_cohortname" href="#synchromoodle.dbutils.Database.disenroll_user_from_username_and_cohortname">disenroll_user_from_username_and_cohortname</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.eleve_has_references" href="#synchromoodle.dbutils.Database.eleve_has_references">eleve_has_references</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.enroll_user_in_cohort" href="#synchromoodle.dbutils.Database.enroll_user_in_cohort">enroll_user_in_cohort</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.enroll_user_in_course" href="#synchromoodle.dbutils.Database.enroll_user_in_course">enroll_user_in_course</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.enseignant_has_references" href="#synchromoodle.dbutils.Database.enseignant_has_references">enseignant_has_references</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.entete" href="#synchromoodle.dbutils.Database.entete">entete</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_all_valid_users" href="#synchromoodle.dbutils.Database.get_all_valid_users">get_all_valid_users</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_cohort_members" href="#synchromoodle.dbutils.Database.get_cohort_members">get_cohort_members</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_cohort_name" href="#synchromoodle.dbutils.Database.get_cohort_name">get_cohort_name</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_course_timemodified" href="#synchromoodle.dbutils.Database.get_course_timemodified">get_course_timemodified</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_courses_ids_owned_by" href="#synchromoodle.dbutils.Database.get_courses_ids_owned_by">get_courses_ids_owned_by</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_courses_ids_owned_or_teach" href="#synchromoodle.dbutils.Database.get_courses_ids_owned_or_teach">get_courses_ids_owned_or_teach</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_description_course_category" href="#synchromoodle.dbutils.Database.get_description_course_category">get_description_course_category</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_descriptions_course_categories_by_themes" href="#synchromoodle.dbutils.Database.get_descriptions_course_categories_by_themes">get_descriptions_course_categories_by_themes</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_empty_cohorts" href="#synchromoodle.dbutils.Database.get_empty_cohorts">get_empty_cohorts</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_field_domaine" href="#synchromoodle.dbutils.Database.get_field_domaine">get_field_domaine</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_block" href="#synchromoodle.dbutils.Database.get_id_block">get_id_block</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_categorie" href="#synchromoodle.dbutils.Database.get_id_categorie">get_id_categorie</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_cohort" href="#synchromoodle.dbutils.Database.get_id_cohort">get_id_cohort</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_context" href="#synchromoodle.dbutils.Database.get_id_context">get_id_context</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_context_categorie" href="#synchromoodle.dbutils.Database.get_id_context_categorie">get_id_context_categorie</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_context_inter_etabs" href="#synchromoodle.dbutils.Database.get_id_context_inter_etabs">get_id_context_inter_etabs</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_context_no_depth" href="#synchromoodle.dbutils.Database.get_id_context_no_depth">get_id_context_no_depth</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_course_by_id_number" href="#synchromoodle.dbutils.Database.get_id_course_by_id_number">get_id_course_by_id_number</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_course_category_by_id_number" href="#synchromoodle.dbutils.Database.get_id_course_category_by_id_number">get_id_course_category_by_id_number</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_course_category_by_theme" href="#synchromoodle.dbutils.Database.get_id_course_category_by_theme">get_id_course_category_by_theme</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_course_module" href="#synchromoodle.dbutils.Database.get_id_course_module">get_id_course_module</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_enrol" href="#synchromoodle.dbutils.Database.get_id_enrol">get_id_enrol</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_enrol_max" href="#synchromoodle.dbutils.Database.get_id_enrol_max">get_id_enrol_max</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_forum" href="#synchromoodle.dbutils.Database.get_id_forum">get_id_forum</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_role_admin_local" href="#synchromoodle.dbutils.Database.get_id_role_admin_local">get_id_role_admin_local</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_role_assignment" href="#synchromoodle.dbutils.Database.get_id_role_assignment">get_id_role_assignment</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_role_by_shortname" href="#synchromoodle.dbutils.Database.get_id_role_by_shortname">get_id_role_by_shortname</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_user_enrolment" href="#synchromoodle.dbutils.Database.get_id_user_enrolment">get_id_user_enrolment</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_user_info_data" href="#synchromoodle.dbutils.Database.get_id_user_info_data">get_id_user_info_data</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_id_user_info_field_by_shortname" href="#synchromoodle.dbutils.Database.get_id_user_info_field_by_shortname">get_id_user_info_field_by_shortname</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_ids_and_summaries_not_allowed_roles" href="#synchromoodle.dbutils.Database.get_ids_and_summaries_not_allowed_roles">get_ids_and_summaries_not_allowed_roles</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_ids_and_themes_not_allowed_roles" href="#synchromoodle.dbutils.Database.get_ids_and_themes_not_allowed_roles">get_ids_and_themes_not_allowed_roles</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_timestamp_now" href="#synchromoodle.dbutils.Database.get_timestamp_now">get_timestamp_now</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_user_data" href="#synchromoodle.dbutils.Database.get_user_data">get_user_data</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_user_filtered_cohorts" href="#synchromoodle.dbutils.Database.get_user_filtered_cohorts">get_user_filtered_cohorts</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_user_id" href="#synchromoodle.dbutils.Database.get_user_id">get_user_id</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_userids_owner_of_course" href="#synchromoodle.dbutils.Database.get_userids_owner_of_course">get_userids_owner_of_course</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.get_users_ids" href="#synchromoodle.dbutils.Database.get_users_ids">get_users_ids</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.insert_moodle_block" href="#synchromoodle.dbutils.Database.insert_moodle_block">insert_moodle_block</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.insert_moodle_context" href="#synchromoodle.dbutils.Database.insert_moodle_context">insert_moodle_context</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.insert_moodle_course" href="#synchromoodle.dbutils.Database.insert_moodle_course">insert_moodle_course</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.insert_moodle_course_category" href="#synchromoodle.dbutils.Database.insert_moodle_course_category">insert_moodle_course_category</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.insert_moodle_course_module" href="#synchromoodle.dbutils.Database.insert_moodle_course_module">insert_moodle_course_module</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.insert_moodle_enrol_capability" href="#synchromoodle.dbutils.Database.insert_moodle_enrol_capability">insert_moodle_enrol_capability</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.insert_moodle_forum" href="#synchromoodle.dbutils.Database.insert_moodle_forum">insert_moodle_forum</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.insert_moodle_local_admin" href="#synchromoodle.dbutils.Database.insert_moodle_local_admin">insert_moodle_local_admin</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.insert_moodle_user" href="#synchromoodle.dbutils.Database.insert_moodle_user">insert_moodle_user</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.insert_moodle_user_info_data" href="#synchromoodle.dbutils.Database.insert_moodle_user_info_data">insert_moodle_user_info_data</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.insert_moodle_user_info_field" href="#synchromoodle.dbutils.Database.insert_moodle_user_info_field">insert_moodle_user_info_field</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.insert_zone_privee" href="#synchromoodle.dbutils.Database.insert_zone_privee">insert_zone_privee</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.insert_zone_privee_context" href="#synchromoodle.dbutils.Database.insert_zone_privee_context">insert_zone_privee_context</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.is_enseignant_avance" href="#synchromoodle.dbutils.Database.is_enseignant_avance">is_enseignant_avance</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.is_moodle_local_admin" href="#synchromoodle.dbutils.Database.is_moodle_local_admin">is_moodle_local_admin</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.mark" href="#synchromoodle.dbutils.Database.mark">mark</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.purge_cohort_profs" href="#synchromoodle.dbutils.Database.purge_cohort_profs">purge_cohort_profs</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.purge_cohorts" href="#synchromoodle.dbutils.Database.purge_cohorts">purge_cohorts</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.remove_role_to_user" href="#synchromoodle.dbutils.Database.remove_role_to_user">remove_role_to_user</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.safe_fetchone" href="#synchromoodle.dbutils.Database.safe_fetchone">safe_fetchone</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.set_user_domain" href="#synchromoodle.dbutils.Database.set_user_domain">set_user_domain</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.update_context_path" href="#synchromoodle.dbutils.Database.update_context_path">update_context_path</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.update_course_category_description" href="#synchromoodle.dbutils.Database.update_course_category_description">update_course_category_description</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.update_course_category_name" href="#synchromoodle.dbutils.Database.update_course_category_name">update_course_category_name</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.update_course_category_path" href="#synchromoodle.dbutils.Database.update_course_category_path">update_course_category_path</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.update_moodle_user" href="#synchromoodle.dbutils.Database.update_moodle_user">update_moodle_user</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.update_user_info_data" href="#synchromoodle.dbutils.Database.update_user_info_data">update_user_info_data</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.user_has_role" href="#synchromoodle.dbutils.Database.user_has_role">user_has_role</a></code></li>
<li><code><a title="synchromoodle.dbutils.Database.user_has_used_moodle" href="#synchromoodle.dbutils.Database.user_has_used_moodle">user_has_used_moodle</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>